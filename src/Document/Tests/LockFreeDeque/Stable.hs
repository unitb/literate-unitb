{-# LANGUAGE OverloadedStrings #-}
module Document.Tests.LockFreeDeque.Stable where

result0 :: String
result0 = unlines
    [ "  o  m0/INIT/INV/m0:inv0"
    , "  o  m0/INIT/INV/m0:inv1"
    , "  o  m0/m0:pop:left/FIS/p@prime"
    , "  o  m0/m0:pop:left/FIS/res@prime"
    , "  o  m0/m0:pop:left/INV/m0:inv0"
    , "  o  m0/m0:pop:left/INV/m0:inv1"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act3"
    , "  o  m0/m0:pop:right/FIS/q@prime"
    , "  o  m0/m0:pop:right/FIS/res@prime"
    , "  o  m0/m0:pop:right/INV/m0:inv0"
    , "  o  m0/m0:pop:right/INV/m0:inv1"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act3"
    , "  o  m0/m0:push:left/INV/m0:inv0"
    , "  o  m0/m0:push:left/INV/m0:inv1"
    , "  o  m0/m0:push:right/INV/m0:inv0"
    , "  o  m0/m0:push:right/INV/m0:inv1"
    , "passed 16 / 16"
    ]

result1 :: String
result1 = unlines
    [ "  o  m0/INIT/INV/m0:inv0"
    , "  o  m0/m0:pop:left/FIS/p@prime"
    , "  o  m0/m0:pop:left/FIS/q@prime"
    , "  o  m0/m0:pop:left/FIS/qe@prime"
    , "  o  m0/m0:pop:left/INV/m0:inv0"
    , "  o  m0/m0:pop:left/SCH"
    , "  o  m0/m0:pop:right/FIS/p@prime"
    , "  o  m0/m0:pop:right/FIS/q@prime"
    , "  o  m0/m0:pop:right/FIS/qe@prime"
    , "  o  m0/m0:pop:right/INV/m0:inv0"
    , "  o  m0/m0:pop:right/SCH"
    , "  o  m0/m0:push:left/FIS/p@prime"
    , "  o  m0/m0:push:left/FIS/q@prime"
    , "  o  m0/m0:push:left/FIS/qe@prime"
    , " xxx m0/m0:push:left/INV/m0:inv0"
    , "  o  m0/m0:push:right/FIS/p@prime"
    , "  o  m0/m0:push:right/FIS/q@prime"
    , "  o  m0/m0:push:right/FIS/qe@prime"
    , " xxx m0/m0:push:right/INV/m0:inv0"
    , "passed 17 / 19"
    ]

result2 :: String
result2 = unlines
    [ "Multiple expressions with the label m0:inv0"
    , "error 42:1:"
    , "\tinvariant"
    , ""
    , "error 44:4:"
    , "\tinvariant"
    , ""
    , ""
    , "Multiple expressions with the label m0:grd0"
    , "error 86:4:"
    , "\tguard (event 'm0:pop:right')"
    , ""
    , "error 87:4:"
    , "\tguard (event 'm0:pop:right')"
    , ""
    ]

result3 :: String
result3 = unlines
    [ "  o  m0/INIT/INV/m0:inv0"
    , "  o  m0/INIT/INV/m0:inv1"
    , "  o  m0/m0:pop:left/FIS/p@prime"
    , "  o  m0/m0:pop:left/FIS/q@prime"
    , "  o  m0/m0:pop:left/FIS/qe@prime"
    , "  o  m0/m0:pop:left/INV/m0:inv0"
    , "  o  m0/m0:pop:left/INV/m0:inv1"
    , "  o  m0/m0:pop:left/SCH"
    , "  o  m0/m0:pop:left/SCH/x"
    , " xxx m0/m0:pop:left/WD/GRD"
    , "  o  m0/m0:pop:right/FIS/p@prime"
    , "  o  m0/m0:pop:right/FIS/q@prime"
    , "  o  m0/m0:pop:right/FIS/qe@prime"
    , "  o  m0/m0:pop:right/INV/m0:inv0"
    , "  o  m0/m0:pop:right/INV/m0:inv1"
    , "  o  m0/m0:pop:right/SCH"
    , "  o  m0/m0:pop:right/SCH/x"
    , "  o  m0/m0:pop:right/WD/GRD"
    , "  o  m0/m0:push:left/FIS/p@prime"
    , "  o  m0/m0:push:left/FIS/q@prime"
    , "  o  m0/m0:push:left/FIS/qe@prime"
    , "  o  m0/m0:push:left/INV/m0:inv0"
    , "  o  m0/m0:push:left/INV/m0:inv1"
    , "  o  m0/m0:push:right/FIS/p@prime"
    , "  o  m0/m0:push:right/FIS/q@prime"
    , "  o  m0/m0:push:right/FIS/qe@prime"
    , "  o  m0/m0:push:right/INV/m0:inv0"
    , "  o  m0/m0:push:right/INV/m0:inv1"
    , "  o  m0/m0:push:right/SCH/x"
    , " xxx m0/m0:push:right/WD/GRD"
    , "passed 28 / 30"
    ]

result4 :: String
result4 = unlines
    [ "  o  m1/INIT/INV/m1:inv0"
    , "  o  m1/INIT/INV/m1:inv1"
    , "  o  m1/LIVE/m1:prog0/ensure/SAF/WD/lhs"
    , "  o  m1/LIVE/m1:prog0/ensure/SAF/WD/rhs"
    , "  o  m1/LIVE/m1:prog0/ensure/TR/WD"
    , "  o  m1/LIVE/m1:prog0/ensure/TR/WFIS/r/r@prime"
    , "  o  m1/LIVE/m1:prog0/ensure/TR/m0:push:left/EN"
    , "  o  m1/LIVE/m1:prog0/ensure/TR/m0:push:left/NEG"
    , "  o  m1/LIVE/m1:prog1/ensure/SAF/WD/lhs"
    , "  o  m1/LIVE/m1:prog1/ensure/SAF/WD/rhs"
    , "  o  m1/LIVE/m1:prog1/ensure/TR/WD"
    , "  o  m1/LIVE/m1:prog1/ensure/TR/WFIS/r/r@prime"
    , "  o  m1/LIVE/m1:prog1/ensure/TR/m0:push:right/EN"
    , "  o  m1/LIVE/m1:prog1/ensure/TR/m0:push:right/NEG"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/WFIS/r/r@prime"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/leadsto"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/m0:pop:right:empty/EN"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/m0:pop:right:empty/NEG"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/m0:pop:right:non:empty/EN"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/m0:pop:right:non:empty/NEG"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/WFIS/r/r@prime"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/leadsto"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/EN"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/NEG"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/EN"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/NEG"
    , "  o  m1/m0:pop:left:empty/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:pop:left:empty/F_SCH/replace/eqv"
    , "  o  m1/m0:pop:left:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:left:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:left:empty/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:pop:left:empty/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:pop:left:empty/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:pop:left:empty/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:pop:left:empty/SCH/m0:grd0"
    , "  o  m1/m0:pop:left:non:empty/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:pop:left:non:empty/F_SCH/replace/eqv"
    , "  o  m1/m0:pop:left:non:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:left:non:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:left:non:empty/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:pop:left:non:empty/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:pop:left:non:empty/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:pop:left:non:empty/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:pop:left:non:empty/SCH/m0:grd0"
    , "  o  m1/m0:pop:left:non:empty/SCH/m1:grd0"
    , "  o  m1/m0:pop:left:non:empty/WD/ACT/m1:a5"
    , "  o  m1/m0:pop:right:empty/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:pop:right:empty/F_SCH/replace/eqv"
    , "  o  m1/m0:pop:right:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:right:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:right:empty/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:pop:right:empty/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:pop:right:empty/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:pop:right:empty/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:pop:right:empty/SCH/m0:grd0"
    , "  o  m1/m0:pop:right:non:empty/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:pop:right:non:empty/F_SCH/replace/eqv"
    , "  o  m1/m0:pop:right:non:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:right:non:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:right:non:empty/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:pop:right:non:empty/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:pop:right:non:empty/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:pop:right:non:empty/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:pop:right:non:empty/SCH/m0:grd0"
    , "  o  m1/m0:pop:right:non:empty/SCH/m1:grd0"
    , "  o  m1/m0:pop:right:non:empty/WD/ACT/m1:a3"
    , "  o  m1/m0:push:left/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:push:left/INV/m1:inv0"
    , "  o  m1/m0:push:left/INV/m1:inv1"
    , "  o  m1/m0:push:left/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:push:left/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:push:left/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:push:left/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:push:left/SCH"
    , "  o  m1/m0:push:left/SCH/x"
    , "  o  m1/m0:push:left/WD/GRD"
    , "  o  m1/m0:push:right/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:push:right/INV/m1:inv0"
    , "  o  m1/m0:push:right/INV/m1:inv1"
    , "  o  m1/m0:push:right/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:push:right/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:push:right/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:push:right/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:push:right/SCH"
    , "  o  m1/m0:push:right/SCH/x"
    , "  o  m1/m0:push:right/WD/GRD"
    , "  o  m1/m1:prog0/PROG/WD/lhs"
    , "  o  m1/m1:prog0/PROG/WD/rhs"
    , "  o  m1/m1:prog1/PROG/WD/lhs"
    , "  o  m1/m1:prog1/PROG/WD/rhs"
    , "passed 90 / 90"
    ]

    -- enablement non-empty
result5 :: String
result5 = unlines 
    [ "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/EN"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl$G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl$REQ))"
    , "(declare-const popL@prime (set sl$REQ))"
    , "(declare-const popR (set sl$REQ))"
    , "(declare-const popR@prime (set sl$REQ))"
    , "(declare-const pshL (pfun sl$REQ sl$G))"
    , "(declare-const pshL@prime (pfun sl$REQ sl$G))"
    , "(declare-const pshR (pfun sl$REQ sl$G))"
    , "(declare-const pshR@prime (pfun sl$REQ sl$G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl$G))"
    , "(declare-const qe@prime (pfun Int sl$G))"
    , "(declare-const r sl$REQ)"
    , "(declare-const res sl$G)"
    , "(declare-const res@prime sl$G)"
    , "(declare-const resL (pfun sl$REQ sl$G))"
    , "(declare-const resL@prime (pfun sl$REQ sl$G))"
    , "(declare-const resR (pfun sl$REQ sl$G))"
    , "(declare-const resR@prime (pfun sl$REQ sl$G))"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$G ( (set sl$G) ) Int)"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Int)"
    , "(declare-fun dom@@Int@@sl$G ( (pfun Int sl$G) ) (set Int))"
    , "(declare-fun dom@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom-rest@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun dom-subt@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun empty-fun@@Int@@sl$G () (pfun Int sl$G))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$G () (pfun sl$REQ sl$G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$G ( (set sl$G) ) Bool)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl$G ( (pfun Int sl$G) ) Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$REQ (sl$REQ) (set sl$REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (pfun Int sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun ovl@@Int@@sl$G"
    , "             ( (pfun Int sl$G)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun ovl@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun pfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun r@param () sl$REQ)"
    , "(declare-fun ran@@Int@@sl$G ( (pfun Int sl$G) ) (set sl$G))"
    , "(declare-fun ran@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) (set sl$G))"
    , "(declare-fun tfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              true ))"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$G"
    , "            ( (s1 (set sl$G)) )"
    , "            (set sl$G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$REQ"
    , "            ( (x sl$REQ)"
    , "              (s1 (set sl$REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (x (pfun Int sl$G))"
    , "              (s1 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              false ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            (set sl$G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$G () (set sl$G) ( (as const (set sl$G)) true ))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (=> (finite@@sl$G r) (<= 0 (card@@sl$G r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$G r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (= (= (card@@sl$G r) 0) (= r empty-set@@sl$G))"
    , "                   :pattern"
    , "                   ( (card@@sl$G r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (= (card@@sl$REQ (mk-set@@sl$REQ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$G)) )"
    , "                              (and true (= r (mk-set@Open@@pfun@@Int@@sl$G@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 1)"
    , "                      (exists ( (x sl$REQ) ) (and true (= r (mk-set@@sl$REQ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G)))"
    , "                  (r0 (set (pfun Int sl$G))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$G@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$G@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$G@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$G@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$G))"
    , "                  (r0 (set sl$G)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$G)"
    , "                       (= (card@@sl$G (union r r0))"
    , "                          (+ (card@@sl$G r) (card@@sl$G r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$G (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (= (dom@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$REQ))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) ))))"
    , "(assert (forall ( (s2 (set sl$G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                     (tfun@@Int@@sl$G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                       (tfun@@Int@@sl$G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G)) )"
    , "                (! (= (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2))"
    , "                      (union (dom@@Int@@sl$G f1) (dom@@Int@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$G f1) (dom@@sl$REQ@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (= (ran@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (= (ran@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$G f1))"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$G f1) s1)"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (injective@@Int@@sl$G empty-fun@@Int@@sl$G))"
    , "(assert (injective@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G))"
    , "                  (y (pfun Int sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$REQ) )"
    , "                (! (= (elem@@sl$REQ x (mk-set@@sl$REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (mk-set@@sl$REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (finite@@sl$G s1)"
    , "                       (finite@@sl$G (set-diff@@sl$G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s1) (finite@@sl$G s2))"
    , "                       (finite@@sl$G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))"
    , "                       (not (finite@@Int (set-diff@@Int s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                            (not (finite@Open@@pfun@@Int@@sl$G@Close s1)))"
    , "                       (not (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s2) (not (finite@@sl$G s1)))"
    , "                       (not (finite@@sl$G (set-diff@@sl$G s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s2) (not (finite@@sl$REQ s1)))"
    , "                       (not (finite@@sl$REQ (set-diff@@sl$REQ s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (finite@@sl$REQ (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl$G@Close empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "(assert (finite@@sl$G empty-set@@sl$G))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (= r@param r))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$G@Close qe (tfun@@Int@@sl$G (intervalR p q) sl$G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resR) popR)"
    , "           empty-set@@sl$REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resL) popL)"
    , "           empty-set@@sl$REQ))"
    , "(assert (not (=> (and (elem@@sl$REQ r popL) (elem@@sl$REQ r popL))"
    , "                 (elem@@sl$REQ r@param popL))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/EN"
    ]

result6 :: String
result6 = unlines 
    [ "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/EN"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl$G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl$REQ))"
    , "(declare-const popL@prime (set sl$REQ))"
    , "(declare-const popR (set sl$REQ))"
    , "(declare-const popR@prime (set sl$REQ))"
    , "(declare-const pshL (pfun sl$REQ sl$G))"
    , "(declare-const pshL@prime (pfun sl$REQ sl$G))"
    , "(declare-const pshR (pfun sl$REQ sl$G))"
    , "(declare-const pshR@prime (pfun sl$REQ sl$G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl$G))"
    , "(declare-const qe@prime (pfun Int sl$G))"
    , "(declare-const r sl$REQ)"
    , "(declare-const res sl$G)"
    , "(declare-const res@prime sl$G)"
    , "(declare-const resL (pfun sl$REQ sl$G))"
    , "(declare-const resL@prime (pfun sl$REQ sl$G))"
    , "(declare-const resR (pfun sl$REQ sl$G))"
    , "(declare-const resR@prime (pfun sl$REQ sl$G))"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$G ( (set sl$G) ) Int)"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Int)"
    , "(declare-fun dom@@Int@@sl$G ( (pfun Int sl$G) ) (set Int))"
    , "(declare-fun dom@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom-rest@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun dom-subt@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun empty-fun@@Int@@sl$G () (pfun Int sl$G))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$G () (pfun sl$REQ sl$G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$G ( (set sl$G) ) Bool)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl$G ( (pfun Int sl$G) ) Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$REQ (sl$REQ) (set sl$REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (pfun Int sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun ovl@@Int@@sl$G"
    , "             ( (pfun Int sl$G)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun ovl@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun pfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun r@param () sl$REQ)"
    , "(declare-fun ran@@Int@@sl$G ( (pfun Int sl$G) ) (set sl$G))"
    , "(declare-fun ran@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) (set sl$G))"
    , "(declare-fun tfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              true ))"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$G"
    , "            ( (s1 (set sl$G)) )"
    , "            (set sl$G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$REQ"
    , "            ( (x sl$REQ)"
    , "              (s1 (set sl$REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (x (pfun Int sl$G))"
    , "              (s1 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              false ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            (set sl$G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$G () (set sl$G) ( (as const (set sl$G)) true ))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (=> (finite@@sl$G r) (<= 0 (card@@sl$G r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$G r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (= (= (card@@sl$G r) 0) (= r empty-set@@sl$G))"
    , "                   :pattern"
    , "                   ( (card@@sl$G r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (= (card@@sl$REQ (mk-set@@sl$REQ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$G)) )"
    , "                              (and true (= r (mk-set@Open@@pfun@@Int@@sl$G@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 1)"
    , "                      (exists ( (x sl$REQ) ) (and true (= r (mk-set@@sl$REQ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G)))"
    , "                  (r0 (set (pfun Int sl$G))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$G@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$G@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$G@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$G@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$G))"
    , "                  (r0 (set sl$G)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$G)"
    , "                       (= (card@@sl$G (union r r0))"
    , "                          (+ (card@@sl$G r) (card@@sl$G r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$G (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (= (dom@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$REQ))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) ))))"
    , "(assert (forall ( (s2 (set sl$G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                     (tfun@@Int@@sl$G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                       (tfun@@Int@@sl$G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G)) )"
    , "                (! (= (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2))"
    , "                      (union (dom@@Int@@sl$G f1) (dom@@Int@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$G f1) (dom@@sl$REQ@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (= (ran@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (= (ran@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$G f1))"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$G f1) s1)"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (injective@@Int@@sl$G empty-fun@@Int@@sl$G))"
    , "(assert (injective@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G))"
    , "                  (y (pfun Int sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$REQ) )"
    , "                (! (= (elem@@sl$REQ x (mk-set@@sl$REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (mk-set@@sl$REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (finite@@sl$G s1)"
    , "                       (finite@@sl$G (set-diff@@sl$G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s1) (finite@@sl$G s2))"
    , "                       (finite@@sl$G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))"
    , "                       (not (finite@@Int (set-diff@@Int s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                            (not (finite@Open@@pfun@@Int@@sl$G@Close s1)))"
    , "                       (not (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s2) (not (finite@@sl$G s1)))"
    , "                       (not (finite@@sl$G (set-diff@@sl$G s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s2) (not (finite@@sl$REQ s1)))"
    , "                       (not (finite@@sl$REQ (set-diff@@sl$REQ s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (finite@@sl$REQ (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl$G@Close empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "(assert (finite@@sl$G empty-set@@sl$G))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (= r@param r))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$G@Close qe (tfun@@Int@@sl$G (intervalR p q) sl$G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resR) popR)"
    , "           empty-set@@sl$REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resL) popL)"
    , "           empty-set@@sl$REQ))"
    , "(assert (not (=> (and (elem@@sl$REQ r popL) (elem@@sl$REQ r popL))"
    , "                 (elem@@sl$REQ r@param popL))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/EN"
    ]

result7 :: String
result7 = unlines 
    [ "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/NEG"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl$G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl$REQ))"
    , "(declare-const popL@prime (set sl$REQ))"
    , "(declare-const popR (set sl$REQ))"
    , "(declare-const popR@prime (set sl$REQ))"
    , "(declare-const pshL (pfun sl$REQ sl$G))"
    , "(declare-const pshL@prime (pfun sl$REQ sl$G))"
    , "(declare-const pshR (pfun sl$REQ sl$G))"
    , "(declare-const pshR@prime (pfun sl$REQ sl$G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl$G))"
    , "(declare-const qe@prime (pfun Int sl$G))"
    , "(declare-const r sl$REQ)"
    , "(declare-const res sl$G)"
    , "(declare-const res@prime sl$G)"
    , "(declare-const resL (pfun sl$REQ sl$G))"
    , "(declare-const resL@prime (pfun sl$REQ sl$G))"
    , "(declare-const resR (pfun sl$REQ sl$G))"
    , "(declare-const resR@prime (pfun sl$REQ sl$G))"
    , "(declare-fun apply@@Int@@sl$G ( (pfun Int sl$G) Int ) sl$G)"
    , "(declare-fun apply@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G)"
    , "               sl$REQ )"
    , "             sl$G)"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$G ( (set sl$G) ) Int)"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Int)"
    , "(declare-fun dom@@Int@@sl$G ( (pfun Int sl$G) ) (set Int))"
    , "(declare-fun dom@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom-rest@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun dom-subt@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun empty-fun@@Int@@sl$G () (pfun Int sl$G))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$G () (pfun sl$REQ sl$G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$G ( (set sl$G) ) Bool)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl$G ( (pfun Int sl$G) ) Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@sl$G (Int sl$G) (pfun Int sl$G))"
    , "(declare-fun mk-fun@@sl$REQ@@sl$G"
    , "             (sl$REQ sl$G)"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$G (sl$G) (set sl$G))"
    , "(declare-fun mk-set@@sl$REQ (sl$REQ) (set sl$REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (pfun Int sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun ovl@@Int@@sl$G"
    , "             ( (pfun Int sl$G)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun ovl@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun pfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun r@param () sl$REQ)"
    , "(declare-fun ran@@Int@@sl$G ( (pfun Int sl$G) ) (set sl$G))"
    , "(declare-fun ran@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) (set sl$G))"
    , "(declare-fun tfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              true ))"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$G"
    , "            ( (s1 (set sl$G)) )"
    , "            (set sl$G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$G"
    , "            ( (x sl$G)"
    , "              (s1 (set sl$G)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$REQ"
    , "            ( (x sl$REQ)"
    , "              (s1 (set sl$REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (x (pfun Int sl$G))"
    , "              (s1 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              false ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            (set sl$G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$G () (set sl$G) ( (as const (set sl$G)) true ))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (=> (finite@@sl$G r) (<= 0 (card@@sl$G r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$G r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (= (= (card@@sl$G r) 0) (= r empty-set@@sl$G))"
    , "                   :pattern"
    , "                   ( (card@@sl$G r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$G) )"
    , "                (! (= (card@@sl$G (mk-set@@sl$G x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$G (mk-set@@sl$G x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (= (card@@sl$REQ (mk-set@@sl$REQ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$G)) )"
    , "                              (and true (= r (mk-set@Open@@pfun@@Int@@sl$G@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (= (= (card@@sl$G r) 1)"
    , "                      (exists ( (x sl$G) ) (and true (= r (mk-set@@sl$G x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$G r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 1)"
    , "                      (exists ( (x sl$REQ) ) (and true (= r (mk-set@@sl$REQ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G)))"
    , "                  (r0 (set (pfun Int sl$G))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$G@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$G@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$G@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$G@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$G))"
    , "                  (r0 (set sl$G)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$G)"
    , "                       (= (card@@sl$G (union r r0))"
    , "                          (+ (card@@sl$G r) (card@@sl$G r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$G (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (= (dom@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$REQ))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (dom@@Int@@sl$G (mk-fun@@Int@@sl$G x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (mk-fun@@Int@@sl$G x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y))"
    , "                      (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$G f2))"
    , "                       (= (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 f2) x)"
    , "                          (apply@@Int@@sl$G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f2))"
    , "                       (= (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl$G f2))))"
    , "                       (= (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 f2) x)"
    , "                          (apply@@Int@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                            (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f2))))"
    , "                       (= (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (apply@@Int@@sl$G (mk-fun@@Int@@sl$G x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (mk-fun@@Int@@sl$G x y) x) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (apply@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl$G f1)))"
    , "                       (= (apply@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1) x)"
    , "                          (apply@@Int@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x s1)"
    , "                            (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1)))"
    , "                       (= (apply@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                       (= (apply@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1) x)"
    , "                          (apply@@Int@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                       (= (apply@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1) x) ))))"
    , "(assert (forall ( (s2 (set sl$G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                     (tfun@@Int@@sl$G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                       (tfun@@Int@@sl$G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G)) )"
    , "                (! (= (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2))"
    , "                      (union (dom@@Int@@sl$G f1) (dom@@Int@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$G f1) (dom@@sl$REQ@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                           (= (apply@@Int@@sl$G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                     (apply@@Int@@sl$G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                           (= (apply@@Int@@sl$G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                     (apply@@Int@@sl$G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                           (= (apply@@sl$REQ@@sl$G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                     (apply@@sl$REQ@@sl$G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                           (= (apply@@sl$REQ@@sl$G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                     (apply@@sl$REQ@@sl$G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl$G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)) x2)"
    , "                          (apply@@Int@@sl$G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (x2 sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))"
    , "                                               x2)"
    , "                          (apply@@sl$REQ@@sl$G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))"
    , "                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))"
    , "                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))"
    , "                                          x) ))))"
    , "(assert (= (ran@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (= (ran@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (y sl$G) )"
    , "                (! (= (elem@@sl$G y (ran@@Int@@sl$G f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                                        (= (apply@@Int@@sl$G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G y (ran@@Int@@sl$G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (y sl$G) )"
    , "                (! (= (elem@@sl$G y (ran@@sl$REQ@@sl$G f1))"
    , "                      (exists ( (x sl$REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                                        (= (apply@@sl$REQ@@sl$G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G y (ran@@sl$REQ@@sl$G f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (ran@@Int@@sl$G (mk-fun@@Int@@sl$G x y))"
    , "                      (mk-set@@sl$G y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$G (mk-fun@@Int@@sl$G x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (ran@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y))"
    , "                      (mk-set@@sl$G y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$G f1))"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$G f1) s1)"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (injective@@Int@@sl$G f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl$G f1)))"
    , "                                  (=> (= (apply@@Int@@sl$G f1 x) (apply@@Int@@sl$G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl$G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (injective@@sl$REQ@@sl$G f1)"
    , "                      (forall ( (x sl$REQ)"
    , "                                (x2 sl$REQ) )"
    , "                              (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                                       (elem@@sl$REQ x2 (dom@@sl$REQ@@sl$G f1)))"
    , "                                  (=> (= (apply@@sl$REQ@@sl$G f1 x)"
    , "                                         (apply@@sl$REQ@@sl$G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$REQ@@sl$G f1) ))))"
    , "(assert (injective@@Int@@sl$G empty-fun@@Int@@sl$G))"
    , "(assert (injective@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                       (elem@@sl$G (apply@@Int@@sl$G f1 x) (ran@@Int@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@Int@@sl$G f1 x) (ran@@Int@@sl$G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                       (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x) (ran@@sl$REQ@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x) (ran@@sl$REQ@@sl$G f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                       (elem@@sl$G (apply@@Int@@sl$G f1 x)"
    , "                                   (ran@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@Int@@sl$G f1 x)"
    , "                                 (ran@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                       (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x)"
    , "                                   (ran@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x)"
    , "                                 (ran@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$G f1) s1))"
    , "                       (elem@@sl$G (apply@@Int@@sl$G f1 x)"
    , "                                   (ran@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@Int@@sl$G f1 x)"
    , "                                 (ran@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (intersect (dom@@sl$REQ@@sl$G f1) s1))"
    , "                       (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x)"
    , "                                   (ran@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x)"
    , "                                 (ran@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                            (injective@@Int@@sl$G f1))"
    , "                       (= (ran@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)))"
    , "                          (union (set-diff@@sl$G (ran@@Int@@sl$G f1)"
    , "                                                 (mk-set@@sl$G (apply@@Int@@sl$G f1 x)))"
    , "                                 (mk-set@@sl$G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                            (injective@@sl$REQ@@sl$G f1))"
    , "                       (= (ran@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y)))"
    , "                          (union (set-diff@@sl$G (ran@@sl$REQ@@sl$G f1)"
    , "                                                 (mk-set@@sl$G (apply@@sl$REQ@@sl$G f1 x)))"
    , "                                 (mk-set@@sl$G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl$G f1)))"
    , "                       (= (ran@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)))"
    , "                          (union (ran@@Int@@sl$G f1) (mk-set@@sl$G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (=> (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1)))"
    , "                       (= (ran@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y)))"
    , "                          (union (ran@@sl$REQ@@sl$G f1) (mk-set@@sl$G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G))"
    , "                  (y (pfun Int sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y)) ))))"
    , "(assert (forall ( (x sl$G)"
    , "                  (y sl$G) )"
    , "                (! (= (elem@@sl$G x (mk-set@@sl$G y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G x (mk-set@@sl$G y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$REQ) )"
    , "                (! (= (elem@@sl$REQ x (mk-set@@sl$REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (mk-set@@sl$REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (finite@@sl$G s1)"
    , "                       (finite@@sl$G (set-diff@@sl$G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s1) (finite@@sl$G s2))"
    , "                       (finite@@sl$G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))"
    , "                       (not (finite@@Int (set-diff@@Int s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                            (not (finite@Open@@pfun@@Int@@sl$G@Close s1)))"
    , "                       (not (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s2) (not (finite@@sl$G s1)))"
    , "                       (not (finite@@sl$G (set-diff@@sl$G s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s2) (not (finite@@sl$REQ s1)))"
    , "                       (not (finite@@sl$REQ (set-diff@@sl$REQ s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$G) )"
    , "                (! (finite@@sl$G (mk-set@@sl$G x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (mk-set@@sl$G x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (finite@@sl$REQ (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl$G@Close empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "(assert (finite@@sl$G empty-set@@sl$G))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (= r@param r))"
    , "; SKIP:p"
    , "(assert (= p@prime p))"
    , "; SKIP:popR"
    , "(assert (= popR@prime popR))"
    , "; SKIP:pshL"
    , "(assert (= pshL@prime pshL))"
    , "; SKIP:pshR"
    , "(assert (= pshR@prime pshR))"
    , "; SKIP:q"
    , "(assert (= q@prime q))"
    , "; SKIP:qe"
    , "(assert (= qe@prime qe))"
    , "; SKIP:res"
    , "(assert (= res@prime res))"
    , "; SKIP:resL"
    , "(assert (= resL@prime resL))"
    , "; SKIP:resR"
    , "(assert (= resR@prime resR))"
    , "; m0:act4"
    , "(assert (= emp@prime true))"
    , "; m0:grd0"
    , "(assert (= p q))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$G@Close qe (tfun@@Int@@sl$G (intervalR p q) sl$G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:a4"
    , "(assert (= popL@prime"
    , "           (set-diff@@sl$REQ popL (mk-set@@sl$REQ r@param))))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resR) popR)"
    , "           empty-set@@sl$REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resL) popL)"
    , "           empty-set@@sl$REQ))"
    , "; m1:sch0"
    , "(assert (elem@@sl$REQ r@param popL))"
    , "; m1:sch1"
    , "(assert (= p q))"
    , "(assert (not (=> (and (elem@@sl$REQ r popL) (elem@@sl$REQ r popL))"
    , "                 (not (and (elem@@sl$REQ r popL@prime)"
    , "                           (elem@@sl$REQ r popL@prime))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/NEG"
    ]

result8 :: String
result8 = unlines 
    [ "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/NEG"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl$G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl$REQ))"
    , "(declare-const popL@prime (set sl$REQ))"
    , "(declare-const popR (set sl$REQ))"
    , "(declare-const popR@prime (set sl$REQ))"
    , "(declare-const pshL (pfun sl$REQ sl$G))"
    , "(declare-const pshL@prime (pfun sl$REQ sl$G))"
    , "(declare-const pshR (pfun sl$REQ sl$G))"
    , "(declare-const pshR@prime (pfun sl$REQ sl$G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl$G))"
    , "(declare-const qe@prime (pfun Int sl$G))"
    , "(declare-const r sl$REQ)"
    , "(declare-const res sl$G)"
    , "(declare-const res@prime sl$G)"
    , "(declare-const resL (pfun sl$REQ sl$G))"
    , "(declare-const resL@prime (pfun sl$REQ sl$G))"
    , "(declare-const resR (pfun sl$REQ sl$G))"
    , "(declare-const resR@prime (pfun sl$REQ sl$G))"
    , "(declare-fun apply@@Int@@sl$G ( (pfun Int sl$G) Int ) sl$G)"
    , "(declare-fun apply@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G)"
    , "               sl$REQ )"
    , "             sl$G)"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$G ( (set sl$G) ) Int)"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Int)"
    , "(declare-fun dom@@Int@@sl$G ( (pfun Int sl$G) ) (set Int))"
    , "(declare-fun dom@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom-rest@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun dom-subt@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun empty-fun@@Int@@sl$G () (pfun Int sl$G))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$G () (pfun sl$REQ sl$G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$G ( (set sl$G) ) Bool)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl$G ( (pfun Int sl$G) ) Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@sl$G (Int sl$G) (pfun Int sl$G))"
    , "(declare-fun mk-fun@@sl$REQ@@sl$G"
    , "             (sl$REQ sl$G)"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$G (sl$G) (set sl$G))"
    , "(declare-fun mk-set@@sl$REQ (sl$REQ) (set sl$REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (pfun Int sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun ovl@@Int@@sl$G"
    , "             ( (pfun Int sl$G)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun ovl@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun pfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun r@param () sl$REQ)"
    , "(declare-fun ran@@Int@@sl$G ( (pfun Int sl$G) ) (set sl$G))"
    , "(declare-fun ran@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) (set sl$G))"
    , "(declare-fun tfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              true ))"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$G"
    , "            ( (s1 (set sl$G)) )"
    , "            (set sl$G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$G"
    , "            ( (x sl$G)"
    , "              (s1 (set sl$G)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$REQ"
    , "            ( (x sl$REQ)"
    , "              (s1 (set sl$REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (x (pfun Int sl$G))"
    , "              (s1 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              false ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            (set sl$G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$G () (set sl$G) ( (as const (set sl$G)) true ))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (=> (finite@@sl$G r) (<= 0 (card@@sl$G r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$G r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (= (= (card@@sl$G r) 0) (= r empty-set@@sl$G))"
    , "                   :pattern"
    , "                   ( (card@@sl$G r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$G) )"
    , "                (! (= (card@@sl$G (mk-set@@sl$G x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$G (mk-set@@sl$G x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (= (card@@sl$REQ (mk-set@@sl$REQ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$G)) )"
    , "                              (and true (= r (mk-set@Open@@pfun@@Int@@sl$G@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (= (= (card@@sl$G r) 1)"
    , "                      (exists ( (x sl$G) ) (and true (= r (mk-set@@sl$G x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$G r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 1)"
    , "                      (exists ( (x sl$REQ) ) (and true (= r (mk-set@@sl$REQ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G)))"
    , "                  (r0 (set (pfun Int sl$G))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$G@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$G@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$G@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$G@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$G))"
    , "                  (r0 (set sl$G)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$G)"
    , "                       (= (card@@sl$G (union r r0))"
    , "                          (+ (card@@sl$G r) (card@@sl$G r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$G (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (= (dom@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$REQ))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (dom@@Int@@sl$G (mk-fun@@Int@@sl$G x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (mk-fun@@Int@@sl$G x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y))"
    , "                      (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$G f2))"
    , "                       (= (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 f2) x)"
    , "                          (apply@@Int@@sl$G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f2))"
    , "                       (= (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl$G f2))))"
    , "                       (= (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 f2) x)"
    , "                          (apply@@Int@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                            (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f2))))"
    , "                       (= (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (apply@@Int@@sl$G (mk-fun@@Int@@sl$G x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (mk-fun@@Int@@sl$G x y) x) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (apply@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl$G f1)))"
    , "                       (= (apply@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1) x)"
    , "                          (apply@@Int@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x s1)"
    , "                            (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1)))"
    , "                       (= (apply@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                       (= (apply@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1) x)"
    , "                          (apply@@Int@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                       (= (apply@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1) x) ))))"
    , "(assert (forall ( (s2 (set sl$G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                     (tfun@@Int@@sl$G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                       (tfun@@Int@@sl$G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G)) )"
    , "                (! (= (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2))"
    , "                      (union (dom@@Int@@sl$G f1) (dom@@Int@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$G f1) (dom@@sl$REQ@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                           (= (apply@@Int@@sl$G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                     (apply@@Int@@sl$G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                           (= (apply@@Int@@sl$G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                     (apply@@Int@@sl$G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                           (= (apply@@sl$REQ@@sl$G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                     (apply@@sl$REQ@@sl$G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                           (= (apply@@sl$REQ@@sl$G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                     (apply@@sl$REQ@@sl$G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl$G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)) x2)"
    , "                          (apply@@Int@@sl$G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (x2 sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))"
    , "                                               x2)"
    , "                          (apply@@sl$REQ@@sl$G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))"
    , "                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))"
    , "                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))"
    , "                                          x) ))))"
    , "(assert (= (ran@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (= (ran@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (y sl$G) )"
    , "                (! (= (elem@@sl$G y (ran@@Int@@sl$G f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                                        (= (apply@@Int@@sl$G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G y (ran@@Int@@sl$G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (y sl$G) )"
    , "                (! (= (elem@@sl$G y (ran@@sl$REQ@@sl$G f1))"
    , "                      (exists ( (x sl$REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                                        (= (apply@@sl$REQ@@sl$G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G y (ran@@sl$REQ@@sl$G f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (ran@@Int@@sl$G (mk-fun@@Int@@sl$G x y))"
    , "                      (mk-set@@sl$G y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$G (mk-fun@@Int@@sl$G x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (ran@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y))"
    , "                      (mk-set@@sl$G y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$G f1))"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$G f1) s1)"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (injective@@Int@@sl$G f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl$G f1)))"
    , "                                  (=> (= (apply@@Int@@sl$G f1 x) (apply@@Int@@sl$G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl$G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (injective@@sl$REQ@@sl$G f1)"
    , "                      (forall ( (x sl$REQ)"
    , "                                (x2 sl$REQ) )"
    , "                              (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                                       (elem@@sl$REQ x2 (dom@@sl$REQ@@sl$G f1)))"
    , "                                  (=> (= (apply@@sl$REQ@@sl$G f1 x)"
    , "                                         (apply@@sl$REQ@@sl$G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$REQ@@sl$G f1) ))))"
    , "(assert (injective@@Int@@sl$G empty-fun@@Int@@sl$G))"
    , "(assert (injective@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                       (elem@@sl$G (apply@@Int@@sl$G f1 x) (ran@@Int@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@Int@@sl$G f1 x) (ran@@Int@@sl$G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                       (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x) (ran@@sl$REQ@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x) (ran@@sl$REQ@@sl$G f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                       (elem@@sl$G (apply@@Int@@sl$G f1 x)"
    , "                                   (ran@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@Int@@sl$G f1 x)"
    , "                                 (ran@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                       (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x)"
    , "                                   (ran@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x)"
    , "                                 (ran@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$G f1) s1))"
    , "                       (elem@@sl$G (apply@@Int@@sl$G f1 x)"
    , "                                   (ran@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@Int@@sl$G f1 x)"
    , "                                 (ran@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (intersect (dom@@sl$REQ@@sl$G f1) s1))"
    , "                       (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x)"
    , "                                   (ran@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x)"
    , "                                 (ran@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                            (injective@@Int@@sl$G f1))"
    , "                       (= (ran@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)))"
    , "                          (union (set-diff@@sl$G (ran@@Int@@sl$G f1)"
    , "                                                 (mk-set@@sl$G (apply@@Int@@sl$G f1 x)))"
    , "                                 (mk-set@@sl$G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                            (injective@@sl$REQ@@sl$G f1))"
    , "                       (= (ran@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y)))"
    , "                          (union (set-diff@@sl$G (ran@@sl$REQ@@sl$G f1)"
    , "                                                 (mk-set@@sl$G (apply@@sl$REQ@@sl$G f1 x)))"
    , "                                 (mk-set@@sl$G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl$G f1)))"
    , "                       (= (ran@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)))"
    , "                          (union (ran@@Int@@sl$G f1) (mk-set@@sl$G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (=> (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1)))"
    , "                       (= (ran@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y)))"
    , "                          (union (ran@@sl$REQ@@sl$G f1) (mk-set@@sl$G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G))"
    , "                  (y (pfun Int sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y)) ))))"
    , "(assert (forall ( (x sl$G)"
    , "                  (y sl$G) )"
    , "                (! (= (elem@@sl$G x (mk-set@@sl$G y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G x (mk-set@@sl$G y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$REQ) )"
    , "                (! (= (elem@@sl$REQ x (mk-set@@sl$REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (mk-set@@sl$REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (finite@@sl$G s1)"
    , "                       (finite@@sl$G (set-diff@@sl$G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s1) (finite@@sl$G s2))"
    , "                       (finite@@sl$G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))"
    , "                       (not (finite@@Int (set-diff@@Int s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                            (not (finite@Open@@pfun@@Int@@sl$G@Close s1)))"
    , "                       (not (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s2) (not (finite@@sl$G s1)))"
    , "                       (not (finite@@sl$G (set-diff@@sl$G s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s2) (not (finite@@sl$REQ s1)))"
    , "                       (not (finite@@sl$REQ (set-diff@@sl$REQ s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$G) )"
    , "                (! (finite@@sl$G (mk-set@@sl$G x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (mk-set@@sl$G x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (finite@@sl$REQ (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl$G@Close empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "(assert (finite@@sl$G empty-set@@sl$G))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (= r@param r))"
    , "; SKIP:popR"
    , "(assert (= popR@prime popR))"
    , "; SKIP:pshL"
    , "(assert (= pshL@prime pshL))"
    , "; SKIP:pshR"
    , "(assert (= pshR@prime pshR))"
    , "; SKIP:q"
    , "(assert (= q@prime q))"
    , "; SKIP:resR"
    , "(assert (= resR@prime resR))"
    , "; m0:act0"
    , "(assert (= qe@prime (dom-subt@@Int@@sl$G (mk-set@@Int p) qe)))"
    , "; m0:act1"
    , "(assert (= p@prime (+ p 1)))"
    , "; m0:act3"
    , "(assert (= res@prime (apply@@Int@@sl$G qe p)))"
    , "; m0:act4"
    , "(assert (= emp@prime false))"
    , "; m0:grd0"
    , "(assert (< p q))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$G@Close qe (tfun@@Int@@sl$G (intervalR p q) sl$G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:a4"
    , "(assert (= popL@prime"
    , "           (set-diff@@sl$REQ popL (mk-set@@sl$REQ r@param))))"
    , "; m1:a5"
    , "(assert (= resL@prime"
    , "           (ovl@@sl$REQ@@sl$G resL"
    , "                              (mk-fun@@sl$REQ@@sl$G r@param (apply@@Int@@sl$G qe p)))))"
    , "; m1:grd0"
    , "(assert (elem@@sl$REQ r@param popL))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resR) popR)"
    , "           empty-set@@sl$REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resL) popL)"
    , "           empty-set@@sl$REQ))"
    , "; m1:sch0"
    , "(assert (elem@@sl$REQ r@param popL))"
    , "; m1:sch1"
    , "(assert (< p q))"
    , "(assert (not (=> (and (elem@@sl$REQ r popL) (elem@@sl$REQ r popL))"
    , "                 (not (and (elem@@sl$REQ r popL@prime)"
    , "                           (elem@@sl$REQ r popL@prime))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/NEG"
    ]

result9 :: String
result9 = unlines
    [ "; m1/LIVE/m1:prog3/ensure/TR/leadsto"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl$G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl$REQ))"
    , "(declare-const popL@prime (set sl$REQ))"
    , "(declare-const popR (set sl$REQ))"
    , "(declare-const popR@prime (set sl$REQ))"
    , "(declare-const pshL (pfun sl$REQ sl$G))"
    , "(declare-const pshL@prime (pfun sl$REQ sl$G))"
    , "(declare-const pshR (pfun sl$REQ sl$G))"
    , "(declare-const pshR@prime (pfun sl$REQ sl$G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl$G))"
    , "(declare-const qe@prime (pfun Int sl$G))"
    , "(declare-const r sl$REQ)"
    , "(declare-const r@m0-pop-left-empty sl$REQ)"
    , "(declare-const r@m0-pop-left-non-empty sl$REQ)"
    , "(declare-const r0 sl$REQ)"
    , "(declare-const res sl$G)"
    , "(declare-const res@prime sl$G)"
    , "(declare-const resL (pfun sl$REQ sl$G))"
    , "(declare-const resL@prime (pfun sl$REQ sl$G))"
    , "(declare-const resR (pfun sl$REQ sl$G))"
    , "(declare-const resR@prime (pfun sl$REQ sl$G))"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$G ( (set sl$G) ) Int)"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Int)"
    , "(declare-fun dom@@Int@@sl$G ( (pfun Int sl$G) ) (set Int))"
    , "(declare-fun dom@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom-rest@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun dom-subt@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun empty-fun@@Int@@sl$G () (pfun Int sl$G))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$G () (pfun sl$REQ sl$G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$G ( (set sl$G) ) Bool)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl$G ( (pfun Int sl$G) ) Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$REQ (sl$REQ) (set sl$REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (pfun Int sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun ovl@@Int@@sl$G"
    , "             ( (pfun Int sl$G)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun ovl@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun pfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun ran@@Int@@sl$G ( (pfun Int sl$G) ) (set sl$G))"
    , "(declare-fun ran@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) (set sl$G))"
    , "(declare-fun tfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              true ))"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$G"
    , "            ( (s1 (set sl$G)) )"
    , "            (set sl$G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$REQ"
    , "            ( (x sl$REQ)"
    , "              (s1 (set sl$REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (x (pfun Int sl$G))"
    , "              (s1 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              false ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            (set sl$G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$G () (set sl$G) ( (as const (set sl$G)) true ))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (=> (finite@@sl$G r) (<= 0 (card@@sl$G r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$G r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (= (= (card@@sl$G r) 0) (= r empty-set@@sl$G))"
    , "                   :pattern"
    , "                   ( (card@@sl$G r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (= (card@@sl$REQ (mk-set@@sl$REQ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$G)) )"
    , "                              (and true (= r (mk-set@Open@@pfun@@Int@@sl$G@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 1)"
    , "                      (exists ( (x sl$REQ) ) (and true (= r (mk-set@@sl$REQ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G)))"
    , "                  (r0 (set (pfun Int sl$G))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$G@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$G@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$G@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$G@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$G))"
    , "                  (r0 (set sl$G)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$G)"
    , "                       (= (card@@sl$G (union r r0))"
    , "                          (+ (card@@sl$G r) (card@@sl$G r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$G (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (= (dom@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$REQ))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) ))))"
    , "(assert (forall ( (s2 (set sl$G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                     (tfun@@Int@@sl$G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                       (tfun@@Int@@sl$G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G)) )"
    , "                (! (= (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2))"
    , "                      (union (dom@@Int@@sl$G f1) (dom@@Int@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$G f1) (dom@@sl$REQ@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (= (ran@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (= (ran@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$G f1))"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$G f1) s1)"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (injective@@Int@@sl$G empty-fun@@Int@@sl$G))"
    , "(assert (injective@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G))"
    , "                  (y (pfun Int sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$REQ) )"
    , "                (! (= (elem@@sl$REQ x (mk-set@@sl$REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (mk-set@@sl$REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (finite@@sl$G s1)"
    , "                       (finite@@sl$G (set-diff@@sl$G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s1) (finite@@sl$G s2))"
    , "                       (finite@@sl$G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))"
    , "                       (not (finite@@Int (set-diff@@Int s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                            (not (finite@Open@@pfun@@Int@@sl$G@Close s1)))"
    , "                       (not (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s2) (not (finite@@sl$G s1)))"
    , "                       (not (finite@@sl$G (set-diff@@sl$G s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s2) (not (finite@@sl$REQ s1)))"
    , "                       (not (finite@@sl$REQ (set-diff@@sl$REQ s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (finite@@sl$REQ (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl$G@Close empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "(assert (finite@@sl$G empty-set@@sl$G))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (not (forall ( (r sl$REQ)"
    , "                       (r@m0-pop-left-empty sl$REQ)"
    , "                       (r@m0-pop-left-non-empty sl$REQ) )"
    , "                     (=> (and (elem@@sl$REQ r popL)"
    , "                              (elem@@sl$REQ r popL)"
    , "                              (elem@@sl$REQ r@m0-pop-left-empty popL)"
    , "                              (elem@@sl$REQ r@m0-pop-left-non-empty popL))"
    , "                         (or (= p q) (< p q))))))"
    , "(assert (not (forall ( (r@m0-pop-left-empty sl$REQ)"
    , "                       (r@m0-pop-left-non-empty sl$REQ) )"
    , "                     (=> (and (elem@@sl$REQ r0 popL)"
    , "                              (elem@@sl$REQ r0 popL)"
    , "                              (elem@@sl$REQ r@m0-pop-left-empty popL)"
    , "                              (elem@@sl$REQ r@m0-pop-left-non-empty popL))"
    , "                         (or (= p q) (< p q))))))"
    , "(assert (not (forall ( (r@m0-pop-left-non-empty sl$REQ) )"
    , "                     (=> (and (elem@@sl$REQ r0 popL)"
    , "                              (elem@@sl$REQ r0 popL)"
    , "                              (elem@@sl$REQ r@m0-pop-left-empty popL)"
    , "                              (elem@@sl$REQ r@m0-pop-left-non-empty popL))"
    , "                         (or (= p q) (< p q))))))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$G@Close qe (tfun@@Int@@sl$G (intervalR p q) sl$G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resR) popR)"
    , "           empty-set@@sl$REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resL) popL)"
    , "           empty-set@@sl$REQ))"
    , "(assert (not (=> (and (elem@@sl$REQ r0 popL)"
    , "                      (elem@@sl$REQ r0 popL)"
    , "                      (elem@@sl$REQ r@m0-pop-left-empty popL)"
    , "                      (elem@@sl$REQ r@m0-pop-left-non-empty popL))"
    , "                 (or (= p q) (< p q)))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/m1:prog3/ensure/TR/leadsto"
    ]

result10 :: String
result10 = unlines
    [ "Multiple refinement of progress property m1:prog3"
    , "error 223:5:"
    , "\tm1:prog3"
    , ""
    , "error 255:1:"
    , "\tm1:prog3"
    , ""
    ]

result11 :: String
result11 = unlines
    [ "error 223:5:"
    , "    A witness is needed for r in event 'm0:pop:left:empty'"
    , ""
    , "error 223:5:"
    , "    A witness is needed for r in event 'm0:pop:left:non:empty'"
    ]

result12 :: String
result12 = unlines
    [ "passed 0 / 0"
    ]

result13 :: String
result13 = unlines
    [ "passed 0 / 0"
    ]

result17 :: String
result17 = unlines
    [ "error 60:12:"
    , "    expecting more arguments"
    ]

result18 :: String
result18 = concat
    [ "no errors"
    ]

result19 :: String
result19 = unlines
    [ "; m1/resp:pop:left/F_SCH/replace/eqv"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl$G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "; comment: we don't need to declare the sort Real"
    , "(declare-sort sl$Req 0)"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const ppL (set sl$Req))"
    , "(declare-const ppL@prime (set sl$Req))"
    , "(declare-const ppR (set sl$Req))"
    , "(declare-const ppR@prime (set sl$Req))"
    , "(declare-const psL (pfun sl$Req sl$G))"
    , "(declare-const psL@prime (pfun sl$Req sl$G))"
    , "(declare-const psR (pfun sl$Req sl$G))"
    , "(declare-const psR@prime (pfun sl$Req sl$G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl$G))"
    , "(declare-const qe@prime (pfun Int sl$G))"
    , "(declare-const r sl$Req)"
    , "(declare-const res sl$G)"
    , "(declare-const res@prime sl$G)"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$G ( (set sl$G) ) Int)"
    , "(declare-fun card@@sl$Req ( (set sl$Req) ) Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Int)"
    , "(declare-fun dom@@Int@@sl$G ( (pfun Int sl$G) ) (set Int))"
    , "(declare-fun dom-rest@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-subt@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun empty-fun@@Int@@sl$G () (pfun Int sl$G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$G ( (set sl$G) ) Bool)"
    , "(declare-fun finite@@sl$Req ( (set sl$Req) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl$G ( (pfun Int sl$G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$Req (sl$Req) (set sl$Req))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (pfun Int sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun ovl@@Int@@sl$G"
    , "             ( (pfun Int sl$G)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun pfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun ran@@Int@@sl$G ( (pfun Int sl$G) ) (set sl$G))"
    , "(declare-fun tfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              true ))"
    , "(define-fun all@@sl$Req"
    , "            ()"
    , "            (set sl$Req)"
    , "            ( (as const (set sl$Req))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$G"
    , "            ( (s1 (set sl$G)) )"
    , "            (set sl$G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$Req"
    , "            ( (s1 (set sl$Req)) )"
    , "            (set sl$Req)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$Req"
    , "            ( (x sl$Req)"
    , "              (s1 (set sl$Req)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (x (pfun Int sl$G))"
    , "              (s1 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              false ))"
    , "(define-fun empty-set@@sl$Req"
    , "            ()"
    , "            (set sl$Req)"
    , "            ( (as const (set sl$Req))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            (set sl$G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$Req"
    , "            ( (s1 (set sl$Req))"
    , "              (s2 (set sl$Req)) )"
    , "            (set sl$Req)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$Req"
    , "            ( (s1 (set sl$Req))"
    , "              (s2 (set sl$Req)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$G () (set sl$G) ( (as const (set sl$G)) true ))"
    , "(define-fun sl$Req"
    , "            ()"
    , "            (set sl$Req)"
    , "            ( (as const (set sl$Req))"
    , "              true ))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (=> (finite@@sl$G r) (<= 0 (card@@sl$G r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$G r)) ))))"
    , "(assert (forall ( (r (set sl$Req)) )"
    , "                (! (=> (finite@@sl$Req r) (<= 0 (card@@sl$Req r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Req r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (= (= (card@@sl$G r) 0) (= r empty-set@@sl$G))"
    , "                   :pattern"
    , "                   ( (card@@sl$G r) ))))"
    , "(assert (forall ( (r (set sl$Req)) )"
    , "                (! (= (= (card@@sl$Req r) 0) (= r empty-set@@sl$Req))"
    , "                   :pattern"
    , "                   ( (card@@sl$Req r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$Req) )"
    , "                (! (= (card@@sl$Req (mk-set@@sl$Req x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$Req (mk-set@@sl$Req x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$G)) )"
    , "                              (and true (= r (mk-set@Open@@pfun@@Int@@sl$G@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$Req)) )"
    , "                (! (= (= (card@@sl$Req r) 1)"
    , "                      (exists ( (x sl$Req) ) (and true (= r (mk-set@@sl$Req x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Req r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G)))"
    , "                  (r0 (set (pfun Int sl$G))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$G@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$G@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$G@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$G@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$G))"
    , "                  (r0 (set sl$G)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$G)"
    , "                       (= (card@@sl$G (union r r0))"
    , "                          (+ (card@@sl$G r) (card@@sl$G r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$G (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Req))"
    , "                  (r0 (set sl$Req)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Req)"
    , "                       (= (card@@sl$Req (union r r0))"
    , "                          (+ (card@@sl$Req r) (card@@sl$Req r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Req (union r r0)) ))))"
    , "(assert (= (dom@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@Int))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) ))))"
    , "(assert (forall ( (s2 (set sl$G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                     (tfun@@Int@@sl$G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                       (tfun@@Int@@sl$G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G)) )"
    , "                (! (= (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2))"
    , "                      (union (dom@@Int@@sl$G f1) (dom@@Int@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1)) ))))"
    , "(assert (= (ran@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$G f1))"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$G f1) s1)"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (injective@@Int@@sl$G empty-fun@@Int@@sl$G))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G))"
    , "                  (y (pfun Int sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y)) ))))"
    , "(assert (forall ( (x sl$Req)"
    , "                  (y sl$Req) )"
    , "                (! (= (elem@@sl$Req x (mk-set@@sl$Req y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Req x (mk-set@@sl$Req y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (finite@@sl$G s1)"
    , "                       (finite@@sl$G (set-diff@@sl$G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Req))"
    , "                  (s2 (set sl$Req)) )"
    , "                (! (=> (finite@@sl$Req s1)"
    , "                       (finite@@sl$Req (set-diff@@sl$Req s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Req (set-diff@@sl$Req s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s1) (finite@@sl$G s2))"
    , "                       (finite@@sl$G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Req))"
    , "                  (s2 (set sl$Req)) )"
    , "                (! (=> (and (finite@@sl$Req s1) (finite@@sl$Req s2))"
    , "                       (finite@@sl$Req (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Req (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))"
    , "                       (not (finite@@Int (set-diff@@Int s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                            (not (finite@Open@@pfun@@Int@@sl$G@Close s1)))"
    , "                       (not (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s2) (not (finite@@sl$G s1)))"
    , "                       (not (finite@@sl$G (set-diff@@sl$G s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Req))"
    , "                  (s2 (set sl$Req)) )"
    , "                (! (=> (and (finite@@sl$Req s2) (not (finite@@sl$Req s1)))"
    , "                       (not (finite@@sl$Req (set-diff@@sl$Req s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Req (set-diff@@sl$Req s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$Req) )"
    , "                (! (finite@@sl$Req (mk-set@@sl$Req x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Req (mk-set@@sl$Req x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl$G@Close empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "(assert (finite@@sl$G empty-set@@sl$G))"
    , "(assert (finite@@sl$Req empty-set@@sl$Req))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (elem@@sl$Req r ppL))"
    , "; m0:sch0"
    , "(assert (elem@@sl$Req r ppL))"
    , "; m1:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$G@Close qe (tfun@@Int@@sl$G (intervalR p q) sl$G)))"
    , "; m1:inv1"
    , "(assert (<= p q))"
    , "(assert (not (= (or (= p q) (not (= p q))) true)))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/resp:pop:left/F_SCH/replace/eqv"
    ]

result20 :: String
result20 = unlines
    [ "  o  m0/LIVE/prog0/ensure/TR/handle/EN"
    , "  o  m0/LIVE/prog0/ensure/TR/handle/NEG"
    , "  o  m0/LIVE/prog1/ensure/TR/handle/EN"
    , "  o  m0/LIVE/prog1/ensure/TR/handle/NEG"
    , "  o  m0/SKIP/CO/co0"
    , "  o  m0/handle/CO/co0"
    , "  o  m0/handle/SAF/LIVE/prog0/ensure"
    , "  o  m0/handle/SAF/LIVE/prog1/ensure"
    , "  o  m0/handle/SCH"
    , "  o  m0/handle/SCH/r"
    , "  o  m0/req/CO/co0"
    , "  o  m0/req/SAF/LIVE/prog0/ensure"
    , "  o  m0/req/SAF/LIVE/prog1/ensure"
    , "  o  m0/req/SCH/r"
    , "passed 14 / 14"
    ]

result23 :: String
result23 = unlines
    [ "; m1/handle/C_SCH/delay/0/prog/m1:prog1/lhs"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const ch Bool)"
    , "(declare-const ch@prime Bool)"
    , "(declare-const req (set sl$REQ))"
    , "(declare-const req@prime (set sl$REQ))"
    , "(declare-const req_0 (set sl$REQ))"
    , "(declare-const req_0@prime (set sl$REQ))"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s2) (not (finite@@sl$REQ s1)))"
    , "                       (not (finite@@sl$REQ (set-diff@@sl$REQ s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "; b"
    , "(assert (= b ch))"
    , "; m0:sch0"
    , "(assert (not (= req empty-set@@sl$REQ)))"
    , "(assert (not (= b ch)))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/handle/C_SCH/delay/0/prog/m1:prog1/lhs"
    ]

result22 :: String
result22 = unlines
    [ "; m1/handle/C_SCH/delay/0/prog/m1:prog1/rhs/m1:sch0"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const ch Bool)"
    , "(declare-const ch@prime Bool)"
    , "(declare-const req (set sl$REQ))"
    , "(declare-const req@prime (set sl$REQ))"
    , "(declare-const req_0 (set sl$REQ))"
    , "(declare-const req_0@prime (set sl$REQ))"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s2) (not (finite@@sl$REQ s1)))"
    , "                       (not (finite@@sl$REQ (set-diff@@sl$REQ s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (not (=> (= b ch)"
    , "                 (or (= b ch) (not (= req empty-set@@sl$REQ))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/handle/C_SCH/delay/0/prog/m1:prog1/rhs/m1:sch0"
    ]

result24 :: String
result24 = unlines
    [ "  o  m1/handle/C_SCH/weaken/m1:sch0"
    , " xxx m1/handle/C_SCH/weaken/m1:sch1"
    , "  o  m1/handle/GRD/str/m0:grd0"
    , "  o  m1/handle/GRD/str/m0:sch0"
    , "  o  m1/handle/IWFIS/r"
    , " xxx m1/handle/IWFIS/v"
    , " xxx m1/handle/IWWD/handle"
    , "passed 4 / 7"
    ]

result25 :: String
result25 = unlines
    [ "passed 0 / 0"
    ]

result26 :: String
result26 = unlines
    [ "  o  m3/INIT/INV/m3:inv0"
    , "  o  m3/INIT/INV/m3:inv1"
    , "  o  m3/INIT/INV/m3:inv2"
    , "  o  m3/add:popL/INV/m3:inv0"
    , "  o  m3/add:popL/INV/m3:inv1"
    , "  o  m3/add:popL/INV/m3:inv2"
    , "  o  m3/add:popR/INV/m3:inv0"
    , "  o  m3/add:popR/INV/m3:inv1"
    , "  o  m3/add:popR/INV/m3:inv2"
    , "  o  m3/add:pushL/INV/m3:inv0"
    , "  o  m3/add:pushL/INV/m3:inv1"
    , "  o  m3/add:pushL/INV/m3:inv2"
    , "  o  m3/add:pushR/INV/m3:inv0"
    , "  o  m3/add:pushR/INV/m3:inv1"
    , "  o  m3/add:pushR/INV/m3:inv2"
    , "  o  m3/handle:popL/C_SCH/delay/0/prog/m3:prog0/lhs"
    , "  o  m3/handle:popL/C_SCH/delay/0/prog/m3:prog0/rhs/split"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/add:popL/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/add:popL/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/add:popR/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/add:popR/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/add:pushL/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/add:pushL/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/add:pushR/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/add:pushR/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:popL:empty/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:popL:empty/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:popL:non:empty/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:popL:non:empty/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:popR:empty/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:popR:empty/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:popR:non:empty/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:popR:non:empty/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:pushL/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:pushL/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:pushR/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:pushR/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/return/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/return/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/F_SCH/replace/eqv"
    , "  o  m3/handle:popL:empty/INV/m3:inv0"
    , "  o  m3/handle:popL:empty/INV/m3:inv1"
    , "  o  m3/handle:popL:empty/INV/m3:inv2"
    , "  o  m3/handle:popL:non:empty/INV/m3:inv0"
    , "  o  m3/handle:popL:non:empty/INV/m3:inv1"
    , "  o  m3/handle:popL:non:empty/INV/m3:inv2"
    , "  o  m3/handle:popL:non:empty/WD/ACT/m3:act0"
    , "  o  m3/handle:popR/C_SCH/delay/0/prog/m3:prog0/lhs"
    , "  o  m3/handle:popR/C_SCH/delay/0/prog/m3:prog0/rhs/split"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/add:popL/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/add:popL/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/add:popR/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/add:popR/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/add:pushL/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/add:pushL/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/add:pushR/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/add:pushR/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:popL:empty/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:popL:empty/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:popL:non:empty/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:popL:non:empty/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:popR:empty/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:popR:empty/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:popR:non:empty/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:popR:non:empty/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:pushL/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:pushL/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:pushR/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:pushR/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/return/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/return/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/F_SCH/replace/eqv"
    , "  o  m3/handle:popR:empty/INV/m3:inv0"
    , "  o  m3/handle:popR:empty/INV/m3:inv1"
    , "  o  m3/handle:popR:empty/INV/m3:inv2"
    , "  o  m3/handle:popR:non:empty/INV/m3:inv0"
    , "  o  m3/handle:popR:non:empty/INV/m3:inv1"
    , "  o  m3/handle:popR:non:empty/INV/m3:inv2"
    , "  o  m3/handle:popR:non:empty/WD/ACT/m3:act0"
    , "  o  m3/handle:pushL/INV/m3:inv0"
    , "  o  m3/handle:pushL/INV/m3:inv1"
    , "  o  m3/handle:pushL/INV/m3:inv2"
    , "  o  m3/handle:pushR/INV/m3:inv0"
    , "  o  m3/handle:pushR/INV/m3:inv1"
    , "  o  m3/handle:pushR/INV/m3:inv2"
    , "  o  m3/m3:prog0/LIVE/implication"
    , "  o  m3/return/FIS/result@prime"
    , "  o  m3/return/INV/m3:inv0"
    , "  o  m3/return/INV/m3:inv1"
    , "  o  m3/return/INV/m3:inv2"
    , "  o  m3/return/WD/ACT/m3:act1"
    , "passed 91 / 91"
    ]

result27 :: String
result27 = unlines
    [ "  o  m5/INIT/FIS/LH"
    , "  o  m5/INIT/FIS/RH"
    , "  o  m5/INIT/FIS/insL"
    , "  o  m5/INIT/FIS/insR"
    , "  o  m5/INIT/FIS/item"
    , "  o  m5/INIT/FIS/left"
    , "  o  m5/INIT/FIS/nL"
    , "  o  m5/INIT/FIS/nR"
    , "  o  m5/INIT/FIS/node"
    , "  o  m5/INIT/FIS/p"
    , "  o  m5/INIT/FIS/popL"
    , "  o  m5/INIT/FIS/popR"
    , "  o  m5/INIT/FIS/ppd"
    , "  o  m5/INIT/FIS/pshL"
    , "  o  m5/INIT/FIS/pshR"
    , "  o  m5/INIT/FIS/q"
    , "  o  m5/INIT/FIS/qe"
    , "  o  m5/INIT/FIS/rep"
    , "  o  m5/INIT/FIS/res"
    , "  o  m5/INIT/FIS/right"
    , "  o  m5/INIT/FIS/ver"
    , "  o  m5/INIT/INV/m5:inv0"
    , "  o  m5/INIT/INV/m5:inv1"
    , "  o  m5/INIT/INV/m5:inv2"
    , "  o  m5/INIT/INV/m5:inv3"
    , "  o  m5/INIT/INV/m5:inv4"
    , "  o  m5/INIT/INV/m5:inv5"
    , "  o  m5/INIT/INV/m5:inv6"
    , "  o  m5/INIT/INV/m5:inv7"
    , "  o  m5/INIT/INV/m5:inv8"
    , "  o  m5/INIT/INV/m5:inv9"
    , "  o  m5/INIT/WD"
    , "  o  m5/INIT/WWD"
    , "  o  m5/INV/WD"
    , "  o  m5/add:popL/FIS/LH@prime"
    , "  o  m5/add:popL/FIS/RH@prime"
    , "  o  m5/add:popL/FIS/emp@prime"
    , "  o  m5/add:popL/FIS/insL@prime"
    , "  o  m5/add:popL/FIS/insR@prime"
    , "  o  m5/add:popL/FIS/item@prime"
    , "  o  m5/add:popL/FIS/left@prime"
    , "  o  m5/add:popL/FIS/nL@prime"
    , "  o  m5/add:popL/FIS/nR@prime"
    , "  o  m5/add:popL/FIS/new@prime"
    , "  o  m5/add:popL/FIS/node@prime"
    , "  o  m5/add:popL/FIS/p@prime"
    , "  o  m5/add:popL/FIS/popL@prime"
    , "  o  m5/add:popL/FIS/popR@prime"
    , "  o  m5/add:popL/FIS/ppd@prime"
    , "  o  m5/add:popL/FIS/pshL@prime"
    , "  o  m5/add:popL/FIS/pshR@prime"
    , "  o  m5/add:popL/FIS/q@prime"
    , "  o  m5/add:popL/FIS/qe@prime"
    , "  o  m5/add:popL/FIS/rep@prime"
    , "  o  m5/add:popL/FIS/res@prime"
    , "  o  m5/add:popL/FIS/result@prime"
    , "  o  m5/add:popL/FIS/right@prime"
    , "  o  m5/add:popL/FIS/ver@prime"
    , "  o  m5/add:popL/INV/m5:inv0"
    , "  o  m5/add:popL/INV/m5:inv1"
    , "  o  m5/add:popL/INV/m5:inv2"
    , "  o  m5/add:popL/INV/m5:inv3"
    , "  o  m5/add:popL/INV/m5:inv4"
    , "  o  m5/add:popL/INV/m5:inv5"
    , "  o  m5/add:popL/INV/m5:inv6"
    , "  o  m5/add:popL/INV/m5:inv7"
    , "  o  m5/add:popL/INV/m5:inv8"
    , "  o  m5/add:popL/INV/m5:inv9"
    , "  o  m5/add:popL/IWWD/add:popL"
    , "  o  m5/add:popL/WD/C_SCH"
    , "  o  m5/add:popL/WD/F_SCH"
    , "  o  m5/add:popL/WD/GRD"
    , "  o  m5/add:popL/WWD"
    , "  o  m5/add:popR/FIS/LH@prime"
    , "  o  m5/add:popR/FIS/RH@prime"
    , "  o  m5/add:popR/FIS/emp@prime"
    , "  o  m5/add:popR/FIS/insL@prime"
    , "  o  m5/add:popR/FIS/insR@prime"
    , "  o  m5/add:popR/FIS/item@prime"
    , "  o  m5/add:popR/FIS/left@prime"
    , "  o  m5/add:popR/FIS/nL@prime"
    , "  o  m5/add:popR/FIS/nR@prime"
    , "  o  m5/add:popR/FIS/new@prime"
    , "  o  m5/add:popR/FIS/node@prime"
    , "  o  m5/add:popR/FIS/p@prime"
    , "  o  m5/add:popR/FIS/popL@prime"
    , "  o  m5/add:popR/FIS/popR@prime"
    , "  o  m5/add:popR/FIS/ppd@prime"
    , "  o  m5/add:popR/FIS/pshL@prime"
    , "  o  m5/add:popR/FIS/pshR@prime"
    , "  o  m5/add:popR/FIS/q@prime"
    , "  o  m5/add:popR/FIS/qe@prime"
    , "  o  m5/add:popR/FIS/rep@prime"
    , "  o  m5/add:popR/FIS/res@prime"
    , "  o  m5/add:popR/FIS/result@prime"
    , "  o  m5/add:popR/FIS/right@prime"
    , "  o  m5/add:popR/FIS/ver@prime"
    , "  o  m5/add:popR/INV/m5:inv0"
    , "  o  m5/add:popR/INV/m5:inv1"
    , "  o  m5/add:popR/INV/m5:inv2"
    , "  o  m5/add:popR/INV/m5:inv3"
    , "  o  m5/add:popR/INV/m5:inv4"
    , "  o  m5/add:popR/INV/m5:inv5"
    , "  o  m5/add:popR/INV/m5:inv6"
    , "  o  m5/add:popR/INV/m5:inv7"
    , "  o  m5/add:popR/INV/m5:inv8"
    , "  o  m5/add:popR/INV/m5:inv9"
    , "  o  m5/add:popR/IWWD/add:popR"
    , "  o  m5/add:popR/WD/C_SCH"
    , "  o  m5/add:popR/WD/F_SCH"
    , "  o  m5/add:popR/WD/GRD"
    , "  o  m5/add:popR/WWD"
    , "  o  m5/add:pushL/FIS/LH@prime"
    , "  o  m5/add:pushL/FIS/RH@prime"
    , "  o  m5/add:pushL/FIS/emp@prime"
    , "  o  m5/add:pushL/FIS/insL@prime"
    , "  o  m5/add:pushL/FIS/insR@prime"
    , "  o  m5/add:pushL/FIS/item@prime"
    , "  o  m5/add:pushL/FIS/left@prime"
    , "  o  m5/add:pushL/FIS/nL@prime"
    , "  o  m5/add:pushL/FIS/nR@prime"
    , "  o  m5/add:pushL/FIS/new@prime"
    , "  o  m5/add:pushL/FIS/node@prime"
    , "  o  m5/add:pushL/FIS/p@prime"
    , "  o  m5/add:pushL/FIS/popL@prime"
    , "  o  m5/add:pushL/FIS/popR@prime"
    , "  o  m5/add:pushL/FIS/ppd@prime"
    , "  o  m5/add:pushL/FIS/pshL@prime"
    , "  o  m5/add:pushL/FIS/pshR@prime"
    , "  o  m5/add:pushL/FIS/q@prime"
    , "  o  m5/add:pushL/FIS/qe@prime"
    , "  o  m5/add:pushL/FIS/rep@prime"
    , "  o  m5/add:pushL/FIS/res@prime"
    , "  o  m5/add:pushL/FIS/result@prime"
    , "  o  m5/add:pushL/FIS/right@prime"
    , "  o  m5/add:pushL/FIS/ver@prime"
    , "  o  m5/add:pushL/INV/m5:inv0"
    , "  o  m5/add:pushL/INV/m5:inv1"
    , "  o  m5/add:pushL/INV/m5:inv2"
    , "  o  m5/add:pushL/INV/m5:inv3"
    , "  o  m5/add:pushL/INV/m5:inv4"
    , "  o  m5/add:pushL/INV/m5:inv5"
    , "  o  m5/add:pushL/INV/m5:inv6"
    , "  o  m5/add:pushL/INV/m5:inv7"
    , "  o  m5/add:pushL/INV/m5:inv8"
    , "  o  m5/add:pushL/INV/m5:inv9"
    , "  o  m5/add:pushL/IWWD/add:pushL"
    , "  o  m5/add:pushL/WD/C_SCH"
    , "  o  m5/add:pushL/WD/F_SCH"
    , "  o  m5/add:pushL/WD/GRD"
    , "  o  m5/add:pushL/WWD"
    , "  o  m5/add:pushR/FIS/LH@prime"
    , "  o  m5/add:pushR/FIS/RH@prime"
    , "  o  m5/add:pushR/FIS/emp@prime"
    , "  o  m5/add:pushR/FIS/insL@prime"
    , "  o  m5/add:pushR/FIS/insR@prime"
    , "  o  m5/add:pushR/FIS/item@prime"
    , "  o  m5/add:pushR/FIS/left@prime"
    , "  o  m5/add:pushR/FIS/nL@prime"
    , "  o  m5/add:pushR/FIS/nR@prime"
    , "  o  m5/add:pushR/FIS/new@prime"
    , "  o  m5/add:pushR/FIS/node@prime"
    , "  o  m5/add:pushR/FIS/p@prime"
    , "  o  m5/add:pushR/FIS/popL@prime"
    , "  o  m5/add:pushR/FIS/popR@prime"
    , "  o  m5/add:pushR/FIS/ppd@prime"
    , "  o  m5/add:pushR/FIS/pshL@prime"
    , "  o  m5/add:pushR/FIS/pshR@prime"
    , "  o  m5/add:pushR/FIS/q@prime"
    , "  o  m5/add:pushR/FIS/qe@prime"
    , "  o  m5/add:pushR/FIS/rep@prime"
    , "  o  m5/add:pushR/FIS/res@prime"
    , "  o  m5/add:pushR/FIS/result@prime"
    , "  o  m5/add:pushR/FIS/right@prime"
    , "  o  m5/add:pushR/FIS/ver@prime"
    , "  o  m5/add:pushR/INV/m5:inv0"
    , "  o  m5/add:pushR/INV/m5:inv1"
    , "  o  m5/add:pushR/INV/m5:inv2"
    , "  o  m5/add:pushR/INV/m5:inv3"
    , "  o  m5/add:pushR/INV/m5:inv4"
    , "  o  m5/add:pushR/INV/m5:inv5"
    , "  o  m5/add:pushR/INV/m5:inv6"
    , "  o  m5/add:pushR/INV/m5:inv7"
    , "  o  m5/add:pushR/INV/m5:inv8"
    , "  o  m5/add:pushR/INV/m5:inv9"
    , "  o  m5/add:pushR/IWWD/add:pushR"
    , "  o  m5/add:pushR/WD/C_SCH"
    , "  o  m5/add:pushR/WD/F_SCH"
    , "  o  m5/add:pushR/WD/GRD"
    , "  o  m5/add:pushR/WWD"
    , "  o  m5/allocateL/FIS/LH@prime"
    , "  o  m5/allocateL/FIS/RH@prime"
    , "  o  m5/allocateL/FIS/emp@prime"
    , "  o  m5/allocateL/FIS/insL@prime"
    , "  o  m5/allocateL/FIS/insR@prime"
    , "  o  m5/allocateL/FIS/item@prime"
    , "  o  m5/allocateL/FIS/left@prime"
    , "  o  m5/allocateL/FIS/nL@prime"
    , "  o  m5/allocateL/FIS/nR@prime"
    , "  o  m5/allocateL/FIS/new@prime"
    , "  o  m5/allocateL/FIS/node@prime"
    , "  o  m5/allocateL/FIS/p@prime"
    , "  o  m5/allocateL/FIS/popL@prime"
    , "  o  m5/allocateL/FIS/popR@prime"
    , "  o  m5/allocateL/FIS/ppd@prime"
    , "  o  m5/allocateL/FIS/pshL@prime"
    , "  o  m5/allocateL/FIS/pshR@prime"
    , "  o  m5/allocateL/FIS/q@prime"
    , "  o  m5/allocateL/FIS/qe@prime"
    , "  o  m5/allocateL/FIS/rep@prime"
    , "  o  m5/allocateL/FIS/res@prime"
    , "  o  m5/allocateL/FIS/result@prime"
    , "  o  m5/allocateL/FIS/right@prime"
    , "  o  m5/allocateL/FIS/ver@prime"
    , " xxx m5/allocateL/INV/m5:inv0"
    , " xxx m5/allocateL/INV/m5:inv1"
    , "  o  m5/allocateL/INV/m5:inv2"
    , "  o  m5/allocateL/INV/m5:inv3"
    , "  o  m5/allocateL/INV/m5:inv4"
    , "  o  m5/allocateL/INV/m5:inv5"
    , "  o  m5/allocateL/INV/m5:inv6"
    , "  o  m5/allocateL/INV/m5:inv7"
    , "  o  m5/allocateL/INV/m5:inv8"
    , "  o  m5/allocateL/INV/m5:inv9"
    , "  o  m5/allocateL/IWWD/allocateL"
    , "  o  m5/allocateL/WD/C_SCH"
    , "  o  m5/allocateL/WD/F_SCH"
    , "  o  m5/allocateL/WD/GRD"
    , "  o  m5/allocateL/WWD"
    , "  o  m5/allocateR/FIS/LH@prime"
    , "  o  m5/allocateR/FIS/RH@prime"
    , "  o  m5/allocateR/FIS/emp@prime"
    , "  o  m5/allocateR/FIS/insL@prime"
    , "  o  m5/allocateR/FIS/insR@prime"
    , "  o  m5/allocateR/FIS/item@prime"
    , "  o  m5/allocateR/FIS/left@prime"
    , "  o  m5/allocateR/FIS/nL@prime"
    , "  o  m5/allocateR/FIS/nR@prime"
    , "  o  m5/allocateR/FIS/new@prime"
    , "  o  m5/allocateR/FIS/node@prime"
    , "  o  m5/allocateR/FIS/p@prime"
    , "  o  m5/allocateR/FIS/popL@prime"
    , "  o  m5/allocateR/FIS/popR@prime"
    , "  o  m5/allocateR/FIS/ppd@prime"
    , "  o  m5/allocateR/FIS/pshL@prime"
    , "  o  m5/allocateR/FIS/pshR@prime"
    , "  o  m5/allocateR/FIS/q@prime"
    , "  o  m5/allocateR/FIS/qe@prime"
    , "  o  m5/allocateR/FIS/rep@prime"
    , "  o  m5/allocateR/FIS/res@prime"
    , "  o  m5/allocateR/FIS/result@prime"
    , "  o  m5/allocateR/FIS/right@prime"
    , "  o  m5/allocateR/FIS/ver@prime"
    , " xxx m5/allocateR/INV/m5:inv0"
    , " xxx m5/allocateR/INV/m5:inv1"
    , "  o  m5/allocateR/INV/m5:inv2"
    , "  o  m5/allocateR/INV/m5:inv3"
    , "  o  m5/allocateR/INV/m5:inv4"
    , "  o  m5/allocateR/INV/m5:inv5"
    , "  o  m5/allocateR/INV/m5:inv6"
    , "  o  m5/allocateR/INV/m5:inv7"
    , "  o  m5/allocateR/INV/m5:inv8"
    , "  o  m5/allocateR/INV/m5:inv9"
    , "  o  m5/allocateR/IWWD/allocateR"
    , "  o  m5/allocateR/WD/C_SCH"
    , "  o  m5/allocateR/WD/F_SCH"
    , "  o  m5/allocateR/WD/GRD"
    , "  o  m5/allocateR/WWD"
    , "  o  m5/handle:popL:empty/FIS/LH@prime"
    , "  o  m5/handle:popL:empty/FIS/RH@prime"
    , "  o  m5/handle:popL:empty/FIS/emp@prime"
    , "  o  m5/handle:popL:empty/FIS/insL@prime"
    , "  o  m5/handle:popL:empty/FIS/insR@prime"
    , "  o  m5/handle:popL:empty/FIS/item@prime"
    , "  o  m5/handle:popL:empty/FIS/left@prime"
    , "  o  m5/handle:popL:empty/FIS/nL@prime"
    , "  o  m5/handle:popL:empty/FIS/nR@prime"
    , "  o  m5/handle:popL:empty/FIS/new@prime"
    , "  o  m5/handle:popL:empty/FIS/node@prime"
    , "  o  m5/handle:popL:empty/FIS/p@prime"
    , "  o  m5/handle:popL:empty/FIS/popL@prime"
    , "  o  m5/handle:popL:empty/FIS/popR@prime"
    , "  o  m5/handle:popL:empty/FIS/ppd@prime"
    , "  o  m5/handle:popL:empty/FIS/pshL@prime"
    , "  o  m5/handle:popL:empty/FIS/pshR@prime"
    , "  o  m5/handle:popL:empty/FIS/q@prime"
    , "  o  m5/handle:popL:empty/FIS/qe@prime"
    , "  o  m5/handle:popL:empty/FIS/rep@prime"
    , "  o  m5/handle:popL:empty/FIS/res@prime"
    , "  o  m5/handle:popL:empty/FIS/result@prime"
    , "  o  m5/handle:popL:empty/FIS/right@prime"
    , "  o  m5/handle:popL:empty/FIS/ver@prime"
    , "  o  m5/handle:popL:empty/INV/m5:inv0"
    , "  o  m5/handle:popL:empty/INV/m5:inv1"
    , "  o  m5/handle:popL:empty/INV/m5:inv2"
    , "  o  m5/handle:popL:empty/INV/m5:inv3"
    , "  o  m5/handle:popL:empty/INV/m5:inv4"
    , "  o  m5/handle:popL:empty/INV/m5:inv5"
    , "  o  m5/handle:popL:empty/INV/m5:inv6"
    , "  o  m5/handle:popL:empty/INV/m5:inv7"
    , "  o  m5/handle:popL:empty/INV/m5:inv8"
    , "  o  m5/handle:popL:empty/INV/m5:inv9"
    , "  o  m5/handle:popL:empty/IWWD/handle:popL:empty"
    , "  o  m5/handle:popL:empty/WD/C_SCH"
    , "  o  m5/handle:popL:empty/WD/F_SCH"
    , "  o  m5/handle:popL:empty/WD/GRD"
    , "  o  m5/handle:popL:empty/WWD"
    , "  o  m5/handle:popL:non:empty/FIS/LH@prime"
    , "  o  m5/handle:popL:non:empty/FIS/RH@prime"
    , "  o  m5/handle:popL:non:empty/FIS/emp@prime"
    , "  o  m5/handle:popL:non:empty/FIS/insL@prime"
    , "  o  m5/handle:popL:non:empty/FIS/insR@prime"
    , "  o  m5/handle:popL:non:empty/FIS/item@prime"
    , "  o  m5/handle:popL:non:empty/FIS/left@prime"
    , "  o  m5/handle:popL:non:empty/FIS/nL@prime"
    , "  o  m5/handle:popL:non:empty/FIS/nR@prime"
    , "  o  m5/handle:popL:non:empty/FIS/new@prime"
    , "  o  m5/handle:popL:non:empty/FIS/node@prime"
    , "  o  m5/handle:popL:non:empty/FIS/p@prime"
    , "  o  m5/handle:popL:non:empty/FIS/popL@prime"
    , "  o  m5/handle:popL:non:empty/FIS/popR@prime"
    , "  o  m5/handle:popL:non:empty/FIS/ppd@prime"
    , "  o  m5/handle:popL:non:empty/FIS/pshL@prime"
    , "  o  m5/handle:popL:non:empty/FIS/pshR@prime"
    , "  o  m5/handle:popL:non:empty/FIS/q@prime"
    , "  o  m5/handle:popL:non:empty/FIS/qe@prime"
    , "  o  m5/handle:popL:non:empty/FIS/rep@prime"
    , "  o  m5/handle:popL:non:empty/FIS/res@prime"
    , "  o  m5/handle:popL:non:empty/FIS/result@prime"
    , "  o  m5/handle:popL:non:empty/FIS/right@prime"
    , "  o  m5/handle:popL:non:empty/FIS/ver@prime"
    , "  o  m5/handle:popL:non:empty/INV/m5:inv0"
    , "  o  m5/handle:popL:non:empty/INV/m5:inv1"
    , " xxx m5/handle:popL:non:empty/INV/m5:inv2"
    , " xxx m5/handle:popL:non:empty/INV/m5:inv3"
    , "  o  m5/handle:popL:non:empty/INV/m5:inv4"
    , "  o  m5/handle:popL:non:empty/INV/m5:inv5"
    , "  o  m5/handle:popL:non:empty/INV/m5:inv6"
    , "  o  m5/handle:popL:non:empty/INV/m5:inv7"
    , "  o  m5/handle:popL:non:empty/INV/m5:inv8"
    , "  o  m5/handle:popL:non:empty/INV/m5:inv9"
    , "  o  m5/handle:popL:non:empty/IWWD/handle:popL:non:empty"
    , "  o  m5/handle:popL:non:empty/WD/C_SCH"
    , "  o  m5/handle:popL:non:empty/WD/F_SCH"
    , "  o  m5/handle:popL:non:empty/WD/GRD"
    , "  o  m5/handle:popL:non:empty/WWD"
    , "  o  m5/handle:popR:empty/FIS/LH@prime"
    , "  o  m5/handle:popR:empty/FIS/RH@prime"
    , "  o  m5/handle:popR:empty/FIS/emp@prime"
    , "  o  m5/handle:popR:empty/FIS/insL@prime"
    , "  o  m5/handle:popR:empty/FIS/insR@prime"
    , "  o  m5/handle:popR:empty/FIS/item@prime"
    , "  o  m5/handle:popR:empty/FIS/left@prime"
    , "  o  m5/handle:popR:empty/FIS/nL@prime"
    , "  o  m5/handle:popR:empty/FIS/nR@prime"
    , "  o  m5/handle:popR:empty/FIS/new@prime"
    , "  o  m5/handle:popR:empty/FIS/node@prime"
    , "  o  m5/handle:popR:empty/FIS/p@prime"
    , "  o  m5/handle:popR:empty/FIS/popL@prime"
    , "  o  m5/handle:popR:empty/FIS/popR@prime"
    , "  o  m5/handle:popR:empty/FIS/ppd@prime"
    , "  o  m5/handle:popR:empty/FIS/pshL@prime"
    , "  o  m5/handle:popR:empty/FIS/pshR@prime"
    , "  o  m5/handle:popR:empty/FIS/q@prime"
    , "  o  m5/handle:popR:empty/FIS/qe@prime"
    , "  o  m5/handle:popR:empty/FIS/rep@prime"
    , "  o  m5/handle:popR:empty/FIS/res@prime"
    , "  o  m5/handle:popR:empty/FIS/result@prime"
    , "  o  m5/handle:popR:empty/FIS/right@prime"
    , "  o  m5/handle:popR:empty/FIS/ver@prime"
    , "  o  m5/handle:popR:empty/INV/m5:inv0"
    , "  o  m5/handle:popR:empty/INV/m5:inv1"
    , "  o  m5/handle:popR:empty/INV/m5:inv2"
    , "  o  m5/handle:popR:empty/INV/m5:inv3"
    , "  o  m5/handle:popR:empty/INV/m5:inv4"
    , "  o  m5/handle:popR:empty/INV/m5:inv5"
    , "  o  m5/handle:popR:empty/INV/m5:inv6"
    , "  o  m5/handle:popR:empty/INV/m5:inv7"
    , "  o  m5/handle:popR:empty/INV/m5:inv8"
    , "  o  m5/handle:popR:empty/INV/m5:inv9"
    , "  o  m5/handle:popR:empty/IWWD/handle:popR:empty"
    , "  o  m5/handle:popR:empty/WD/C_SCH"
    , "  o  m5/handle:popR:empty/WD/F_SCH"
    , "  o  m5/handle:popR:empty/WD/GRD"
    , "  o  m5/handle:popR:empty/WWD"
    , "  o  m5/handle:popR:non:empty/FIS/LH@prime"
    , "  o  m5/handle:popR:non:empty/FIS/RH@prime"
    , "  o  m5/handle:popR:non:empty/FIS/emp@prime"
    , "  o  m5/handle:popR:non:empty/FIS/insL@prime"
    , "  o  m5/handle:popR:non:empty/FIS/insR@prime"
    , "  o  m5/handle:popR:non:empty/FIS/item@prime"
    , "  o  m5/handle:popR:non:empty/FIS/left@prime"
    , "  o  m5/handle:popR:non:empty/FIS/nL@prime"
    , "  o  m5/handle:popR:non:empty/FIS/nR@prime"
    , "  o  m5/handle:popR:non:empty/FIS/new@prime"
    , "  o  m5/handle:popR:non:empty/FIS/node@prime"
    , "  o  m5/handle:popR:non:empty/FIS/p@prime"
    , "  o  m5/handle:popR:non:empty/FIS/popL@prime"
    , "  o  m5/handle:popR:non:empty/FIS/popR@prime"
    , "  o  m5/handle:popR:non:empty/FIS/ppd@prime"
    , "  o  m5/handle:popR:non:empty/FIS/pshL@prime"
    , "  o  m5/handle:popR:non:empty/FIS/pshR@prime"
    , "  o  m5/handle:popR:non:empty/FIS/q@prime"
    , "  o  m5/handle:popR:non:empty/FIS/qe@prime"
    , "  o  m5/handle:popR:non:empty/FIS/rep@prime"
    , "  o  m5/handle:popR:non:empty/FIS/res@prime"
    , "  o  m5/handle:popR:non:empty/FIS/result@prime"
    , "  o  m5/handle:popR:non:empty/FIS/right@prime"
    , "  o  m5/handle:popR:non:empty/FIS/ver@prime"
    , "  o  m5/handle:popR:non:empty/INV/m5:inv0"
    , "  o  m5/handle:popR:non:empty/INV/m5:inv1"
    , " xxx m5/handle:popR:non:empty/INV/m5:inv2"
    , " xxx m5/handle:popR:non:empty/INV/m5:inv3"
    , "  o  m5/handle:popR:non:empty/INV/m5:inv4"
    , "  o  m5/handle:popR:non:empty/INV/m5:inv5"
    , "  o  m5/handle:popR:non:empty/INV/m5:inv6"
    , "  o  m5/handle:popR:non:empty/INV/m5:inv7"
    , "  o  m5/handle:popR:non:empty/INV/m5:inv8"
    , "  o  m5/handle:popR:non:empty/INV/m5:inv9"
    , "  o  m5/handle:popR:non:empty/IWWD/handle:popR:non:empty"
    , "  o  m5/handle:popR:non:empty/WD/C_SCH"
    , "  o  m5/handle:popR:non:empty/WD/F_SCH"
    , "  o  m5/handle:popR:non:empty/WD/GRD"
    , "  o  m5/handle:popR:non:empty/WWD"
    , "  o  m5/handle:pushL/FIS/LH@prime"
    , "  o  m5/handle:pushL/FIS/RH@prime"
    , "  o  m5/handle:pushL/FIS/emp@prime"
    , "  o  m5/handle:pushL/FIS/insL@prime"
    , "  o  m5/handle:pushL/FIS/insR@prime"
    , "  o  m5/handle:pushL/FIS/item@prime"
    , "  o  m5/handle:pushL/FIS/left@prime"
    , "  o  m5/handle:pushL/FIS/nL@prime"
    , "  o  m5/handle:pushL/FIS/nR@prime"
    , "  o  m5/handle:pushL/FIS/new@prime"
    , "  o  m5/handle:pushL/FIS/node@prime"
    , "  o  m5/handle:pushL/FIS/p@prime"
    , "  o  m5/handle:pushL/FIS/popL@prime"
    , "  o  m5/handle:pushL/FIS/popR@prime"
    , "  o  m5/handle:pushL/FIS/ppd@prime"
    , "  o  m5/handle:pushL/FIS/pshL@prime"
    , "  o  m5/handle:pushL/FIS/pshR@prime"
    , "  o  m5/handle:pushL/FIS/q@prime"
    , "  o  m5/handle:pushL/FIS/qe@prime"
    , "  o  m5/handle:pushL/FIS/rep@prime"
    , "  o  m5/handle:pushL/FIS/res@prime"
    , "  o  m5/handle:pushL/FIS/result@prime"
    , "  o  m5/handle:pushL/FIS/right@prime"
    , "  o  m5/handle:pushL/FIS/ver@prime"
    , "  o  m5/handle:pushL/INV/m5:inv0"
    , "  o  m5/handle:pushL/INV/m5:inv1"
    , " xxx m5/handle:pushL/INV/m5:inv2"
    , "  o  m5/handle:pushL/INV/m5:inv3"
    , "  o  m5/handle:pushL/INV/m5:inv4"
    , "  o  m5/handle:pushL/INV/m5:inv5"
    , " xxx m5/handle:pushL/INV/m5:inv6"
    , " xxx m5/handle:pushL/INV/m5:inv7"
    , "  o  m5/handle:pushL/INV/m5:inv8"
    , "  o  m5/handle:pushL/INV/m5:inv9"
    , "  o  m5/handle:pushL/IWWD/handle:pushL"
    , "  o  m5/handle:pushL/WD/C_SCH"
    , "  o  m5/handle:pushL/WD/F_SCH"
    , "  o  m5/handle:pushL/WD/GRD"
    , "  o  m5/handle:pushL/WWD"
    , "  o  m5/handle:pushR/FIS/LH@prime"
    , "  o  m5/handle:pushR/FIS/RH@prime"
    , "  o  m5/handle:pushR/FIS/emp@prime"
    , "  o  m5/handle:pushR/FIS/insL@prime"
    , "  o  m5/handle:pushR/FIS/insR@prime"
    , "  o  m5/handle:pushR/FIS/item@prime"
    , "  o  m5/handle:pushR/FIS/left@prime"
    , "  o  m5/handle:pushR/FIS/nL@prime"
    , "  o  m5/handle:pushR/FIS/nR@prime"
    , "  o  m5/handle:pushR/FIS/new@prime"
    , "  o  m5/handle:pushR/FIS/node@prime"
    , "  o  m5/handle:pushR/FIS/p@prime"
    , "  o  m5/handle:pushR/FIS/popL@prime"
    , "  o  m5/handle:pushR/FIS/popR@prime"
    , "  o  m5/handle:pushR/FIS/ppd@prime"
    , "  o  m5/handle:pushR/FIS/pshL@prime"
    , "  o  m5/handle:pushR/FIS/pshR@prime"
    , "  o  m5/handle:pushR/FIS/q@prime"
    , "  o  m5/handle:pushR/FIS/qe@prime"
    , "  o  m5/handle:pushR/FIS/rep@prime"
    , "  o  m5/handle:pushR/FIS/res@prime"
    , "  o  m5/handle:pushR/FIS/result@prime"
    , "  o  m5/handle:pushR/FIS/right@prime"
    , "  o  m5/handle:pushR/FIS/ver@prime"
    , "  o  m5/handle:pushR/INV/m5:inv0"
    , "  o  m5/handle:pushR/INV/m5:inv1"
    , " xxx m5/handle:pushR/INV/m5:inv2"
    , "  o  m5/handle:pushR/INV/m5:inv3"
    , "  o  m5/handle:pushR/INV/m5:inv4"
    , "  o  m5/handle:pushR/INV/m5:inv5"
    , " xxx m5/handle:pushR/INV/m5:inv6"
    , " xxx m5/handle:pushR/INV/m5:inv7"
    , "  o  m5/handle:pushR/INV/m5:inv8"
    , "  o  m5/handle:pushR/INV/m5:inv9"
    , "  o  m5/handle:pushR/IWWD/handle:pushR"
    , "  o  m5/handle:pushR/WD/C_SCH"
    , "  o  m5/handle:pushR/WD/F_SCH"
    , "  o  m5/handle:pushR/WD/GRD"
    , "  o  m5/handle:pushR/WWD"
    , "  o  m5/return/FIS/LH@prime"
    , "  o  m5/return/FIS/RH@prime"
    , "  o  m5/return/FIS/emp@prime"
    , "  o  m5/return/FIS/insL@prime"
    , "  o  m5/return/FIS/insR@prime"
    , "  o  m5/return/FIS/item@prime"
    , "  o  m5/return/FIS/left@prime"
    , "  o  m5/return/FIS/nL@prime"
    , "  o  m5/return/FIS/nR@prime"
    , "  o  m5/return/FIS/new@prime"
    , "  o  m5/return/FIS/node@prime"
    , "  o  m5/return/FIS/p@prime"
    , "  o  m5/return/FIS/popL@prime"
    , "  o  m5/return/FIS/popR@prime"
    , "  o  m5/return/FIS/ppd@prime"
    , "  o  m5/return/FIS/pshL@prime"
    , "  o  m5/return/FIS/pshR@prime"
    , "  o  m5/return/FIS/q@prime"
    , "  o  m5/return/FIS/qe@prime"
    , "  o  m5/return/FIS/rep@prime"
    , "  o  m5/return/FIS/res@prime"
    , "  o  m5/return/FIS/result@prime"
    , "  o  m5/return/FIS/right@prime"
    , "  o  m5/return/FIS/ver@prime"
    , "  o  m5/return/INV/m5:inv0"
    , "  o  m5/return/INV/m5:inv1"
    , "  o  m5/return/INV/m5:inv2"
    , "  o  m5/return/INV/m5:inv3"
    , "  o  m5/return/INV/m5:inv4"
    , "  o  m5/return/INV/m5:inv5"
    , "  o  m5/return/INV/m5:inv6"
    , "  o  m5/return/INV/m5:inv7"
    , "  o  m5/return/INV/m5:inv8"
    , "  o  m5/return/INV/m5:inv9"
    , "  o  m5/return/IWWD/return"
    , "  o  m5/return/WD/C_SCH"
    , "  o  m5/return/WD/F_SCH"
    , "  o  m5/return/WD/GRD"
    , "  o  m5/return/WWD"
    , "passed 527 / 541"
    ]

result28 :: String
result28 = unlines
    [ "; m5/INV/WD"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$Node 0)"
    , "(declare-sort sl$OBJ 0)"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const LH sl$Node)"
    , "(declare-const RH sl$Node)"
    , "(declare-const dummy sl$Node)"
    , "(declare-const emp Bool)"
    , "(declare-const insL (pfun sl$REQ sl$OBJ))"
    , "(declare-const insR (pfun sl$REQ sl$OBJ))"
    , "(declare-const item (pfun sl$Node sl$OBJ))"
    , "(declare-const left (pfun sl$Node sl$Node))"
    , "(declare-const nL (pfun sl$REQ sl$Node))"
    , "(declare-const nR (pfun sl$REQ sl$Node))"
    , "(declare-const new (set sl$Node))"
    , "(declare-const node (set sl$Node))"
    , "(declare-const p Int)"
    , "(declare-const popL (set sl$REQ))"
    , "(declare-const popR (set sl$REQ))"
    , "(declare-const ppd (set sl$REQ))"
    , "(declare-const pshL (set sl$REQ))"
    , "(declare-const pshR (set sl$REQ))"
    , "(declare-const q Int)"
    , "(declare-const qe (pfun Int sl$OBJ))"
    , "(declare-const rep (pfun Int sl$Node))"
    , "(declare-const req (set sl$REQ))"
    , "(declare-const res (pfun sl$REQ sl$OBJ))"
    , "(declare-const result sl$OBJ)"
    , "(declare-const right (pfun sl$Node sl$Node))"
    , "(declare-const ver Int)"
    , "(declare-fun apply@@Int@@sl$Node"
    , "             ( (pfun Int sl$Node)"
    , "               Int )"
    , "             sl$Node)"
    , "(declare-fun apply@@Int@@sl$OBJ ( (pfun Int sl$OBJ) Int ) sl$OBJ)"
    , "(declare-fun apply@@sl$Node@@sl$Node"
    , "             ( (pfun sl$Node sl$Node)"
    , "               sl$Node )"
    , "             sl$Node)"
    , "(declare-fun apply@@sl$Node@@sl$OBJ"
    , "             ( (pfun sl$Node sl$OBJ)"
    , "               sl$Node )"
    , "             sl$OBJ)"
    , "(declare-fun apply@@sl$REQ@@sl$Node"
    , "             ( (pfun sl$REQ sl$Node)"
    , "               sl$REQ )"
    , "             sl$Node)"
    , "(declare-fun apply@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ)"
    , "               sl$REQ )"
    , "             sl$OBJ)"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$Node ( (set sl$Node) ) Int)"
    , "(declare-fun card@@sl$OBJ ( (set sl$OBJ) ) Int)"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$Node@Close"
    , "             ( (set (pfun Int sl$Node)) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$OBJ@Close"
    , "             ( (set (pfun Int sl$OBJ)) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "             ( (set (pfun sl$Node sl$Node)) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "             ( (set (pfun sl$Node sl$OBJ)) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "             ( (set (pfun sl$REQ sl$Node)) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "             ( (set (pfun sl$REQ sl$OBJ)) )"
    , "             Int)"
    , "(declare-fun dom@@Int@@sl$Node ( (pfun Int sl$Node) ) (set Int))"
    , "(declare-fun dom@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) (set Int))"
    , "(declare-fun dom@@sl$Node@@sl$Node"
    , "             ( (pfun sl$Node sl$Node) )"
    , "             (set sl$Node))"
    , "(declare-fun dom@@sl$Node@@sl$OBJ"
    , "             ( (pfun sl$Node sl$OBJ) )"
    , "             (set sl$Node))"
    , "(declare-fun dom@@sl$REQ@@sl$Node"
    , "             ( (pfun sl$REQ sl$Node) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom-rest@@Int@@sl$Node"
    , "             ( (set Int)"
    , "               (pfun Int sl$Node) )"
    , "             (pfun Int sl$Node))"
    , "(declare-fun dom-rest@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (pfun Int sl$OBJ) )"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun dom-rest@@sl$Node@@sl$Node"
    , "             ( (set sl$Node)"
    , "               (pfun sl$Node sl$Node) )"
    , "             (pfun sl$Node sl$Node))"
    , "(declare-fun dom-rest@@sl$Node@@sl$OBJ"
    , "             ( (set sl$Node)"
    , "               (pfun sl$Node sl$OBJ) )"
    , "             (pfun sl$Node sl$OBJ))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$Node"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$Node) )"
    , "             (pfun sl$REQ sl$Node))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$OBJ) )"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun dom-subt@@Int@@sl$Node"
    , "             ( (set Int)"
    , "               (pfun Int sl$Node) )"
    , "             (pfun Int sl$Node))"
    , "(declare-fun dom-subt@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (pfun Int sl$OBJ) )"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun dom-subt@@sl$Node@@sl$Node"
    , "             ( (set sl$Node)"
    , "               (pfun sl$Node sl$Node) )"
    , "             (pfun sl$Node sl$Node))"
    , "(declare-fun dom-subt@@sl$Node@@sl$OBJ"
    , "             ( (set sl$Node)"
    , "               (pfun sl$Node sl$OBJ) )"
    , "             (pfun sl$Node sl$OBJ))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$Node"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$Node) )"
    , "             (pfun sl$REQ sl$Node))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$OBJ) )"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun empty-fun@@Int@@sl$Node () (pfun Int sl$Node))"
    , "(declare-fun empty-fun@@Int@@sl$OBJ () (pfun Int sl$OBJ))"
    , "(declare-fun empty-fun@@sl$Node@@sl$Node"
    , "             ()"
    , "             (pfun sl$Node sl$Node))"
    , "(declare-fun empty-fun@@sl$Node@@sl$OBJ"
    , "             ()"
    , "             (pfun sl$Node sl$OBJ))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$Node"
    , "             ()"
    , "             (pfun sl$REQ sl$Node))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$OBJ () (pfun sl$REQ sl$OBJ))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$Node ( (set sl$Node) ) Bool)"
    , "(declare-fun finite@@sl$OBJ ( (set sl$OBJ) ) Bool)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$Node@Close"
    , "             ( (set (pfun Int sl$Node)) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$OBJ@Close"
    , "             ( (set (pfun Int sl$OBJ)) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "             ( (set (pfun sl$Node sl$Node)) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "             ( (set (pfun sl$Node sl$OBJ)) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "             ( (set (pfun sl$REQ sl$Node)) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "             ( (set (pfun sl$REQ sl$OBJ)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl$Node ( (pfun Int sl$Node) ) Bool)"
    , "(declare-fun injective@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) Bool)"
    , "(declare-fun injective@@sl$Node@@sl$Node"
    , "             ( (pfun sl$Node sl$Node) )"
    , "             Bool)"
    , "(declare-fun injective@@sl$Node@@sl$OBJ"
    , "             ( (pfun sl$Node sl$OBJ) )"
    , "             Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$Node"
    , "             ( (pfun sl$REQ sl$Node) )"
    , "             Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@sl$Node"
    , "             (Int sl$Node)"
    , "             (pfun Int sl$Node))"
    , "(declare-fun mk-fun@@Int@@sl$OBJ"
    , "             (Int sl$OBJ)"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun mk-fun@@sl$Node@@sl$Node"
    , "             (sl$Node sl$Node)"
    , "             (pfun sl$Node sl$Node))"
    , "(declare-fun mk-fun@@sl$Node@@sl$OBJ"
    , "             (sl$Node sl$OBJ)"
    , "             (pfun sl$Node sl$OBJ))"
    , "(declare-fun mk-fun@@sl$REQ@@sl$Node"
    , "             (sl$REQ sl$Node)"
    , "             (pfun sl$REQ sl$Node))"
    , "(declare-fun mk-fun@@sl$REQ@@sl$OBJ"
    , "             (sl$REQ sl$OBJ)"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$Node (sl$Node) (set sl$Node))"
    , "(declare-fun mk-set@@sl$OBJ (sl$OBJ) (set sl$OBJ))"
    , "(declare-fun mk-set@@sl$REQ (sl$REQ) (set sl$REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$Node@Close"
    , "             ( (pfun Int sl$Node) )"
    , "             (set (pfun Int sl$Node)))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$OBJ@Close"
    , "             ( (pfun Int sl$OBJ) )"
    , "             (set (pfun Int sl$OBJ)))"
    , "(declare-fun mk-set@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "             ( (pfun sl$Node sl$Node) )"
    , "             (set (pfun sl$Node sl$Node)))"
    , "(declare-fun mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "             ( (pfun sl$Node sl$OBJ) )"
    , "             (set (pfun sl$Node sl$OBJ)))"
    , "(declare-fun mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "             ( (pfun sl$REQ sl$Node) )"
    , "             (set (pfun sl$REQ sl$Node)))"
    , "(declare-fun mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             (set (pfun sl$REQ sl$OBJ)))"
    , "(declare-fun ovl@@Int@@sl$Node"
    , "             ( (pfun Int sl$Node)"
    , "               (pfun Int sl$Node) )"
    , "             (pfun Int sl$Node))"
    , "(declare-fun ovl@@Int@@sl$OBJ"
    , "             ( (pfun Int sl$OBJ)"
    , "               (pfun Int sl$OBJ) )"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun ovl@@sl$Node@@sl$Node"
    , "             ( (pfun sl$Node sl$Node)"
    , "               (pfun sl$Node sl$Node) )"
    , "             (pfun sl$Node sl$Node))"
    , "(declare-fun ovl@@sl$Node@@sl$OBJ"
    , "             ( (pfun sl$Node sl$OBJ)"
    , "               (pfun sl$Node sl$OBJ) )"
    , "             (pfun sl$Node sl$OBJ))"
    , "(declare-fun ovl@@sl$REQ@@sl$Node"
    , "             ( (pfun sl$REQ sl$Node)"
    , "               (pfun sl$REQ sl$Node) )"
    , "             (pfun sl$REQ sl$Node))"
    , "(declare-fun ovl@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ)"
    , "               (pfun sl$REQ sl$OBJ) )"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun pfun@@Int@@sl$Node"
    , "             ( (set Int)"
    , "               (set sl$Node) )"
    , "             (set (pfun Int sl$Node)))"
    , "(declare-fun pfun@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun Int sl$OBJ)))"
    , "(declare-fun pfun@@sl$Node@@sl$Node"
    , "             ( (set sl$Node)"
    , "               (set sl$Node) )"
    , "             (set (pfun sl$Node sl$Node)))"
    , "(declare-fun pfun@@sl$Node@@sl$OBJ"
    , "             ( (set sl$Node)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun sl$Node sl$OBJ)))"
    , "(declare-fun pfun@@sl$REQ@@sl$Node"
    , "             ( (set sl$REQ)"
    , "               (set sl$Node) )"
    , "             (set (pfun sl$REQ sl$Node)))"
    , "(declare-fun pfun@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun sl$REQ sl$OBJ)))"
    , "(declare-fun ran@@Int@@sl$Node"
    , "             ( (pfun Int sl$Node) )"
    , "             (set sl$Node))"
    , "(declare-fun ran@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) (set sl$OBJ))"
    , "(declare-fun ran@@sl$Node@@sl$Node"
    , "             ( (pfun sl$Node sl$Node) )"
    , "             (set sl$Node))"
    , "(declare-fun ran@@sl$Node@@sl$OBJ"
    , "             ( (pfun sl$Node sl$OBJ) )"
    , "             (set sl$OBJ))"
    , "(declare-fun ran@@sl$REQ@@sl$Node"
    , "             ( (pfun sl$REQ sl$Node) )"
    , "             (set sl$Node))"
    , "(declare-fun ran@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             (set sl$OBJ))"
    , "(declare-fun tfun@@Int@@sl$Node"
    , "             ( (set Int)"
    , "               (set sl$Node) )"
    , "             (set (pfun Int sl$Node)))"
    , "(declare-fun tfun@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun Int sl$OBJ)))"
    , "(declare-fun tfun@@sl$Node@@sl$Node"
    , "             ( (set sl$Node)"
    , "               (set sl$Node) )"
    , "             (set (pfun sl$Node sl$Node)))"
    , "(declare-fun tfun@@sl$Node@@sl$OBJ"
    , "             ( (set sl$Node)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun sl$Node sl$OBJ)))"
    , "(declare-fun tfun@@sl$REQ@@sl$Node"
    , "             ( (set sl$REQ)"
    , "               (set sl$Node) )"
    , "             (set (pfun sl$REQ sl$Node)))"
    , "(declare-fun tfun@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun sl$REQ sl$OBJ)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$Node"
    , "            ()"
    , "            (set sl$Node)"
    , "            ( (as const (set sl$Node))"
    , "              true ))"
    , "(define-fun all@@sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ)"
    , "            ( (as const (set sl$OBJ))"
    , "              true ))"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$Node@Close"
    , "            ()"
    , "            (set (pfun Int sl$Node))"
    , "            ( (as const (set (pfun Int sl$Node)))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun Int sl$OBJ))"
    , "            ( (as const (set (pfun Int sl$OBJ)))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "            ()"
    , "            (set (pfun sl$Node sl$Node))"
    , "            ( (as const (set (pfun sl$Node sl$Node)))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun sl$Node sl$OBJ))"
    , "            ( (as const (set (pfun sl$Node sl$OBJ)))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "            ()"
    , "            (set (pfun sl$REQ sl$Node))"
    , "            ( (as const (set (pfun sl$REQ sl$Node)))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun sl$REQ sl$OBJ))"
    , "            ( (as const (set (pfun sl$REQ sl$OBJ)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$Node"
    , "            ( (s1 (set sl$Node)) )"
    , "            (set sl$Node)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$OBJ"
    , "            ( (s1 (set sl$OBJ)) )"
    , "            (set sl$OBJ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$Node@Close"
    , "            ( (s1 (set (pfun Int sl$Node))) )"
    , "            (set (pfun Int sl$Node))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun Int sl$OBJ))) )"
    , "            (set (pfun Int sl$OBJ))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "            ( (s1 (set (pfun sl$Node sl$Node))) )"
    , "            (set (pfun sl$Node sl$Node))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$Node sl$OBJ))) )"
    , "            (set (pfun sl$Node sl$OBJ))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$Node))) )"
    , "            (set (pfun sl$REQ sl$Node))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$OBJ))) )"
    , "            (set (pfun sl$REQ sl$OBJ))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$Node"
    , "            ( (x sl$Node)"
    , "              (s1 (set sl$Node)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$OBJ"
    , "            ( (x sl$OBJ)"
    , "              (s1 (set sl$OBJ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$REQ"
    , "            ( (x sl$REQ)"
    , "              (s1 (set sl$REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$Node@Close"
    , "            ( (x (pfun Int sl$Node))"
    , "              (s1 (set (pfun Int sl$Node))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ( (x (pfun Int sl$OBJ))"
    , "              (s1 (set (pfun Int sl$OBJ))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "            ( (x (pfun sl$Node sl$Node))"
    , "              (s1 (set (pfun sl$Node sl$Node))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "            ( (x (pfun sl$Node sl$OBJ))"
    , "              (s1 (set (pfun sl$Node sl$OBJ))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "            ( (x (pfun sl$REQ sl$Node))"
    , "              (s1 (set (pfun sl$REQ sl$Node))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ( (x (pfun sl$REQ sl$OBJ))"
    , "              (s1 (set (pfun sl$REQ sl$OBJ))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$Node"
    , "            ()"
    , "            (set sl$Node)"
    , "            ( (as const (set sl$Node))"
    , "              false ))"
    , "(define-fun empty-set@@sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ)"
    , "            ( (as const (set sl$OBJ))"
    , "              false ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$Node@Close"
    , "            ()"
    , "            (set (pfun Int sl$Node))"
    , "            ( (as const (set (pfun Int sl$Node)))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun Int sl$OBJ))"
    , "            ( (as const (set (pfun Int sl$OBJ)))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "            ()"
    , "            (set (pfun sl$Node sl$Node))"
    , "            ( (as const (set (pfun sl$Node sl$Node)))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun sl$Node sl$OBJ))"
    , "            ( (as const (set (pfun sl$Node sl$OBJ)))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "            ()"
    , "            (set (pfun sl$REQ sl$Node))"
    , "            ( (as const (set (pfun sl$REQ sl$Node)))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun sl$REQ sl$OBJ))"
    , "            ( (as const (set (pfun sl$REQ sl$OBJ)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$Node"
    , "            ( (s1 (set sl$Node))"
    , "              (s2 (set sl$Node)) )"
    , "            (set sl$Node)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$OBJ"
    , "            ( (s1 (set sl$OBJ))"
    , "              (s2 (set sl$OBJ)) )"
    , "            (set sl$OBJ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$Node@Close"
    , "            ( (s1 (set (pfun Int sl$Node)))"
    , "              (s2 (set (pfun Int sl$Node))) )"
    , "            (set (pfun Int sl$Node))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun Int sl$OBJ)))"
    , "              (s2 (set (pfun Int sl$OBJ))) )"
    , "            (set (pfun Int sl$OBJ))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "            ( (s1 (set (pfun sl$Node sl$Node)))"
    , "              (s2 (set (pfun sl$Node sl$Node))) )"
    , "            (set (pfun sl$Node sl$Node))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$Node sl$OBJ)))"
    , "              (s2 (set (pfun sl$Node sl$OBJ))) )"
    , "            (set (pfun sl$Node sl$OBJ))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$Node)))"
    , "              (s2 (set (pfun sl$REQ sl$Node))) )"
    , "            (set (pfun sl$REQ sl$Node))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "              (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "            (set (pfun sl$REQ sl$OBJ))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$Node"
    , "            ( (s1 (set sl$Node))"
    , "              (s2 (set sl$Node)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$OBJ"
    , "            ( (s1 (set sl$OBJ))"
    , "              (s2 (set sl$OBJ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$Node@Close"
    , "            ( (s1 (set (pfun Int sl$Node)))"
    , "              (s2 (set (pfun Int sl$Node))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun Int sl$OBJ)))"
    , "              (s2 (set (pfun Int sl$OBJ))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "            ( (s1 (set (pfun sl$Node sl$Node)))"
    , "              (s2 (set (pfun sl$Node sl$Node))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$Node sl$OBJ)))"
    , "              (s2 (set (pfun sl$Node sl$OBJ))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$Node)))"
    , "              (s2 (set (pfun sl$REQ sl$Node))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "              (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Node"
    , "            ()"
    , "            (set sl$Node)"
    , "            ( (as const (set sl$Node))"
    , "              true ))"
    , "(define-fun sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ)"
    , "            ( (as const (set sl$OBJ))"
    , "              true ))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$Node))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$Node@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$Node@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$Node@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$OBJ@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$OBJ@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$OBJ@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun sl$Node sl$Node))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$Node@@sl$Node@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@sl$Node@@sl$Node@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@sl$Node@@sl$Node@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun sl$Node sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$Node))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$REQ@@sl$Node@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@sl$REQ@@sl$Node@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@sl$REQ@@sl$Node@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)) ))))"
    , "(assert (forall ( (r (set sl$Node)) )"
    , "                (! (=> (finite@@sl$Node r) (<= 0 (card@@sl$Node r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Node r)) ))))"
    , "(assert (forall ( (r (set sl$OBJ)) )"
    , "                (! (=> (finite@@sl$OBJ r) (<= 0 (card@@sl$OBJ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$OBJ r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$Node))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$Node@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$Node@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$Node@Close r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$OBJ@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$OBJ@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$Node sl$Node))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$Node@@sl$Node@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@sl$Node@@sl$Node@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Node@@sl$Node@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$Node sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@sl$Node@@sl$OBJ@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$Node))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$REQ@@sl$Node@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@sl$REQ@@sl$Node@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$Node@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set sl$Node)) )"
    , "                (! (= (= (card@@sl$Node r) 0) (= r empty-set@@sl$Node))"
    , "                   :pattern"
    , "                   ( (card@@sl$Node r) ))))"
    , "(assert (forall ( (r (set sl$OBJ)) )"
    , "                (! (= (= (card@@sl$OBJ r) 0) (= r empty-set@@sl$OBJ))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$Node)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$Node@Close (mk-set@Open@@pfun@@Int@@sl$Node@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$Node@Close (mk-set@Open@@pfun@@Int@@sl$Node@Close x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$OBJ)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$Node sl$Node)) )"
    , "                (! (= (card@Open@@pfun@@sl$Node@@sl$Node@Close (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Node@@sl$Node@Close (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$Node sl$OBJ)) )"
    , "                (! (= (card@Open@@pfun@@sl$Node@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Node@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$Node)) )"
    , "                (! (= (card@Open@@pfun@@sl$REQ@@sl$Node@Close (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$Node@Close (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x sl$Node) )"
    , "                (! (= (card@@sl$Node (mk-set@@sl$Node x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$Node (mk-set@@sl$Node x)) ))))"
    , "(assert (forall ( (x sl$OBJ) )"
    , "                (! (= (card@@sl$OBJ (mk-set@@sl$OBJ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ (mk-set@@sl$OBJ x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (= (card@@sl$REQ (mk-set@@sl$REQ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$Node))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$Node@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$Node)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@Int@@sl$Node@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$Node@Close r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$OBJ@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$OBJ)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$Node sl$Node))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$Node@@sl$Node@Close r) 1)"
    , "                      (exists ( (x (pfun sl$Node sl$Node)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Node@@sl$Node@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$Node sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r) 1)"
    , "                      (exists ( (x (pfun sl$Node sl$OBJ)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$Node))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$REQ@@sl$Node@Close r) 1)"
    , "                      (exists ( (x (pfun sl$REQ sl$Node)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$Node@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) 1)"
    , "                      (exists ( (x (pfun sl$REQ sl$OBJ)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set sl$Node)) )"
    , "                (! (= (= (card@@sl$Node r) 1)"
    , "                      (exists ( (x sl$Node) )"
    , "                              (and true (= r (mk-set@@sl$Node x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Node r) ))))"
    , "(assert (forall ( (r (set sl$OBJ)) )"
    , "                (! (= (= (card@@sl$OBJ r) 1)"
    , "                      (exists ( (x sl$OBJ) ) (and true (= r (mk-set@@sl$OBJ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 1)"
    , "                      (exists ( (x sl$REQ) ) (and true (= r (mk-set@@sl$REQ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$Node)))"
    , "                  (r0 (set (pfun Int sl$Node))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$Node@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$Node@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$Node@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$Node@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$Node@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$OBJ)))"
    , "                  (r0 (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$OBJ@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$OBJ@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$OBJ@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$OBJ@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun sl$Node sl$Node)))"
    , "                  (r0 (set (pfun sl$Node sl$Node))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@sl$Node@@sl$Node@Close)"
    , "                       (= (card@Open@@pfun@@sl$Node@@sl$Node@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@sl$Node@@sl$Node@Close r)"
    , "                             (card@Open@@pfun@@sl$Node@@sl$Node@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Node@@sl$Node@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun sl$Node sl$OBJ)))"
    , "                  (r0 (set (pfun sl$Node sl$OBJ))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@sl$Node@@sl$OBJ@Close)"
    , "                       (= (card@Open@@pfun@@sl$Node@@sl$OBJ@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r)"
    , "                             (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Node@@sl$OBJ@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$Node)))"
    , "                  (r0 (set (pfun sl$REQ sl$Node))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@sl$REQ@@sl$Node@Close)"
    , "                       (= (card@Open@@pfun@@sl$REQ@@sl$Node@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@sl$REQ@@sl$Node@Close r)"
    , "                             (card@Open@@pfun@@sl$REQ@@sl$Node@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$Node@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$OBJ)))"
    , "                  (r0 (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close)"
    , "                       (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)"
    , "                             (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Node))"
    , "                  (r0 (set sl$Node)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Node)"
    , "                       (= (card@@sl$Node (union r r0))"
    , "                          (+ (card@@sl$Node r) (card@@sl$Node r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Node (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$OBJ))"
    , "                  (r0 (set sl$OBJ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$OBJ)"
    , "                       (= (card@@sl$OBJ (union r r0))"
    , "                          (+ (card@@sl$OBJ r) (card@@sl$OBJ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (= (dom@@Int@@sl$Node empty-fun@@Int@@sl$Node)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node)"
    , "           empty-set@@sl$Node))"
    , "(assert (= (dom@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ)"
    , "           empty-set@@sl$Node))"
    , "(assert (= (dom@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node)"
    , "           empty-set@@sl$REQ))"
    , "(assert (= (dom@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ)"
    , "           empty-set@@sl$REQ))"
    , "(assert (forall ( (f1 (pfun Int sl$Node)) )"
    , "                (! (= (ovl@@Int@@sl$Node f1 empty-fun@@Int@@sl$Node) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$Node f1 empty-fun@@Int@@sl$Node) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ)) )"
    , "                (! (= (ovl@@Int@@sl$OBJ f1 empty-fun@@Int@@sl$OBJ) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$OBJ f1 empty-fun@@Int@@sl$OBJ) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node)) )"
    , "                (! (= (ovl@@sl$Node@@sl$Node f1 empty-fun@@sl$Node@@sl$Node)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Node@@sl$Node f1 empty-fun@@sl$Node@@sl$Node) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ)) )"
    , "                (! (= (ovl@@sl$Node@@sl$OBJ f1 empty-fun@@sl$Node@@sl$OBJ)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Node@@sl$OBJ f1 empty-fun@@sl$Node@@sl$OBJ) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$Node f1 empty-fun@@sl$REQ@@sl$Node)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$Node f1 empty-fun@@sl$REQ@@sl$Node) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$OBJ f1 empty-fun@@sl$REQ@@sl$OBJ)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$OBJ f1 empty-fun@@sl$REQ@@sl$OBJ) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node)) )"
    , "                (! (= (ovl@@Int@@sl$Node empty-fun@@Int@@sl$Node f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$Node empty-fun@@Int@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ)) )"
    , "                (! (= (ovl@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node)) )"
    , "                (! (= (ovl@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ)) )"
    , "                (! (= (ovl@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ f1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (dom@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (dom@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (dom@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y))"
    , "                      (mk-set@@sl$Node x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y)) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (dom@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                      (mk-set@@sl$Node x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (dom@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y))"
    , "                      (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                      (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (f2 (pfun Int sl$Node))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$Node f2))"
    , "                       (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x)"
    , "                          (apply@@Int@@sl$Node f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (f2 (pfun Int sl$OBJ))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$OBJ f2))"
    , "                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x)"
    , "                          (apply@@Int@@sl$OBJ f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (f2 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$Node f2))"
    , "                       (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x)"
    , "                          (apply@@sl$Node@@sl$Node f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (f2 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f2))"
    , "                       (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x)"
    , "                          (apply@@sl$Node@@sl$OBJ f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (f2 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f2))"
    , "                       (= (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$Node f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (f2 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f2))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$OBJ f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (f2 (pfun Int sl$Node))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl$Node f2))))"
    , "                       (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x)"
    , "                          (apply@@Int@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (f2 (pfun Int sl$OBJ))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl$OBJ f2))))"
    , "                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x)"
    , "                          (apply@@Int@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (f2 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                            (not (elem@@sl$Node x (dom@@sl$Node@@sl$Node f2))))"
    , "                       (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x)"
    , "                          (apply@@sl$Node@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (f2 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node) )"
    , "                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                            (not (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f2))))"
    , "                       (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x)"
    , "                          (apply@@sl$Node@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (f2 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                            (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f2))))"
    , "                       (= (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (f2 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                            (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f2))))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (apply@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y) x) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (apply@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y) x) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y) x) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (apply@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y) x) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl$Node f1)))"
    , "                       (= (apply@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1) x)"
    , "                          (apply@@Int@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl$OBJ f1)))"
    , "                       (= (apply@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1) x)"
    , "                          (apply@@Int@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (and (elem@@sl$Node x s1)"
    , "                            (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1)))"
    , "                       (= (apply@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1) x)"
    , "                          (apply@@sl$Node@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (and (elem@@sl$Node x s1)"
    , "                            (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1)))"
    , "                       (= (apply@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1) x)"
    , "                          (apply@@sl$Node@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x s1)"
    , "                            (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1)))"
    , "                       (= (apply@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x s1)"
    , "                            (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$Node f1) s1))"
    , "                       (= (apply@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1) x)"
    , "                          (apply@@Int@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))"
    , "                       (= (apply@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1) x)"
    , "                          (apply@@Int@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x"
    , "                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$Node f1) s1))"
    , "                       (= (apply@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1) x)"
    , "                          (apply@@sl$Node@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x"
    , "                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$OBJ f1) s1))"
    , "                       (= (apply@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1) x)"
    , "                          (apply@@sl$Node@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$Node f1) s1))"
    , "                       (= (apply@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (s2 (set sl$Node)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$Node@Close empty-fun@@Int@@sl$Node"
    , "                                                        (tfun@@Int@@sl$Node empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$Node@Close empty-fun@@Int@@sl$Node"
    , "                                                          (tfun@@Int@@sl$Node empty-set@@Int s2)) ))))"
    , "(assert (forall ( (s2 (set sl$OBJ)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$OBJ@Close empty-fun@@Int@@sl$OBJ"
    , "                                                       (tfun@@Int@@sl$OBJ empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close empty-fun@@Int@@sl$OBJ"
    , "                                                         (tfun@@Int@@sl$OBJ empty-set@@Int s2)) ))))"
    , "(assert (forall ( (s2 (set sl$Node)) )"
    , "                (! (elem@Open@@pfun@@sl$Node@@sl$Node@Close empty-fun@@sl$Node@@sl$Node"
    , "                                                            (tfun@@sl$Node@@sl$Node empty-set@@sl$Node s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Node@@sl$Node@Close empty-fun@@sl$Node@@sl$Node"
    , "                                                              (tfun@@sl$Node@@sl$Node empty-set@@sl$Node s2)) ))))"
    , "(assert (forall ( (s2 (set sl$OBJ)) )"
    , "                (! (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close empty-fun@@sl$Node@@sl$OBJ"
    , "                                                           (tfun@@sl$Node@@sl$OBJ empty-set@@sl$Node s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close empty-fun@@sl$Node@@sl$OBJ"
    , "                                                             (tfun@@sl$Node@@sl$OBJ empty-set@@sl$Node s2)) ))))"
    , "(assert (forall ( (s2 (set sl$Node)) )"
    , "                (! (elem@Open@@pfun@@sl$REQ@@sl$Node@Close empty-fun@@sl$REQ@@sl$Node"
    , "                                                           (tfun@@sl$REQ@@sl$Node empty-set@@sl$REQ s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$Node@Close empty-fun@@sl$REQ@@sl$Node"
    , "                                                             (tfun@@sl$REQ@@sl$Node empty-set@@sl$REQ s2)) ))))"
    , "(assert (forall ( (s2 (set sl$OBJ)) )"
    , "                (! (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close empty-fun@@sl$REQ@@sl$OBJ"
    , "                                                          (tfun@@sl$REQ@@sl$OBJ empty-set@@sl$REQ s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close empty-fun@@sl$REQ@@sl$OBJ"
    , "                                                            (tfun@@sl$REQ@@sl$OBJ empty-set@@sl$REQ s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (f2 (pfun Int sl$Node)) )"
    , "                (! (= (dom@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2))"
    , "                      (union (dom@@Int@@sl$Node f1) (dom@@Int@@sl$Node f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (f2 (pfun Int sl$OBJ)) )"
    , "                (! (= (dom@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2))"
    , "                      (union (dom@@Int@@sl$OBJ f1) (dom@@Int@@sl$OBJ f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (f2 (pfun sl$Node sl$Node)) )"
    , "                (! (= (dom@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2))"
    , "                      (union (dom@@sl$Node@@sl$Node f1)"
    , "                             (dom@@sl$Node@@sl$Node f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (f2 (pfun sl$Node sl$OBJ)) )"
    , "                (! (= (dom@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2))"
    , "                      (union (dom@@sl$Node@@sl$OBJ f1)"
    , "                             (dom@@sl$Node@@sl$OBJ f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (f2 (pfun sl$REQ sl$Node)) )"
    , "                (! (= (dom@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$Node f1)"
    , "                             (dom@@sl$REQ@@sl$Node f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (f2 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$OBJ f1) (dom@@sl$REQ@@sl$OBJ f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node)) )"
    , "                (! (= (dom@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1))"
    , "                      (intersect s1 (dom@@sl$Node@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node)) )"
    , "                (! (= (dom@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1))"
    , "                      (intersect s1 (dom@@sl$Node@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$Node f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node)) )"
    , "                (! (= (dom@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1))"
    , "                      (set-diff@@sl$Node (dom@@sl$Node@@sl$Node f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node)) )"
    , "                (! (= (dom@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1))"
    , "                      (set-diff@@sl$Node (dom@@sl$Node@@sl$OBJ f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$Node f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                           (= (apply@@sl$REQ@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                     (apply@@sl$REQ@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                           (= (apply@@sl$REQ@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                     (apply@@sl$REQ@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                           (= (apply@@sl$REQ@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                     (apply@@sl$REQ@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                           (= (apply@@sl$REQ@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                     (apply@@sl$REQ@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                           (= (apply@@sl$REQ@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                     (apply@@sl$REQ@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                           (= (apply@@sl$REQ@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                     (apply@@sl$REQ@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl$Node) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))"
    , "                                               x2)"
    , "                          (apply@@Int@@sl$Node f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))"
    , "                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))"
    , "                                              x2)"
    , "                          (apply@@Int@@sl$OBJ f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))"
    , "                                         x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (x2 sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))"
    , "                                                   x2)"
    , "                          (apply@@sl$Node@@sl$Node f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))"
    , "                                              x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (x2 sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                                                  x2)"
    , "                          (apply@@sl$Node@@sl$OBJ f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                                             x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (x2 sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))"
    , "                                                  x2)"
    , "                          (apply@@sl$REQ@@sl$Node f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))"
    , "                                             x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (x2 sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                                                 x2)"
    , "                          (apply@@sl$REQ@@sl$OBJ f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                                            x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))"
    , "                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))"
    , "                                          x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))"
    , "                                               x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))"
    , "                                              x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                                              x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                                             x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))"
    , "                                              x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))"
    , "                                             x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                                             x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                                            x) ))))"
    , "(assert (= (ran@@Int@@sl$Node empty-fun@@Int@@sl$Node)"
    , "           empty-set@@sl$Node))"
    , "(assert (= (ran@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ)"
    , "           empty-set@@sl$OBJ))"
    , "(assert (= (ran@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node)"
    , "           empty-set@@sl$Node))"
    , "(assert (= (ran@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ)"
    , "           empty-set@@sl$OBJ))"
    , "(assert (= (ran@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node)"
    , "           empty-set@@sl$Node))"
    , "(assert (= (ran@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ)"
    , "           empty-set@@sl$OBJ))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (y sl$Node) )"
    , "                (! (= (elem@@sl$Node y (ran@@Int@@sl$Node f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                                        (= (apply@@Int@@sl$Node f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node y (ran@@Int@@sl$Node f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ y (ran@@Int@@sl$OBJ f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                                        (= (apply@@Int@@sl$OBJ f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ y (ran@@Int@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (y sl$Node) )"
    , "                (! (= (elem@@sl$Node y (ran@@sl$Node@@sl$Node f1))"
    , "                      (exists ( (x sl$Node) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                                        (= (apply@@sl$Node@@sl$Node f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node y (ran@@sl$Node@@sl$Node f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ y (ran@@sl$Node@@sl$OBJ f1))"
    , "                      (exists ( (x sl$Node) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                                        (= (apply@@sl$Node@@sl$OBJ f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ y (ran@@sl$Node@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (y sl$Node) )"
    , "                (! (= (elem@@sl$Node y (ran@@sl$REQ@@sl$Node f1))"
    , "                      (exists ( (x sl$REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                                        (= (apply@@sl$REQ@@sl$Node f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node y (ran@@sl$REQ@@sl$Node f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ y (ran@@sl$REQ@@sl$OBJ f1))"
    , "                      (exists ( (x sl$REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                                        (= (apply@@sl$REQ@@sl$OBJ f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ y (ran@@sl$REQ@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (ran@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y))"
    , "                      (mk-set@@sl$Node y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (ran@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y))"
    , "                      (mk-set@@sl$OBJ y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (ran@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y))"
    , "                      (mk-set@@sl$Node y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y)) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (ran@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                      (mk-set@@sl$OBJ y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (ran@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y))"
    , "                      (mk-set@@sl$Node y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (ran@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                      (mk-set@@sl$OBJ y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$Node@Close f1 (tfun@@Int@@sl$Node s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$Node f1))"
    , "                           (subset (ran@@Int@@sl$Node f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$Node@Close f1 (tfun@@Int@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (tfun@@Int@@sl$OBJ s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$OBJ f1))"
    , "                           (subset (ran@@Int@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (tfun@@Int@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@sl$Node@@sl$Node@Close f1 (tfun@@sl$Node@@sl$Node s1 s2))"
    , "                      (and (= s1 (dom@@sl$Node@@sl$Node f1))"
    , "                           (subset (ran@@sl$Node@@sl$Node f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Node@@sl$Node@Close f1 (tfun@@sl$Node@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close f1 (tfun@@sl$Node@@sl$OBJ s1 s2))"
    , "                      (and (= s1 (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (subset (ran@@sl$Node@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close f1 (tfun@@sl$Node@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$Node@Close f1 (tfun@@sl$REQ@@sl$Node s1 s2))"
    , "                      (and (= s1 (dom@@sl$REQ@@sl$Node f1))"
    , "                           (subset (ran@@sl$REQ@@sl$Node f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$Node@Close f1 (tfun@@sl$REQ@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (tfun@@sl$REQ@@sl$OBJ s1 s2))"
    , "                      (and (= s1 (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (subset (ran@@sl$REQ@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (tfun@@sl$REQ@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$Node@Close f1 (pfun@@Int@@sl$Node s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$Node f1) s1)"
    , "                           (subset (ran@@Int@@sl$Node f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$Node@Close f1 (pfun@@Int@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (pfun@@Int@@sl$OBJ s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$OBJ f1) s1)"
    , "                           (subset (ran@@Int@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (pfun@@Int@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@sl$Node@@sl$Node@Close f1 (pfun@@sl$Node@@sl$Node s1 s2))"
    , "                      (and (subset (dom@@sl$Node@@sl$Node f1) s1)"
    , "                           (subset (ran@@sl$Node@@sl$Node f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Node@@sl$Node@Close f1 (pfun@@sl$Node@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close f1 (pfun@@sl$Node@@sl$OBJ s1 s2))"
    , "                      (and (subset (dom@@sl$Node@@sl$OBJ f1) s1)"
    , "                           (subset (ran@@sl$Node@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close f1 (pfun@@sl$Node@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$Node@Close f1 (pfun@@sl$REQ@@sl$Node s1 s2))"
    , "                      (and (subset (dom@@sl$REQ@@sl$Node f1) s1)"
    , "                           (subset (ran@@sl$REQ@@sl$Node f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$Node@Close f1 (pfun@@sl$REQ@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (pfun@@sl$REQ@@sl$OBJ s1 s2))"
    , "                      (and (subset (dom@@sl$REQ@@sl$OBJ f1) s1)"
    , "                           (subset (ran@@sl$REQ@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (pfun@@sl$REQ@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node)) )"
    , "                (! (= (injective@@Int@@sl$Node f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl$Node f1)))"
    , "                                  (=> (= (apply@@Int@@sl$Node f1 x)"
    , "                                         (apply@@Int@@sl$Node f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ)) )"
    , "                (! (= (injective@@Int@@sl$OBJ f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl$OBJ f1)))"
    , "                                  (=> (= (apply@@Int@@sl$OBJ f1 x)"
    , "                                         (apply@@Int@@sl$OBJ f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl$OBJ f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node)) )"
    , "                (! (= (injective@@sl$Node@@sl$Node f1)"
    , "                      (forall ( (x sl$Node)"
    , "                                (x2 sl$Node) )"
    , "                              (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                                       (elem@@sl$Node x2 (dom@@sl$Node@@sl$Node f1)))"
    , "                                  (=> (= (apply@@sl$Node@@sl$Node f1 x)"
    , "                                         (apply@@sl$Node@@sl$Node f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$Node@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ)) )"
    , "                (! (= (injective@@sl$Node@@sl$OBJ f1)"
    , "                      (forall ( (x sl$Node)"
    , "                                (x2 sl$Node) )"
    , "                              (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                                       (elem@@sl$Node x2 (dom@@sl$Node@@sl$OBJ f1)))"
    , "                                  (=> (= (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                         (apply@@sl$Node@@sl$OBJ f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$Node@@sl$OBJ f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node)) )"
    , "                (! (= (injective@@sl$REQ@@sl$Node f1)"
    , "                      (forall ( (x sl$REQ)"
    , "                                (x2 sl$REQ) )"
    , "                              (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                                       (elem@@sl$REQ x2 (dom@@sl$REQ@@sl$Node f1)))"
    , "                                  (=> (= (apply@@sl$REQ@@sl$Node f1 x)"
    , "                                         (apply@@sl$REQ@@sl$Node f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$REQ@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (injective@@sl$REQ@@sl$OBJ f1)"
    , "                      (forall ( (x sl$REQ)"
    , "                                (x2 sl$REQ) )"
    , "                              (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                                       (elem@@sl$REQ x2 (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                                  (=> (= (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                         (apply@@sl$REQ@@sl$OBJ f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$REQ@@sl$OBJ f1) ))))"
    , "(assert (injective@@Int@@sl$Node empty-fun@@Int@@sl$Node))"
    , "(assert (injective@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ))"
    , "(assert (injective@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node))"
    , "(assert (injective@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ))"
    , "(assert (injective@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node))"
    , "(assert (injective@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                       (elem@@sl$Node (apply@@Int@@sl$Node f1 x) (ran@@Int@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@Int@@sl$Node f1 x) (ran@@Int@@sl$Node f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x) (ran@@Int@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x) (ran@@Int@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                       (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                      (ran@@sl$Node@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                    (ran@@sl$Node@@sl$Node f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                       (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$Node@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$Node@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                       (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)"
    , "                                      (ran@@sl$REQ@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)"
    , "                                    (ran@@sl$REQ@@sl$Node f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                       (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$REQ@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$REQ@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$Node f1) s1))"
    , "                       (elem@@sl$Node (apply@@Int@@sl$Node f1 x)"
    , "                                      (ran@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@Int@@sl$Node f1 x)"
    , "                                    (ran@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                     (ran@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                   (ran@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x"
    , "                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$Node f1) s1))"
    , "                       (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                      (ran@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                    (ran@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x"
    , "                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$Node f1) s1))"
    , "                       (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)"
    , "                                      (ran@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)"
    , "                                    (ran@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$Node f1) s1))"
    , "                       (elem@@sl$Node (apply@@Int@@sl$Node f1 x)"
    , "                                      (ran@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@Int@@sl$Node f1 x)"
    , "                                    (ran@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                     (ran@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                   (ran@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (intersect (dom@@sl$Node@@sl$Node f1) s1))"
    , "                       (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                      (ran@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                    (ran@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (intersect (dom@@sl$Node@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (intersect (dom@@sl$REQ@@sl$Node f1) s1))"
    , "                       (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)"
    , "                                      (ran@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)"
    , "                                    (ran@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (intersect (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                            (injective@@Int@@sl$Node f1))"
    , "                       (= (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y)))"
    , "                          (union (set-diff@@sl$Node (ran@@Int@@sl$Node f1)"
    , "                                                    (mk-set@@sl$Node (apply@@Int@@sl$Node f1 x)))"
    , "                                 (mk-set@@sl$Node y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                            (injective@@Int@@sl$OBJ f1))"
    , "                       (= (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)))"
    , "                          (union (set-diff@@sl$OBJ (ran@@Int@@sl$OBJ f1)"
    , "                                                   (mk-set@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)))"
    , "                                 (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                            (injective@@sl$Node@@sl$Node f1))"
    , "                       (= (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y)))"
    , "                          (union (set-diff@@sl$Node (ran@@sl$Node@@sl$Node f1)"
    , "                                                    (mk-set@@sl$Node (apply@@sl$Node@@sl$Node f1 x)))"
    , "                                 (mk-set@@sl$Node y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                            (injective@@sl$Node@@sl$OBJ f1))"
    , "                       (= (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y)))"
    , "                          (union (set-diff@@sl$OBJ (ran@@sl$Node@@sl$OBJ f1)"
    , "                                                   (mk-set@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)))"
    , "                                 (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                            (injective@@sl$REQ@@sl$Node f1))"
    , "                       (= (ran@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y)))"
    , "                          (union (set-diff@@sl$Node (ran@@sl$REQ@@sl$Node f1)"
    , "                                                    (mk-set@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)))"
    , "                                 (mk-set@@sl$Node y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                            (injective@@sl$REQ@@sl$OBJ f1))"
    , "                       (= (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y)))"
    , "                          (union (set-diff@@sl$OBJ (ran@@sl$REQ@@sl$OBJ f1)"
    , "                                                   (mk-set@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)))"
    , "                                 (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl$Node f1)))"
    , "                       (= (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y)))"
    , "                          (union (ran@@Int@@sl$Node f1) (mk-set@@sl$Node y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl$OBJ f1)))"
    , "                       (= (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)))"
    , "                          (union (ran@@Int@@sl$OBJ f1) (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (=> (not (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1)))"
    , "                       (= (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y)))"
    , "                          (union (ran@@sl$Node@@sl$Node f1) (mk-set@@sl$Node y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1)))"
    , "                       (= (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y)))"
    , "                          (union (ran@@sl$Node@@sl$OBJ f1) (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (=> (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1)))"
    , "                       (= (ran@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y)))"
    , "                          (union (ran@@sl$REQ@@sl$Node f1) (mk-set@@sl$Node y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                       (= (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y)))"
    , "                          (union (ran@@sl$REQ@@sl$OBJ f1) (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$Node))"
    , "                  (y (pfun Int sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$Node@Close x (mk-set@Open@@pfun@@Int@@sl$Node@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$Node@Close x (mk-set@Open@@pfun@@Int@@sl$Node@Close y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$OBJ))"
    , "                  (y (pfun Int sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$OBJ@Close x (mk-set@Open@@pfun@@Int@@sl$OBJ@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close x (mk-set@Open@@pfun@@Int@@sl$OBJ@Close y)) ))))"
    , "(assert (forall ( (x (pfun sl$Node sl$Node))"
    , "                  (y (pfun sl$Node sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@sl$Node@@sl$Node@Close x (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Node@@sl$Node@Close x (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close y)) ))))"
    , "(assert (forall ( (x (pfun sl$Node sl$OBJ))"
    , "                  (y (pfun sl$Node sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close x (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close x (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close y)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$Node))"
    , "                  (y (pfun sl$REQ sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$Node@Close x (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$Node@Close x (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close y)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$OBJ))"
    , "                  (y (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close x (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close x (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close y)) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (elem@@sl$Node x (mk-set@@sl$Node y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (mk-set@@sl$Node y)) ))))"
    , "(assert (forall ( (x sl$OBJ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ x (mk-set@@sl$OBJ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ x (mk-set@@sl$OBJ y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$REQ) )"
    , "                (! (= (elem@@sl$REQ x (mk-set@@sl$REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (mk-set@@sl$REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$Node)))"
    , "                  (s2 (set (pfun Int sl$Node))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$Node@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$Node@Close (set-diff@Open@@pfun@@Int@@sl$Node@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$Node@Close (set-diff@Open@@pfun@@Int@@sl$Node@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$OBJ)))"
    , "                  (s2 (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$OBJ@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Node sl$Node)))"
    , "                  (s2 (set (pfun sl$Node sl$Node))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$Node@@sl$Node@Close s1)"
    , "                       (finite@Open@@pfun@@sl$Node@@sl$Node@Close (set-diff@Open@@pfun@@sl$Node@@sl$Node@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Node@@sl$Node@Close (set-diff@Open@@pfun@@sl$Node@@sl$Node@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Node sl$OBJ)))"
    , "                  (s2 (set (pfun sl$Node sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s1)"
    , "                       (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$Node@@sl$OBJ@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$Node@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$Node)))"
    , "                  (s2 (set (pfun sl$REQ sl$Node))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s1)"
    , "                       (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (set-diff@Open@@pfun@@sl$REQ@@sl$Node@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (set-diff@Open@@pfun@@sl$REQ@@sl$Node@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "                  (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1)"
    , "                       (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Node))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (=> (finite@@sl$Node s1)"
    , "                       (finite@@sl$Node (set-diff@@sl$Node s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Node (set-diff@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (=> (finite@@sl$OBJ s1)"
    , "                       (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$Node)))"
    , "                  (s2 (set (pfun Int sl$Node))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$Node@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$Node@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$Node@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$Node@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$OBJ)))"
    , "                  (s2 (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$OBJ@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$OBJ@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$OBJ@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Node sl$Node)))"
    , "                  (s2 (set (pfun sl$Node sl$Node))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$Node@@sl$Node@Close s1)"
    , "                            (finite@Open@@pfun@@sl$Node@@sl$Node@Close s2))"
    , "                       (finite@Open@@pfun@@sl$Node@@sl$Node@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Node@@sl$Node@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Node sl$OBJ)))"
    , "                  (s2 (set (pfun sl$Node sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s1)"
    , "                            (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s2))"
    , "                       (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$Node)))"
    , "                  (s2 (set (pfun sl$REQ sl$Node))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s1)"
    , "                            (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s2))"
    , "                       (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "                  (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1)"
    , "                            (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s2))"
    , "                       (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Node))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (=> (and (finite@@sl$Node s1) (finite@@sl$Node s2))"
    , "                       (finite@@sl$Node (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Node (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (=> (and (finite@@sl$OBJ s1) (finite@@sl$OBJ s2))"
    , "                       (finite@@sl$OBJ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))"
    , "                       (not (finite@@Int (set-diff@@Int s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$Node)))"
    , "                  (s2 (set (pfun Int sl$Node))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$Node@Close s2)"
    , "                            (not (finite@Open@@pfun@@Int@@sl$Node@Close s1)))"
    , "                       (not (finite@Open@@pfun@@Int@@sl$Node@Close (set-diff@Open@@pfun@@Int@@sl$Node@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$Node@Close (set-diff@Open@@pfun@@Int@@sl$Node@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$OBJ)))"
    , "                  (s2 (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$OBJ@Close s2)"
    , "                            (not (finite@Open@@pfun@@Int@@sl$OBJ@Close s1)))"
    , "                       (not (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Node sl$Node)))"
    , "                  (s2 (set (pfun sl$Node sl$Node))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$Node@@sl$Node@Close s2)"
    , "                            (not (finite@Open@@pfun@@sl$Node@@sl$Node@Close s1)))"
    , "                       (not (finite@Open@@pfun@@sl$Node@@sl$Node@Close (set-diff@Open@@pfun@@sl$Node@@sl$Node@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Node@@sl$Node@Close (set-diff@Open@@pfun@@sl$Node@@sl$Node@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Node sl$OBJ)))"
    , "                  (s2 (set (pfun sl$Node sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s2)"
    , "                            (not (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s1)))"
    , "                       (not (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$Node@@sl$OBJ@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$Node@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$Node)))"
    , "                  (s2 (set (pfun sl$REQ sl$Node))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s2)"
    , "                            (not (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s1)))"
    , "                       (not (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (set-diff@Open@@pfun@@sl$REQ@@sl$Node@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (set-diff@Open@@pfun@@sl$REQ@@sl$Node@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "                  (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s2)"
    , "                            (not (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1)))"
    , "                       (not (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Node))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (=> (and (finite@@sl$Node s2) (not (finite@@sl$Node s1)))"
    , "                       (not (finite@@sl$Node (set-diff@@sl$Node s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Node (set-diff@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (=> (and (finite@@sl$OBJ s2) (not (finite@@sl$OBJ s1)))"
    , "                       (not (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s2) (not (finite@@sl$REQ s1)))"
    , "                       (not (finite@@sl$REQ (set-diff@@sl$REQ s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$Node)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$Node@Close (mk-set@Open@@pfun@@Int@@sl$Node@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$Node@Close (mk-set@Open@@pfun@@Int@@sl$Node@Close x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$OBJ)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$Node sl$Node)) )"
    , "                (! (finite@Open@@pfun@@sl$Node@@sl$Node@Close (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Node@@sl$Node@Close (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$Node sl$OBJ)) )"
    , "                (! (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$Node)) )"
    , "                (! (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$OBJ)) )"
    , "                (! (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x sl$Node) )"
    , "                (! (finite@@sl$Node (mk-set@@sl$Node x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Node (mk-set@@sl$Node x)) ))))"
    , "(assert (forall ( (x sl$OBJ) )"
    , "                (! (finite@@sl$OBJ (mk-set@@sl$OBJ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (mk-set@@sl$OBJ x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (finite@@sl$REQ (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl$Node@Close empty-set@Open@@pfun@@Int@@sl$Node@Close))"
    , "(assert (finite@Open@@pfun@@Int@@sl$OBJ@Close empty-set@Open@@pfun@@Int@@sl$OBJ@Close))"
    , "(assert (finite@Open@@pfun@@sl$Node@@sl$Node@Close empty-set@Open@@pfun@@sl$Node@@sl$Node@Close))"
    , "(assert (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close empty-set@Open@@pfun@@sl$Node@@sl$OBJ@Close))"
    , "(assert (finite@Open@@pfun@@sl$REQ@@sl$Node@Close empty-set@Open@@pfun@@sl$REQ@@sl$Node@Close))"
    , "(assert (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close))"
    , "(assert (finite@@sl$Node empty-set@@sl$Node))"
    , "(assert (finite@@sl$OBJ empty-set@@sl$OBJ))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "; m2:inv0"
    , "(assert (= (union (union (union pshL pshR) popL) popR) req))"
    , "; m2:inv1"
    , "(assert (= (intersect pshL pshR) empty-set@@sl$REQ))"
    , "; m2:inv2"
    , "(assert (= (intersect pshL popL) empty-set@@sl$REQ))"
    , "; m2:inv3"
    , "(assert (= (intersect pshL popR) empty-set@@sl$REQ))"
    , "; m2:inv4"
    , "(assert (= (intersect pshR popL) empty-set@@sl$REQ))"
    , "; m2:inv5"
    , "(assert (= (intersect pshR popR) empty-set@@sl$REQ))"
    , "; m2:inv6"
    , "(assert (= (intersect popL popR) empty-set@@sl$REQ))"
    , "; m3:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$OBJ@Close qe (tfun@@Int@@sl$OBJ (intervalR p q) sl$OBJ)))"
    , "; m3:inv1"
    , "(assert (<= p q))"
    , "; m3:inv2"
    , "(assert (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close insL (tfun@@sl$REQ@@sl$OBJ pshL sl$OBJ)))"
    , "; m3:inv3"
    , "(assert (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close insR (tfun@@sl$REQ@@sl$OBJ pshR sl$OBJ)))"
    , "; m3:inv4"
    , "(assert (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close res (pfun@@sl$REQ@@sl$OBJ ppd sl$OBJ)))"
    , "; m4:asm0"
    , "(assert (not (finite@@sl$Node sl$Node)))"
    , "; m4:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$Node@Close rep (tfun@@Int@@sl$Node (intervalR p q) node)))"
    , "; m4:inv1"
    , "(assert (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close item (tfun@@sl$Node@@sl$OBJ node sl$OBJ)))"
    , "; m4:inv10"
    , "(assert (not (elem@@sl$Node dummy (ran@@Int@@sl$Node rep))))"
    , "; m4:inv11"
    , "(assert (not (elem@@sl$Node dummy (ran@@sl$REQ@@sl$Node nL))))"
    , "; m4:inv12"
    , "(assert (not (elem@@sl$Node dummy (ran@@sl$REQ@@sl$Node nR))))"
    , "; m4:inv3"
    , "(assert (forall ( (i Int) )"
    , "                (! (=> (betweenR p i q)"
    , "                       (= (apply@@Int@@sl$OBJ qe i)"
    , "                          (apply@@sl$Node@@sl$OBJ item (apply@@Int@@sl$Node rep i))))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ qe i) ))))"
    , "; m4:inv4"
    , "(assert (elem@Open@@pfun@@sl$REQ@@sl$Node@Close nL (pfun@@sl$REQ@@sl$Node pshL node)))"
    , "; m4:inv5"
    , "(assert (elem@Open@@pfun@@sl$REQ@@sl$Node@Close nR (pfun@@sl$REQ@@sl$Node pshR node)))"
    , "; m4:inv6"
    , "(assert (forall ( (r sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ r (dom@@sl$REQ@@sl$Node nL))"
    , "                       (= (apply@@sl$Node@@sl$OBJ item (apply@@sl$REQ@@sl$Node nL r))"
    , "                          (apply@@sl$REQ@@sl$OBJ insL r)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ item (apply@@sl$REQ@@sl$Node nL r)) ))))"
    , "; m4:inv7"
    , "(assert (forall ( (r sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ r (dom@@sl$REQ@@sl$Node nR))"
    , "                       (= (apply@@sl$Node@@sl$OBJ item (apply@@sl$REQ@@sl$Node nR r))"
    , "                          (apply@@sl$REQ@@sl$OBJ insR r)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ item (apply@@sl$REQ@@sl$Node nR r)) ))))"
    , "; m4:inv8"
    , "(assert (finite@@sl$Node node))"
    , "; m4:inv9"
    , "(assert (elem@@sl$Node dummy node))"
    , "(assert (not (=> (and (elem@Open@@pfun@@sl$Node@@sl$Node@Close left (tfun@@sl$Node@@sl$Node node node))"
    , "                      (elem@Open@@pfun@@sl$Node@@sl$Node@Close right (tfun@@sl$Node@@sl$Node node node))"
    , "                      (=> (= p q) (and (= LH dummy) (= RH dummy))))"
    , "                 (or (and (or (not (< p q))"
    , "                              (and (= LH (apply@@Int@@sl$Node rep p))"
    , "                                   (elem@@Int p (dom@@Int@@sl$Node rep))"
    , "                                   (= RH (apply@@Int@@sl$Node rep (- q 1)))"
    , "                                   (elem@@Int (- q 1) (dom@@Int@@sl$Node rep))))"
    , "                          (= (apply@@sl$Node@@sl$Node left dummy) dummy)"
    , "                          (elem@@sl$Node dummy (dom@@sl$Node@@sl$Node left))"
    , "                          (= (apply@@sl$Node@@sl$Node right dummy) dummy)"
    , "                          (elem@@sl$Node dummy (dom@@sl$Node@@sl$Node right))"
    , "                          (forall ( (i Int) )"
    , "                                  (=> true"
    , "                                      (or (not (betweenR p i (- q 1)))"
    , "                                          (and (= (apply@@sl$Node@@sl$Node right (apply@@Int@@sl$Node rep i))"
    , "                                                  (apply@@Int@@sl$Node rep (+ i 1)))"
    , "                                               (elem@@sl$Node (apply@@Int@@sl$Node rep i)"
    , "                                                              (dom@@sl$Node@@sl$Node right))"
    , "                                               (elem@@Int i (dom@@Int@@sl$Node rep))"
    , "                                               (elem@@Int (+ i 1) (dom@@Int@@sl$Node rep))))))"
    , "                          (forall ( (i Int) )"
    , "                                  (=> true"
    , "                                      (or (not (betweenR p i (- q 1)))"
    , "                                          (and (= (apply@@sl$Node@@sl$Node left (apply@@Int@@sl$Node rep (+ i 1)))"
    , "                                                  (apply@@Int@@sl$Node rep i))"
    , "                                               (elem@@sl$Node (apply@@Int@@sl$Node rep (+ i 1))"
    , "                                                              (dom@@sl$Node@@sl$Node left))"
    , "                                               (elem@@Int (+ i 1) (dom@@Int@@sl$Node rep))"
    , "                                               (elem@@Int i (dom@@Int@@sl$Node rep))))))"
    , "                          (= (apply@@sl$Node@@sl$Node left LH) dummy)"
    , "                          (elem@@sl$Node LH (dom@@sl$Node@@sl$Node left))"
    , "                          (= (apply@@sl$Node@@sl$Node right RH) dummy)"
    , "                          (elem@@sl$Node RH (dom@@sl$Node@@sl$Node right)))"
    , "                     (and (< p q)"
    , "                          (or (and (not (= LH (apply@@Int@@sl$Node rep p)))"
    , "                                   (elem@@Int p (dom@@Int@@sl$Node rep)))"
    , "                              (and (not (= RH (apply@@Int@@sl$Node rep (- q 1))))"
    , "                                   (elem@@Int (- q 1) (dom@@Int@@sl$Node rep)))))"
    , "                     (and (not (= (apply@@sl$Node@@sl$Node left dummy) dummy))"
    , "                          (elem@@sl$Node dummy (dom@@sl$Node@@sl$Node left)))"
    , "                     (and (not (= (apply@@sl$Node@@sl$Node right dummy) dummy))"
    , "                          (elem@@sl$Node dummy (dom@@sl$Node@@sl$Node right)))"
    , "                     (exists ( (i Int) )"
    , "                             (and true"
    , "                                  (and (betweenR p i (- q 1))"
    , "                                       (not (= (apply@@sl$Node@@sl$Node right (apply@@Int@@sl$Node rep i))"
    , "                                               (apply@@Int@@sl$Node rep (+ i 1))))"
    , "                                       (elem@@sl$Node (apply@@Int@@sl$Node rep i)"
    , "                                                      (dom@@sl$Node@@sl$Node right))"
    , "                                       (elem@@Int i (dom@@Int@@sl$Node rep))"
    , "                                       (elem@@Int (+ i 1) (dom@@Int@@sl$Node rep)))))"
    , "                     (exists ( (i Int) )"
    , "                             (and true"
    , "                                  (and (betweenR p i (- q 1))"
    , "                                       (not (= (apply@@sl$Node@@sl$Node left (apply@@Int@@sl$Node rep (+ i 1)))"
    , "                                               (apply@@Int@@sl$Node rep i)))"
    , "                                       (elem@@sl$Node (apply@@Int@@sl$Node rep (+ i 1))"
    , "                                                      (dom@@sl$Node@@sl$Node left))"
    , "                                       (elem@@Int (+ i 1) (dom@@Int@@sl$Node rep))"
    , "                                       (elem@@Int i (dom@@Int@@sl$Node rep)))))"
    , "                     (and (not (= (apply@@sl$Node@@sl$Node left LH) dummy))"
    , "                          (elem@@sl$Node LH (dom@@sl$Node@@sl$Node left)))"
    , "                     (and (not (= (apply@@sl$Node@@sl$Node right RH) dummy))"
    , "                          (elem@@sl$Node RH (dom@@sl$Node@@sl$Node right)))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m5/INV/WD"
    ]

result29 :: String
result29 = unlines
    [ "; m5/handle:pushR/C_SCH/weaken"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(declare-datatypes (a1 a2 a3)"
    , "                   ( (Record-item-left-right (Record-item-left-right (@@field@@_item a1)"
    , "                                                                     (@@field@@_left a2)"
    , "                                                                     (@@field@@_right a3))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "(declare-sort sl$Addr 0)"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$OBJ 0)"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const LH sl$Addr)"
    , "(declare-const LH@prime sl$Addr)"
    , "(declare-const RH sl$Addr)"
    , "(declare-const RH@prime sl$Addr)"
    , "(declare-const dummy sl$Addr)"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const insL (pfun sl$REQ sl$OBJ))"
    , "(declare-const insL@prime (pfun sl$REQ sl$OBJ))"
    , "(declare-const insR (pfun sl$REQ sl$OBJ))"
    , "(declare-const insR@prime (pfun sl$REQ sl$OBJ))"
    , "(declare-const link"
    , "               (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-const link@prime"
    , "               (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl$REQ))"
    , "(declare-const popL@prime (set sl$REQ))"
    , "(declare-const popR (set sl$REQ))"
    , "(declare-const popR@prime (set sl$REQ))"
    , "(declare-const ppd (set sl$REQ))"
    , "(declare-const ppd@prime (set sl$REQ))"
    , "(declare-const pshL (set sl$REQ))"
    , "(declare-const pshL@prime (set sl$REQ))"
    , "(declare-const pshR (set sl$REQ))"
    , "(declare-const pshR@prime (set sl$REQ))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl$OBJ))"
    , "(declare-const qe@prime (pfun Int sl$OBJ))"
    , "(declare-const r sl$REQ)"
    , "(declare-const rep (pfun Int sl$Addr))"
    , "(declare-const rep@prime (pfun Int sl$Addr))"
    , "(declare-const req (set sl$REQ))"
    , "(declare-const res (pfun sl$REQ sl$OBJ))"
    , "(declare-const res@prime (pfun sl$REQ sl$OBJ))"
    , "(declare-const result sl$OBJ)"
    , "(declare-const result@prime sl$OBJ)"
    , "(declare-const v Int)"
    , "(declare-const ver Int)"
    , "(declare-const ver@prime Int)"
    , "(declare-fun apply@@Int@@sl$Addr"
    , "             ( (pfun Int sl$Addr)"
    , "               Int )"
    , "             sl$Addr)"
    , "(declare-fun apply@@Int@@sl$OBJ ( (pfun Int sl$OBJ) Int ) sl$OBJ)"
    , "(declare-fun apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "               sl$Addr )"
    , "             (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "(declare-fun apply@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ)"
    , "               sl$REQ )"
    , "             sl$OBJ)"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$Addr ( (set sl$Addr) ) Int)"
    , "(declare-fun card@@sl$OBJ ( (set sl$OBJ) ) Int)"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$Addr@Close"
    , "             ( (set (pfun Int sl$Addr)) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$OBJ@Close"
    , "             ( (set (pfun Int sl$OBJ)) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "             ( (set (pfun sl$Addr"
    , "                          (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "             ( (set (pfun sl$REQ sl$OBJ)) )"
    , "             Int)"
    , "(declare-fun const@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (Record-item-left-right sl$OBJ sl$Addr sl$Addr) )"
    , "             (Array (Record-item-left-right sl$OBJ sl$Addr sl$Addr)"
    , "                    (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun dom@@Int@@sl$Addr ( (pfun Int sl$Addr) ) (set Int))"
    , "(declare-fun dom@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) (set Int))"
    , "(declare-fun dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (set sl$Addr))"
    , "(declare-fun dom@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom-rest@@Int@@sl$Addr"
    , "             ( (set Int)"
    , "               (pfun Int sl$Addr) )"
    , "             (pfun Int sl$Addr))"
    , "(declare-fun dom-rest@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (pfun Int sl$OBJ) )"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun dom-rest@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (set sl$Addr)"
    , "               (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (pfun sl$Addr"
    , "                   (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$OBJ) )"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun dom-subt@@Int@@sl$Addr"
    , "             ( (set Int)"
    , "               (pfun Int sl$Addr) )"
    , "             (pfun Int sl$Addr))"
    , "(declare-fun dom-subt@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (pfun Int sl$OBJ) )"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun dom-subt@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (set sl$Addr)"
    , "               (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (pfun sl$Addr"
    , "                   (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$OBJ) )"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun empty-fun@@Int@@sl$Addr () (pfun Int sl$Addr))"
    , "(declare-fun empty-fun@@Int@@sl$OBJ () (pfun Int sl$OBJ))"
    , "(declare-fun empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ()"
    , "             (pfun sl$Addr"
    , "                   (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$OBJ () (pfun sl$REQ sl$OBJ))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$Addr ( (set sl$Addr) ) Bool)"
    , "(declare-fun finite@@sl$OBJ ( (set sl$OBJ) ) Bool)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(declare-fun finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$Addr@Close"
    , "             ( (set (pfun Int sl$Addr)) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$OBJ@Close"
    , "             ( (set (pfun Int sl$OBJ)) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "             ( (set (pfun sl$Addr"
    , "                          (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "             ( (set (pfun sl$REQ sl$OBJ)) )"
    , "             Bool)"
    , "(declare-fun ident@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ()"
    , "             (Array (Record-item-left-right sl$OBJ sl$Addr sl$Addr)"
    , "                    (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun injective@@Int@@sl$Addr ( (pfun Int sl$Addr) ) Bool)"
    , "(declare-fun injective@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) Bool)"
    , "(declare-fun injective@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@sl$Addr"
    , "             (Int sl$Addr)"
    , "             (pfun Int sl$Addr))"
    , "(declare-fun mk-fun@@Int@@sl$OBJ"
    , "             (Int sl$OBJ)"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             (sl$Addr (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "             (pfun sl$Addr"
    , "                   (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun mk-fun@@sl$REQ@@sl$OBJ"
    , "             (sl$REQ sl$OBJ)"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$Addr (sl$Addr) (set sl$Addr))"
    , "(declare-fun mk-set@@sl$OBJ (sl$OBJ) (set sl$OBJ))"
    , "(declare-fun mk-set@@sl$REQ (sl$REQ) (set sl$REQ))"
    , "(declare-fun mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (Record-item-left-right sl$OBJ sl$Addr sl$Addr) )"
    , "             (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$Addr@Close"
    , "             ( (pfun Int sl$Addr) )"
    , "             (set (pfun Int sl$Addr)))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$OBJ@Close"
    , "             ( (pfun Int sl$OBJ) )"
    , "             (set (pfun Int sl$OBJ)))"
    , "(declare-fun mk-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "             ( (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (set (pfun sl$Addr"
    , "                        (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "(declare-fun mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             (set (pfun sl$REQ sl$OBJ)))"
    , "(declare-fun ovl@@Int@@sl$Addr"
    , "             ( (pfun Int sl$Addr)"
    , "               (pfun Int sl$Addr) )"
    , "             (pfun Int sl$Addr))"
    , "(declare-fun ovl@@Int@@sl$OBJ"
    , "             ( (pfun Int sl$OBJ)"
    , "               (pfun Int sl$OBJ) )"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "               (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (pfun sl$Addr"
    , "                   (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun ovl@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ)"
    , "               (pfun sl$REQ sl$OBJ) )"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun pfun@@Int@@sl$Addr"
    , "             ( (set Int)"
    , "               (set sl$Addr) )"
    , "             (set (pfun Int sl$Addr)))"
    , "(declare-fun pfun@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun Int sl$OBJ)))"
    , "(declare-fun pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (set sl$Addr)"
    , "               (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (set (pfun sl$Addr"
    , "                        (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "(declare-fun pfun@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun sl$REQ sl$OBJ)))"
    , "(declare-fun ran@@Int@@sl$Addr"
    , "             ( (pfun Int sl$Addr) )"
    , "             (set sl$Addr))"
    , "(declare-fun ran@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) (set sl$OBJ))"
    , "(declare-fun ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun ran@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             (set sl$OBJ))"
    , "(declare-fun set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "               (Array (Record-item-left-right sl$OBJ sl$Addr sl$Addr)"
    , "                      (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun tfun@@Int@@sl$Addr"
    , "             ( (set Int)"
    , "               (set sl$Addr) )"
    , "             (set (pfun Int sl$Addr)))"
    , "(declare-fun tfun@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun Int sl$OBJ)))"
    , "(declare-fun tfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (set sl$Addr)"
    , "               (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (set (pfun sl$Addr"
    , "                        (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "(declare-fun tfun@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun sl$REQ sl$OBJ)))"
    , "(declare-fun @@lambda@@_0"
    , "             ( (set sl$OBJ)"
    , "               (set sl$Addr)"
    , "               (set sl$Addr) )"
    , "             (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(define-fun Req"
    , "            ()"
    , "            (set sl$REQ)"
    , "            (union (union (union pshL pshR) popL) popR))"
    , "(define-fun Req@prime"
    , "            ()"
    , "            (set sl$REQ)"
    , "            (union (union (union pshL@prime pshR@prime) popL@prime)"
    , "                   popR@prime))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$Addr"
    , "            ()"
    , "            (set sl$Addr)"
    , "            ( (as const (set sl$Addr))"
    , "              true ))"
    , "(define-fun all@@sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ)"
    , "            ( (as const (set sl$OBJ))"
    , "              true ))"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun all@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "            ()"
    , "            (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "            ( (as const"
    , "                  (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$Addr@Close"
    , "            ()"
    , "            (set (pfun Int sl$Addr))"
    , "            ( (as const (set (pfun Int sl$Addr)))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun Int sl$OBJ))"
    , "            ( (as const (set (pfun Int sl$OBJ)))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "            ()"
    , "            (set (pfun sl$Addr"
    , "                       (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "            ( (as const"
    , "                  (set (pfun sl$Addr"
    , "                             (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun sl$REQ sl$OBJ))"
    , "            ( (as const (set (pfun sl$REQ sl$OBJ)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$Addr"
    , "            ( (s1 (set sl$Addr)) )"
    , "            (set sl$Addr)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$OBJ"
    , "            ( (s1 (set sl$OBJ)) )"
    , "            (set sl$OBJ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "            ( (s1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "            (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$Addr@Close"
    , "            ( (s1 (set (pfun Int sl$Addr))) )"
    , "            (set (pfun Int sl$Addr))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun Int sl$OBJ))) )"
    , "            (set (pfun Int sl$OBJ))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "            ( (s1 (set (pfun sl$Addr"
    , "                             (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "            (set (pfun sl$Addr"
    , "                       (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$OBJ))) )"
    , "            (set (pfun sl$REQ sl$OBJ))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$Addr"
    , "            ( (x sl$Addr)"
    , "              (s1 (set sl$Addr)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$OBJ"
    , "            ( (x sl$OBJ)"
    , "              (s1 (set sl$OBJ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$REQ"
    , "            ( (x sl$REQ)"
    , "              (s1 (set sl$REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "            ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "              (s1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$Addr@Close"
    , "            ( (x (pfun Int sl$Addr))"
    , "              (s1 (set (pfun Int sl$Addr))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ( (x (pfun Int sl$OBJ))"
    , "              (s1 (set (pfun Int sl$OBJ))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "            ( (x (pfun sl$Addr"
    , "                       (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "              (s1 (set (pfun sl$Addr"
    , "                             (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ( (x (pfun sl$REQ sl$OBJ))"
    , "              (s1 (set (pfun sl$REQ sl$OBJ))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$Addr"
    , "            ()"
    , "            (set sl$Addr)"
    , "            ( (as const (set sl$Addr))"
    , "              false ))"
    , "(define-fun empty-set@@sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ)"
    , "            ( (as const (set sl$OBJ))"
    , "              false ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "            ()"
    , "            (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "            ( (as const"
    , "                  (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$Addr@Close"
    , "            ()"
    , "            (set (pfun Int sl$Addr))"
    , "            ( (as const (set (pfun Int sl$Addr)))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun Int sl$OBJ))"
    , "            ( (as const (set (pfun Int sl$OBJ)))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "            ()"
    , "            (set (pfun sl$Addr"
    , "                       (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "            ( (as const"
    , "                  (set (pfun sl$Addr"
    , "                             (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun sl$REQ sl$OBJ))"
    , "            ( (as const (set (pfun sl$REQ sl$OBJ)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$Addr"
    , "            ( (s1 (set sl$Addr))"
    , "              (s2 (set sl$Addr)) )"
    , "            (set sl$Addr)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$OBJ"
    , "            ( (s1 (set sl$OBJ))"
    , "              (s2 (set sl$OBJ)) )"
    , "            (set sl$OBJ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "            ( (s1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "              (s2 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "            (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$Addr@Close"
    , "            ( (s1 (set (pfun Int sl$Addr)))"
    , "              (s2 (set (pfun Int sl$Addr))) )"
    , "            (set (pfun Int sl$Addr))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun Int sl$OBJ)))"
    , "              (s2 (set (pfun Int sl$OBJ))) )"
    , "            (set (pfun Int sl$OBJ))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "            ( (s1 (set (pfun sl$Addr"
    , "                             (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "              (s2 (set (pfun sl$Addr"
    , "                             (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "            (set (pfun sl$Addr"
    , "                       (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "              (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "            (set (pfun sl$REQ sl$OBJ))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$Addr"
    , "            ( (s1 (set sl$Addr))"
    , "              (s2 (set sl$Addr)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$OBJ"
    , "            ( (s1 (set sl$OBJ))"
    , "              (s2 (set sl$OBJ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "            ( (s1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "              (s2 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$Addr@Close"
    , "            ( (s1 (set (pfun Int sl$Addr)))"
    , "              (s2 (set (pfun Int sl$Addr))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun Int sl$OBJ)))"
    , "              (s2 (set (pfun Int sl$OBJ))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "            ( (s1 (set (pfun sl$Addr"
    , "                             (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "              (s2 (set (pfun sl$Addr"
    , "                             (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "              (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Addr"
    , "            ()"
    , "            (set sl$Addr)"
    , "            ( (as const (set sl$Addr))"
    , "              true ))"
    , "(define-fun sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ)"
    , "            ( (as const (set sl$OBJ))"
    , "              true ))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun Node@prime"
    , "            ()"
    , "            (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "            (set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (@@lambda@@_0 sl$OBJ sl$Addr sl$Addr)"
    , "                                                                                                                                           ident@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close))"
    , "(define-fun Node"
    , "            ()"
    , "            (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "            (set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (@@lambda@@_0 sl$OBJ sl$Addr sl$Addr)"
    , "                                                                                                                                           ident@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (=> (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r)"
    , "                       (<= 0"
    , "                           (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0"
    , "                         (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$Addr))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$Addr@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$Addr@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$Addr@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$OBJ@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$OBJ@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$OBJ@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun sl$Addr"
    , "                                (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r)"
    , "                       (<= 0"
    , "                           (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0"
    , "                         (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)) ))))"
    , "(assert (forall ( (r (set sl$Addr)) )"
    , "                (! (=> (finite@@sl$Addr r) (<= 0 (card@@sl$Addr r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Addr r)) ))))"
    , "(assert (forall ( (r (set sl$OBJ)) )"
    , "                (! (=> (finite@@sl$OBJ r) (<= 0 (card@@sl$OBJ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$OBJ r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (= (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r)"
    , "                         0)"
    , "                      (= r"
    , "                         empty-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$Addr))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$Addr@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$Addr@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$Addr@Close r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$OBJ@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$OBJ@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$Addr"
    , "                                (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r)"
    , "                         0)"
    , "                      (= r"
    , "                         empty-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set sl$Addr)) )"
    , "                (! (= (= (card@@sl$Addr r) 0) (= r empty-set@@sl$Addr))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr r) ))))"
    , "(assert (forall ( (r (set sl$OBJ)) )"
    , "                (! (= (= (card@@sl$OBJ r) 0) (= r empty-set@@sl$OBJ))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$Addr)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$Addr@Close (mk-set@Open@@pfun@@Int@@sl$Addr@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$Addr@Close (mk-set@Open@@pfun@@Int@@sl$Addr@Close x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$OBJ)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$Addr"
    , "                           (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (mk-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (mk-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x sl$Addr) )"
    , "                (! (= (card@@sl$Addr (mk-set@@sl$Addr x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr (mk-set@@sl$Addr x)) ))))"
    , "(assert (forall ( (x sl$OBJ) )"
    , "                (! (= (card@@sl$OBJ (mk-set@@sl$OBJ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ (mk-set@@sl$OBJ x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (= (card@@sl$REQ (mk-set@@sl$REQ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (= (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r)"
    , "                         1)"
    , "                      (exists ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                              (and true"
    , "                                   (= r"
    , "                                      (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$Addr))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$Addr@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$Addr)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@Int@@sl$Addr@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$Addr@Close r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$OBJ@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$OBJ)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$Addr"
    , "                                (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r)"
    , "                         1)"
    , "                      (exists ( (x (pfun sl$Addr"
    , "                                         (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                              (and true"
    , "                                   (= r"
    , "                                      (mk-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) 1)"
    , "                      (exists ( (x (pfun sl$REQ sl$OBJ)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set sl$Addr)) )"
    , "                (! (= (= (card@@sl$Addr r) 1)"
    , "                      (exists ( (x sl$Addr) )"
    , "                              (and true (= r (mk-set@@sl$Addr x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr r) ))))"
    , "(assert (forall ( (r (set sl$OBJ)) )"
    , "                (! (= (= (card@@sl$OBJ r) 1)"
    , "                      (exists ( (x sl$OBJ) ) (and true (= r (mk-set@@sl$OBJ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 1)"
    , "                      (exists ( (x sl$REQ) ) (and true (= r (mk-set@@sl$REQ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (r0 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close)"
    , "                       (= (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (union r r0))"
    , "                          (+ (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r)"
    , "                             (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$Addr)))"
    , "                  (r0 (set (pfun Int sl$Addr))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$Addr@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$Addr@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$Addr@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$Addr@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$Addr@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$OBJ)))"
    , "                  (r0 (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$OBJ@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$OBJ@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$OBJ@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$OBJ@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun sl$Addr"
    , "                                (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "                  (r0 (set (pfun sl$Addr"
    , "                                 (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close)"
    , "                       (= (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r)"
    , "                             (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$OBJ)))"
    , "                  (r0 (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close)"
    , "                       (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)"
    , "                             (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Addr))"
    , "                  (r0 (set sl$Addr)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Addr)"
    , "                       (= (card@@sl$Addr (union r r0))"
    , "                          (+ (card@@sl$Addr r) (card@@sl$Addr r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$OBJ))"
    , "                  (r0 (set sl$OBJ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$OBJ)"
    , "                       (= (card@@sl$OBJ (union r r0))"
    , "                          (+ (card@@sl$OBJ r) (card@@sl$OBJ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (forall ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (select (const@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x)"
    , "                              y)"
    , "                      x)"
    , "                   :pattern"
    , "                   ( (select (const@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x)"
    , "                             y) ))))"
    , "(assert (forall ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (select ident@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "                              x)"
    , "                      x)"
    , "                   :pattern"
    , "                   ( (select ident@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "                             x) ))))"
    , "(assert (= (dom@@Int@@sl$Addr empty-fun@@Int@@sl$Addr)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close)"
    , "           empty-set@@sl$Addr))"
    , "(assert (= (dom@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ)"
    , "           empty-set@@sl$REQ))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr)) )"
    , "                (! (= (ovl@@Int@@sl$Addr f1 empty-fun@@Int@@sl$Addr) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$Addr f1 empty-fun@@Int@@sl$Addr) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ)) )"
    , "                (! (= (ovl@@Int@@sl$OBJ f1 empty-fun@@Int@@sl$OBJ) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$OBJ f1 empty-fun@@Int@@sl$OBJ) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                 empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$OBJ f1 empty-fun@@sl$REQ@@sl$OBJ)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$OBJ f1 empty-fun@@sl$REQ@@sl$OBJ) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr)) )"
    , "                (! (= (ovl@@Int@@sl$Addr empty-fun@@Int@@sl$Addr f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$Addr empty-fun@@Int@@sl$Addr f1) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ)) )"
    , "                (! (= (ovl@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "                                                                                                 f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "                                                                                                f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ f1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (= (dom@@Int@@sl$Addr (mk-fun@@Int@@sl$Addr x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Addr (mk-fun@@Int@@sl$Addr x y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (dom@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y))"
    , "                      (mk-set@@sl$Addr x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                      (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (f2 (pfun Int sl$Addr))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$Addr f2))"
    , "                       (= (apply@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 f2) x)"
    , "                          (apply@@Int@@sl$Addr f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (f2 (pfun Int sl$OBJ))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$OBJ f2))"
    , "                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x)"
    , "                          (apply@@Int@@sl$OBJ f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (f2 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr) )"
    , "                (! (=> (elem@@sl$Addr x"
    , "                                      (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f2))"
    , "                       (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 f2)"
    , "                                                                                                       x)"
    , "                          (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 f2)"
    , "                                                                                                  x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (f2 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f2))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$OBJ f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (f2 (pfun Int sl$Addr))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl$Addr f2))))"
    , "                       (= (apply@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 f2) x)"
    , "                          (apply@@Int@@sl$Addr f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (f2 (pfun Int sl$OBJ))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl$OBJ f2))))"
    , "                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x)"
    , "                          (apply@@Int@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (f2 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr) )"
    , "                (! (=> (and (elem@@sl$Addr x"
    , "                                           (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                            (not (elem@@sl$Addr x"
    , "                                                (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f2))))"
    , "                       (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 f2)"
    , "                                                                                                       x)"
    , "                          (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 f2)"
    , "                                                                                                  x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (f2 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                            (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f2))))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (= (apply@@Int@@sl$Addr (mk-fun@@Int@@sl$Addr x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Addr (mk-fun@@Int@@sl$Addr x y) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y) x) ))))"
    , "(assert (forall ( (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y)"
    , "                                                                                                   x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y)"
    , "                                                                                                  x) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl$Addr f1)))"
    , "                       (= (apply@@Int@@sl$Addr (dom-rest@@Int@@sl$Addr s1 f1) x)"
    , "                          (apply@@Int@@sl$Addr f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Addr (dom-rest@@Int@@sl$Addr s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl$OBJ f1)))"
    , "                       (= (apply@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1) x)"
    , "                          (apply@@Int@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s1 (set sl$Addr))"
    , "                  (x sl$Addr) )"
    , "                (! (=> (and (elem@@sl$Addr x s1)"
    , "                            (elem@@sl$Addr x"
    , "                                           (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)))"
    , "                       (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-rest@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1)"
    , "                                                                                                       x)"
    , "                          (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-rest@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1)"
    , "                                                                                                  x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x s1)"
    , "                            (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$Addr f1) s1))"
    , "                       (= (apply@@Int@@sl$Addr (dom-subt@@Int@@sl$Addr s1 f1) x)"
    , "                          (apply@@Int@@sl$Addr f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Addr (dom-subt@@Int@@sl$Addr s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))"
    , "                       (= (apply@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1) x)"
    , "                          (apply@@Int@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s1 (set sl$Addr))"
    , "                  (x sl$Addr) )"
    , "                (! (=> (elem@@sl$Addr x"
    , "                                      (set-diff@@sl$Addr (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                                         s1))"
    , "                       (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-subt@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1)"
    , "                                                                                                       x)"
    , "                          (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-subt@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1)"
    , "                                                                                                  x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (s2 (set sl$Addr)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$Addr@Close empty-fun@@Int@@sl$Addr"
    , "                                                        (tfun@@Int@@sl$Addr empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$Addr@Close empty-fun@@Int@@sl$Addr"
    , "                                                          (tfun@@Int@@sl$Addr empty-set@@Int s2)) ))))"
    , "(assert (forall ( (s2 (set sl$OBJ)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$OBJ@Close empty-fun@@Int@@sl$OBJ"
    , "                                                       (tfun@@Int@@sl$OBJ empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close empty-fun@@Int@@sl$OBJ"
    , "                                                         (tfun@@Int@@sl$OBJ empty-set@@Int s2)) ))))"
    , "(assert (forall ( (s2 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "                                                                                                                (tfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close empty-set@@sl$Addr s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "                                                                                                                  (tfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close empty-set@@sl$Addr s2)) ))))"
    , "(assert (forall ( (s2 (set sl$OBJ)) )"
    , "                (! (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close empty-fun@@sl$REQ@@sl$OBJ"
    , "                                                          (tfun@@sl$REQ@@sl$OBJ empty-set@@sl$REQ s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close empty-fun@@sl$REQ@@sl$OBJ"
    , "                                                            (tfun@@sl$REQ@@sl$OBJ empty-set@@sl$REQ s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (f2 (pfun Int sl$Addr)) )"
    , "                (! (= (dom@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 f2))"
    , "                      (union (dom@@Int@@sl$Addr f1) (dom@@Int@@sl$Addr f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (f2 (pfun Int sl$OBJ)) )"
    , "                (! (= (dom@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2))"
    , "                      (union (dom@@Int@@sl$OBJ f1) (dom@@Int@@sl$OBJ f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (f2 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 f2))"
    , "                      (union (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                             (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (f2 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$OBJ f1) (dom@@sl$REQ@@sl$OBJ f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$Addr (dom-rest@@Int@@sl$Addr s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$Addr f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Addr (dom-rest@@Int@@sl$Addr s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s1 (set sl$Addr)) )"
    , "                (! (= (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-rest@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1))"
    , "                      (intersect s1"
    , "                                 (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-rest@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$Addr (dom-subt@@Int@@sl$Addr s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$Addr f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Addr (dom-subt@@Int@@sl$Addr s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s1 (set sl$Addr)) )"
    , "                (! (= (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-subt@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1))"
    , "                      (set-diff@@sl$Addr (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                         s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-subt@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                           (= (apply@@Int@@sl$Addr f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                     (apply@@Int@@sl$Addr f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                           (= (apply@@Int@@sl$Addr f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                     (apply@@Int@@sl$Addr f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                           (= (apply@@Int@@sl$Addr f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                     (apply@@Int@@sl$Addr f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                           (= (apply@@Int@@sl$Addr f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                     (apply@@Int@@sl$Addr f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (and (elem@@sl$Addr x"
    , "                                          (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                           (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                              y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr x"
    , "                                    (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                     (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (and (elem@@sl$Addr x"
    , "                                          (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                           (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                              y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr x"
    , "                                    (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                     (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (and (elem@@sl$Addr x"
    , "                                          (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                           (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                              y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr x"
    , "                                    (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                     (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (and (elem@@sl$Addr x"
    , "                                          (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                           (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                              y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr x"
    , "                                    (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                     (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl$Addr) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 (mk-fun@@Int@@sl$Addr x y))"
    , "                                               x2)"
    , "                          (apply@@Int@@sl$Addr f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 (mk-fun@@Int@@sl$Addr x y))"
    , "                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))"
    , "                                              x2)"
    , "                          (apply@@Int@@sl$OBJ f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))"
    , "                                         x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr)"
    , "                  (x2 sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                                                                                                  (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y))"
    , "                                                                                                       x2)"
    , "                          (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                                                                                             (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y))"
    , "                                                                                                  x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (x2 sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                                                 x2)"
    , "                          (apply@@sl$REQ@@sl$OBJ f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                                            x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (= (apply@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 (mk-fun@@Int@@sl$Addr x y))"
    , "                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 (mk-fun@@Int@@sl$Addr x y))"
    , "                                          x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                                                                                              (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y))"
    , "                                                                                                   x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                                                                                             (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y))"
    , "                                                                                                  x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                                             x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                                            x) ))))"
    , "(assert (= (ran@@Int@@sl$Addr empty-fun@@Int@@sl$Addr)"
    , "           empty-set@@sl$Addr))"
    , "(assert (= (ran@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ)"
    , "           empty-set@@sl$OBJ))"
    , "(assert (= (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close)"
    , "           empty-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close))"
    , "(assert (= (ran@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ)"
    , "           empty-set@@sl$OBJ))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (y sl$Addr) )"
    , "                (! (= (elem@@sl$Addr y (ran@@Int@@sl$Addr f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                                        (= (apply@@Int@@sl$Addr f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr y (ran@@Int@@sl$Addr f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ y (ran@@Int@@sl$OBJ f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                                        (= (apply@@Int@@sl$OBJ f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ y (ran@@Int@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y"
    , "                                                                                         (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                      (exists ( (x sl$Addr) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$Addr x"
    , "                                                       (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                                        (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                                           y)))))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y"
    , "                                                                                        (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ y (ran@@sl$REQ@@sl$OBJ f1))"
    , "                      (exists ( (x sl$REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                                        (= (apply@@sl$REQ@@sl$OBJ f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ y (ran@@sl$REQ@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (= (ran@@Int@@sl$Addr (mk-fun@@Int@@sl$Addr x y))"
    , "                      (mk-set@@sl$Addr y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$Addr (mk-fun@@Int@@sl$Addr x y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (ran@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y))"
    , "                      (mk-set@@sl$OBJ y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y))"
    , "                      (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (ran@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                      (mk-set@@sl$OBJ y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$Addr)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$Addr@Close f1 (tfun@@Int@@sl$Addr s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$Addr f1))"
    , "                           (subset (ran@@Int@@sl$Addr f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$Addr@Close f1 (tfun@@Int@@sl$Addr s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (tfun@@Int@@sl$OBJ s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$OBJ f1))"
    , "                           (subset (ran@@Int@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (tfun@@Int@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s1 (set sl$Addr))"
    , "                  (s2 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close f1"
    , "                                                                                                                   (tfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 s2))"
    , "                      (and (= s1"
    , "                              (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                           (subset (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                   s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close f1"
    , "                                                                                                                  (tfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (tfun@@sl$REQ@@sl$OBJ s1 s2))"
    , "                      (and (= s1 (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (subset (ran@@sl$REQ@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (tfun@@sl$REQ@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$Addr)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$Addr@Close f1 (pfun@@Int@@sl$Addr s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$Addr f1) s1)"
    , "                           (subset (ran@@Int@@sl$Addr f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$Addr@Close f1 (pfun@@Int@@sl$Addr s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (pfun@@Int@@sl$OBJ s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$OBJ f1) s1)"
    , "                           (subset (ran@@Int@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (pfun@@Int@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s1 (set sl$Addr))"
    , "                  (s2 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close f1"
    , "                                                                                                                   (pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 s2))"
    , "                      (and (subset (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                   s1)"
    , "                           (subset (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                   s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close f1"
    , "                                                                                                                  (pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (pfun@@sl$REQ@@sl$OBJ s1 s2))"
    , "                      (and (subset (dom@@sl$REQ@@sl$OBJ f1) s1)"
    , "                           (subset (ran@@sl$REQ@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (pfun@@sl$REQ@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr)) )"
    , "                (! (= (injective@@Int@@sl$Addr f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl$Addr f1)))"
    , "                                  (=> (= (apply@@Int@@sl$Addr f1 x)"
    , "                                         (apply@@Int@@sl$Addr f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl$Addr f1) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ)) )"
    , "                (! (= (injective@@Int@@sl$OBJ f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl$OBJ f1)))"
    , "                                  (=> (= (apply@@Int@@sl$OBJ f1 x)"
    , "                                         (apply@@Int@@sl$OBJ f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl$OBJ f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (injective@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                      (forall ( (x sl$Addr)"
    , "                                (x2 sl$Addr) )"
    , "                              (=> (and (elem@@sl$Addr x"
    , "                                                      (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                                       (elem@@sl$Addr x2"
    , "                                                      (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)))"
    , "                                  (=> (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                                         (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (injective@@sl$REQ@@sl$OBJ f1)"
    , "                      (forall ( (x sl$REQ)"
    , "                                (x2 sl$REQ) )"
    , "                              (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                                       (elem@@sl$REQ x2 (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                                  (=> (= (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                         (apply@@sl$REQ@@sl$OBJ f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$REQ@@sl$OBJ f1) ))))"
    , "(assert (injective@@Int@@sl$Addr empty-fun@@Int@@sl$Addr))"
    , "(assert (injective@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ))"
    , "(assert (injective@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close))"
    , "(assert (injective@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                       (elem@@sl$Addr (apply@@Int@@sl$Addr f1 x) (ran@@Int@@sl$Addr f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr (apply@@Int@@sl$Addr f1 x) (ran@@Int@@sl$Addr f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x) (ran@@Int@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x) (ran@@Int@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr) )"
    , "                (! (=> (elem@@sl$Addr x"
    , "                                      (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                       (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                                                                                          (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                                                                                        (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                       (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$REQ@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$REQ@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$Addr f1) s1))"
    , "                       (elem@@sl$Addr (apply@@Int@@sl$Addr f1 x)"
    , "                                      (ran@@Int@@sl$Addr (dom-subt@@Int@@sl$Addr s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr (apply@@Int@@sl$Addr f1 x)"
    , "                                    (ran@@Int@@sl$Addr (dom-subt@@Int@@sl$Addr s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                     (ran@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                   (ran@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s1 (set sl$Addr))"
    , "                  (x sl$Addr) )"
    , "                (! (=> (elem@@sl$Addr x"
    , "                                      (set-diff@@sl$Addr (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                                         s1))"
    , "                       (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                                                                                          (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-subt@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                                                                                        (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-subt@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$Addr f1) s1))"
    , "                       (elem@@sl$Addr (apply@@Int@@sl$Addr f1 x)"
    , "                                      (ran@@Int@@sl$Addr (dom-rest@@Int@@sl$Addr s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr (apply@@Int@@sl$Addr f1 x)"
    , "                                    (ran@@Int@@sl$Addr (dom-rest@@Int@@sl$Addr s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                     (ran@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                   (ran@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s1 (set sl$Addr))"
    , "                  (x sl$Addr) )"
    , "                (! (=> (elem@@sl$Addr x"
    , "                                      (intersect (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                                 s1))"
    , "                       (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                                                                                          (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-rest@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                                                                                        (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-rest@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (intersect (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                            (injective@@Int@@sl$Addr f1))"
    , "                       (= (ran@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 (mk-fun@@Int@@sl$Addr x y)))"
    , "                          (union (set-diff@@sl$Addr (ran@@Int@@sl$Addr f1)"
    , "                                                    (mk-set@@sl$Addr (apply@@Int@@sl$Addr f1 x)))"
    , "                                 (mk-set@@sl$Addr y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 (mk-fun@@Int@@sl$Addr x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                            (injective@@Int@@sl$OBJ f1))"
    , "                       (= (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)))"
    , "                          (union (set-diff@@sl$OBJ (ran@@Int@@sl$OBJ f1)"
    , "                                                   (mk-set@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)))"
    , "                                 (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (=> (and (elem@@sl$Addr x"
    , "                                           (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                            (injective@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                       (= (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                                                                                                (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y)))"
    , "                          (union (set-diff@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                                                                                        (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)))"
    , "                                 (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                                                                                           (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                            (injective@@sl$REQ@@sl$OBJ f1))"
    , "                       (= (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y)))"
    , "                          (union (set-diff@@sl$OBJ (ran@@sl$REQ@@sl$OBJ f1)"
    , "                                                   (mk-set@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)))"
    , "                                 (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl$Addr f1)))"
    , "                       (= (ran@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 (mk-fun@@Int@@sl$Addr x y)))"
    , "                          (union (ran@@Int@@sl$Addr f1) (mk-set@@sl$Addr y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 (mk-fun@@Int@@sl$Addr x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl$OBJ f1)))"
    , "                       (= (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)))"
    , "                          (union (ran@@Int@@sl$OBJ f1) (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (=> (not (elem@@sl$Addr x"
    , "                                           (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)))"
    , "                       (= (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                                                                                                (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y)))"
    , "                          (union (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                 (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                                                                                           (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                       (= (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y)))"
    , "                          (union (ran@@sl$REQ@@sl$OBJ f1) (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x"
    , "                                                                                         (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x"
    , "                                                                                        (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$Addr))"
    , "                  (y (pfun Int sl$Addr)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$Addr@Close x (mk-set@Open@@pfun@@Int@@sl$Addr@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$Addr@Close x (mk-set@Open@@pfun@@Int@@sl$Addr@Close y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$OBJ))"
    , "                  (y (pfun Int sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$OBJ@Close x (mk-set@Open@@pfun@@Int@@sl$OBJ@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close x (mk-set@Open@@pfun@@Int@@sl$OBJ@Close y)) ))))"
    , "(assert (forall ( (x (pfun sl$Addr"
    , "                           (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (y (pfun sl$Addr"
    , "                           (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close x"
    , "                                                                                                                   (mk-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close x"
    , "                                                                                                                  (mk-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close y)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$OBJ))"
    , "                  (y (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close x (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close x (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close y)) ))))"
    , "(assert (forall ( (x sl$Addr)"
    , "                  (y sl$Addr) )"
    , "                (! (= (elem@@sl$Addr x (mk-set@@sl$Addr y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr x (mk-set@@sl$Addr y)) ))))"
    , "(assert (forall ( (x sl$OBJ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ x (mk-set@@sl$OBJ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ x (mk-set@@sl$OBJ y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$REQ) )"
    , "                (! (= (elem@@sl$REQ x (mk-set@@sl$REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (mk-set@@sl$REQ y)) ))))"
    , "(assert (forall ( (r1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (term (Array (Record-item-left-right sl$OBJ sl$Addr sl$Addr)"
    , "                               (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y"
    , "                                                                                         (set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r1 term))"
    , "                      (exists ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                              (and (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x r1)"
    , "                                   (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y"
    , "                                                                                        (set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r1 term)) ))))"
    , "(assert (forall ( (r1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (term (Array (Record-item-left-right sl$OBJ sl$Addr sl$Addr)"
    , "                               (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (= (set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r1 term)"
    , "                         (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y))"
    , "                      (forall ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                              (=> (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x r1)"
    , "                                  (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r1 term)"
    , "                     (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s2 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (=> (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1)"
    , "                       (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (set-diff@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (set-diff@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$Addr)))"
    , "                  (s2 (set (pfun Int sl$Addr))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$Addr@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$Addr@Close (set-diff@Open@@pfun@@Int@@sl$Addr@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$Addr@Close (set-diff@Open@@pfun@@Int@@sl$Addr@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$OBJ)))"
    , "                  (s2 (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$OBJ@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Addr"
    , "                                 (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "                  (s2 (set (pfun sl$Addr"
    , "                                 (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s1)"
    , "                       (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (set-diff@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (set-diff@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "                  (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1)"
    , "                       (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr))"
    , "                  (s2 (set sl$Addr)) )"
    , "                (! (=> (finite@@sl$Addr s1)"
    , "                       (finite@@sl$Addr (set-diff@@sl$Addr s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr (set-diff@@sl$Addr s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (=> (finite@@sl$OBJ s1)"
    , "                       (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s2 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (=> (and (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1)"
    , "                            (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s2))"
    , "                       (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$Addr)))"
    , "                  (s2 (set (pfun Int sl$Addr))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$Addr@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$Addr@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$Addr@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$Addr@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$OBJ)))"
    , "                  (s2 (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$OBJ@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$OBJ@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$OBJ@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Addr"
    , "                                 (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "                  (s2 (set (pfun sl$Addr"
    , "                                 (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s1)"
    , "                            (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s2))"
    , "                       (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "                  (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1)"
    , "                            (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s2))"
    , "                       (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr))"
    , "                  (s2 (set sl$Addr)) )"
    , "                (! (=> (and (finite@@sl$Addr s1) (finite@@sl$Addr s2))"
    , "                       (finite@@sl$Addr (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (=> (and (finite@@sl$OBJ s1) (finite@@sl$OBJ s2))"
    , "                       (finite@@sl$OBJ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))"
    , "                       (not (finite@@Int (set-diff@@Int s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s2 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (=> (and (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s2)"
    , "                            (not (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1)))"
    , "                       (not (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (set-diff@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (set-diff@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$Addr)))"
    , "                  (s2 (set (pfun Int sl$Addr))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$Addr@Close s2)"
    , "                            (not (finite@Open@@pfun@@Int@@sl$Addr@Close s1)))"
    , "                       (not (finite@Open@@pfun@@Int@@sl$Addr@Close (set-diff@Open@@pfun@@Int@@sl$Addr@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$Addr@Close (set-diff@Open@@pfun@@Int@@sl$Addr@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$OBJ)))"
    , "                  (s2 (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$OBJ@Close s2)"
    , "                            (not (finite@Open@@pfun@@Int@@sl$OBJ@Close s1)))"
    , "                       (not (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Addr"
    , "                                 (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "                  (s2 (set (pfun sl$Addr"
    , "                                 (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s2)"
    , "                            (not (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s1)))"
    , "                       (not (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (set-diff@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (set-diff@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "                  (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s2)"
    , "                            (not (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1)))"
    , "                       (not (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr))"
    , "                  (s2 (set sl$Addr)) )"
    , "                (! (=> (and (finite@@sl$Addr s2) (not (finite@@sl$Addr s1)))"
    , "                       (not (finite@@sl$Addr (set-diff@@sl$Addr s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr (set-diff@@sl$Addr s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (=> (and (finite@@sl$OBJ s2) (not (finite@@sl$OBJ s1)))"
    , "                       (not (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s2) (not (finite@@sl$REQ s1)))"
    , "                       (not (finite@@sl$REQ (set-diff@@sl$REQ s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$Addr)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$Addr@Close (mk-set@Open@@pfun@@Int@@sl$Addr@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$Addr@Close (mk-set@Open@@pfun@@Int@@sl$Addr@Close x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$OBJ)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$Addr"
    , "                           (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (mk-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (mk-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$OBJ)) )"
    , "                (! (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x sl$Addr) )"
    , "                (! (finite@@sl$Addr (mk-set@@sl$Addr x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr (mk-set@@sl$Addr x)) ))))"
    , "(assert (forall ( (x sl$OBJ) )"
    , "                (! (finite@@sl$OBJ (mk-set@@sl$OBJ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (mk-set@@sl$OBJ x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (finite@@sl$REQ (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close empty-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close))"
    , "(assert (finite@Open@@pfun@@Int@@sl$Addr@Close empty-set@Open@@pfun@@Int@@sl$Addr@Close))"
    , "(assert (finite@Open@@pfun@@Int@@sl$OBJ@Close empty-set@Open@@pfun@@Int@@sl$OBJ@Close))"
    , "(assert (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close empty-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close))"
    , "(assert (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close))"
    , "(assert (finite@@sl$Addr empty-set@@sl$Addr))"
    , "(assert (finite@@sl$OBJ empty-set@@sl$OBJ))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (r1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r1"
    , "                                                                                                                                                     ident@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close)"
    , "                      r1)"
    , "                   :pattern"
    , "                   ( (set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r1"
    , "                                                                                                                                                    ident@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (forall ( (@@fv@@_0 (set sl$OBJ))"
    , "                  (@@fv@@_1 (set sl$Addr))"
    , "                  (@@fv@@_2 (set sl$Addr))"
    , "                  (@@bv@@_0 (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close @@bv@@_0"
    , "                                                                                         (@@lambda@@_0 @@fv@@_0 @@fv@@_1 @@fv@@_2))"
    , "                      (and (elem@@sl$OBJ (@@field@@_item @@bv@@_0) @@fv@@_0)"
    , "                           (elem@@sl$Addr (@@field@@_left @@bv@@_0) @@fv@@_1)"
    , "                           (elem@@sl$Addr (@@field@@_right @@bv@@_0) @@fv@@_2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close @@bv@@_0"
    , "                                                                                        (@@lambda@@_0 @@fv@@_0 @@fv@@_1 @@fv@@_2)) ))))"
    , "; m1:sch1"
    , "(assert (= v ver))"
    , "; m2:inv0"
    , "(assert (= Req req))"
    , "; m2:inv1"
    , "(assert (= (intersect pshL pshR) empty-set@@sl$REQ))"
    , "; m2:inv2"
    , "(assert (= (intersect pshL popL) empty-set@@sl$REQ))"
    , "; m2:inv3"
    , "(assert (= (intersect pshL popR) empty-set@@sl$REQ))"
    , "; m2:inv4"
    , "(assert (= (intersect pshR popL) empty-set@@sl$REQ))"
    , "; m2:inv5"
    , "(assert (= (intersect pshR popR) empty-set@@sl$REQ))"
    , "; m2:inv6"
    , "(assert (= (intersect popL popR) empty-set@@sl$REQ))"
    , "; m2:sch0"
    , "(assert (elem@@sl$REQ r pshR))"
    , "; m3:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$OBJ@Close qe (tfun@@Int@@sl$OBJ (intervalR p q) sl$OBJ)))"
    , "; m3:inv1"
    , "(assert (<= p q))"
    , "; m3:inv2"
    , "(assert (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close insL (tfun@@sl$REQ@@sl$OBJ pshL sl$OBJ)))"
    , "; m3:inv3"
    , "(assert (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close insR (tfun@@sl$REQ@@sl$OBJ pshR sl$OBJ)))"
    , "; m3:inv4"
    , "(assert (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close res (pfun@@sl$REQ@@sl$OBJ ppd sl$OBJ)))"
    , "; m4:asm0"
    , "(assert (not (finite@@sl$Addr sl$Addr)))"
    , "; m4:inv0"
    , "(assert (injective@@Int@@sl$Addr rep))"
    , "; m4:inv1"
    , "(assert (elem@Open@@pfun@@Int@@sl$Addr@Close rep (tfun@@Int@@sl$Addr (intervalR p q) sl$Addr)))"
    , "; m4:inv2"
    , "(assert (not (elem@@sl$Addr dummy (ran@@Int@@sl$Addr rep))))"
    , "; m4:inv8"
    , "(assert (finite@@sl$Addr (ran@@Int@@sl$Addr rep)))"
    , "; m5:inv1"
    , "(assert (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close link"
    , "                                                                                                     (tfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ran@@Int@@sl$Addr rep) Node)))"
    , "; m5:inv11"
    , "(assert (forall ( (i Int) )"
    , "                (! (=> (betweenR p i (- q 1))"
    , "                       (= (@@field@@_right (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close link (apply@@Int@@sl$Addr rep i)))"
    , "                          (apply@@Int@@sl$Addr rep (+ i 1))))"
    , "                   :pattern"
    , "                   ( (@@field@@_right (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close link (apply@@Int@@sl$Addr rep i))) ))))"
    , "; m5:inv12"
    , "(assert (forall ( (i Int) )"
    , "                (! (=> (betweenR p i (- q 1))"
    , "                       (= (@@field@@_left (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close link (apply@@Int@@sl$Addr rep (+ i 1))))"
    , "                          (apply@@Int@@sl$Addr rep i)))"
    , "                   :pattern"
    , "                   ( (@@field@@_left (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close link (apply@@Int@@sl$Addr rep (+ i 1)))) ))))"
    , "; m5:inv13"
    , "(assert (=> (< p q) (= LH (apply@@Int@@sl$Addr rep p))))"
    , "; m5:inv14"
    , "(assert (=> (< p q) (= RH (apply@@Int@@sl$Addr rep (- q 1)))))"
    , "; m5:inv15"
    , "(assert (=> (= p q) (= LH dummy)))"
    , "; m5:inv16"
    , "(assert (=> (= p q) (= RH dummy)))"
    , "; m5:inv2"
    , "(assert (forall ( (i Int) )"
    , "                (! (=> (betweenR p i q)"
    , "                       (= (apply@@Int@@sl$OBJ qe i)"
    , "                          (@@field@@_item (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close link (apply@@Int@@sl$Addr rep i)))))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ qe i) ))))"
    , "; m5:inv4"
    , "(assert (= (= p q) (= LH dummy)))"
    , "; m5:inv5"
    , "(assert (= (= p q) (= RH dummy)))"
    , "; m5:inv7"
    , "(assert (finite@@sl$Addr (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close link)))"
    , "(assert (not (or (not (= RH dummy)) (= RH dummy))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m5/handle:pushR/C_SCH/weaken"
    ]

result30 :: String
result30 = unlines
    [ "; m5/handle:pushR/C_SCH/weaken/saf/add:popL/SAF/handle:pushR:empty"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(declare-datatypes (a1 a2 a3)"
    , "                   ( (Record-item-left-right (Record-item-left-right (@@field@@_item a1)"
    , "                                                                     (@@field@@_left a2)"
    , "                                                                     (@@field@@_right a3))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "(declare-sort sl$Addr 0)"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$OBJ 0)"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const LH sl$Addr)"
    , "(declare-const LH@prime sl$Addr)"
    , "(declare-const RH sl$Addr)"
    , "(declare-const RH@prime sl$Addr)"
    , "(declare-const dummy sl$Addr)"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const insL (pfun sl$REQ sl$OBJ))"
    , "(declare-const insL@prime (pfun sl$REQ sl$OBJ))"
    , "(declare-const insR (pfun sl$REQ sl$OBJ))"
    , "(declare-const insR@prime (pfun sl$REQ sl$OBJ))"
    , "(declare-const link"
    , "               (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-const link@prime"
    , "               (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl$REQ))"
    , "(declare-const popL@prime (set sl$REQ))"
    , "(declare-const popR (set sl$REQ))"
    , "(declare-const popR@prime (set sl$REQ))"
    , "(declare-const ppd (set sl$REQ))"
    , "(declare-const ppd@prime (set sl$REQ))"
    , "(declare-const pshL (set sl$REQ))"
    , "(declare-const pshL@prime (set sl$REQ))"
    , "(declare-const pshR (set sl$REQ))"
    , "(declare-const pshR@prime (set sl$REQ))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl$OBJ))"
    , "(declare-const qe@prime (pfun Int sl$OBJ))"
    , "(declare-const r sl$REQ)"
    , "(declare-const r0 sl$REQ)"
    , "(declare-const rep (pfun Int sl$Addr))"
    , "(declare-const rep@prime (pfun Int sl$Addr))"
    , "(declare-const req (set sl$REQ))"
    , "(declare-const res (pfun sl$REQ sl$OBJ))"
    , "(declare-const res@prime (pfun sl$REQ sl$OBJ))"
    , "(declare-const result sl$OBJ)"
    , "(declare-const result@prime sl$OBJ)"
    , "(declare-const v Int)"
    , "(declare-const v0 Int)"
    , "(declare-const ver Int)"
    , "(declare-const ver@prime Int)"
    , "(declare-fun apply@@Int@@sl$Addr"
    , "             ( (pfun Int sl$Addr)"
    , "               Int )"
    , "             sl$Addr)"
    , "(declare-fun apply@@Int@@sl$OBJ ( (pfun Int sl$OBJ) Int ) sl$OBJ)"
    , "(declare-fun apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "               sl$Addr )"
    , "             (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "(declare-fun apply@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ)"
    , "               sl$REQ )"
    , "             sl$OBJ)"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$Addr ( (set sl$Addr) ) Int)"
    , "(declare-fun card@@sl$OBJ ( (set sl$OBJ) ) Int)"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$Addr@Close"
    , "             ( (set (pfun Int sl$Addr)) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$OBJ@Close"
    , "             ( (set (pfun Int sl$OBJ)) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "             ( (set (pfun sl$Addr"
    , "                          (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "             ( (set (pfun sl$REQ sl$OBJ)) )"
    , "             Int)"
    , "(declare-fun const@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (Record-item-left-right sl$OBJ sl$Addr sl$Addr) )"
    , "             (Array (Record-item-left-right sl$OBJ sl$Addr sl$Addr)"
    , "                    (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun dom@@Int@@sl$Addr ( (pfun Int sl$Addr) ) (set Int))"
    , "(declare-fun dom@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) (set Int))"
    , "(declare-fun dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (set sl$Addr))"
    , "(declare-fun dom@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom-rest@@Int@@sl$Addr"
    , "             ( (set Int)"
    , "               (pfun Int sl$Addr) )"
    , "             (pfun Int sl$Addr))"
    , "(declare-fun dom-rest@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (pfun Int sl$OBJ) )"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun dom-rest@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (set sl$Addr)"
    , "               (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (pfun sl$Addr"
    , "                   (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$OBJ) )"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun dom-subt@@Int@@sl$Addr"
    , "             ( (set Int)"
    , "               (pfun Int sl$Addr) )"
    , "             (pfun Int sl$Addr))"
    , "(declare-fun dom-subt@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (pfun Int sl$OBJ) )"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun dom-subt@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (set sl$Addr)"
    , "               (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (pfun sl$Addr"
    , "                   (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$OBJ) )"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun empty-fun@@Int@@sl$Addr () (pfun Int sl$Addr))"
    , "(declare-fun empty-fun@@Int@@sl$OBJ () (pfun Int sl$OBJ))"
    , "(declare-fun empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ()"
    , "             (pfun sl$Addr"
    , "                   (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$OBJ () (pfun sl$REQ sl$OBJ))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$Addr ( (set sl$Addr) ) Bool)"
    , "(declare-fun finite@@sl$OBJ ( (set sl$OBJ) ) Bool)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(declare-fun finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$Addr@Close"
    , "             ( (set (pfun Int sl$Addr)) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$OBJ@Close"
    , "             ( (set (pfun Int sl$OBJ)) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "             ( (set (pfun sl$Addr"
    , "                          (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "             ( (set (pfun sl$REQ sl$OBJ)) )"
    , "             Bool)"
    , "(declare-fun ident@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ()"
    , "             (Array (Record-item-left-right sl$OBJ sl$Addr sl$Addr)"
    , "                    (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun injective@@Int@@sl$Addr ( (pfun Int sl$Addr) ) Bool)"
    , "(declare-fun injective@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) Bool)"
    , "(declare-fun injective@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@sl$Addr"
    , "             (Int sl$Addr)"
    , "             (pfun Int sl$Addr))"
    , "(declare-fun mk-fun@@Int@@sl$OBJ"
    , "             (Int sl$OBJ)"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             (sl$Addr (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "             (pfun sl$Addr"
    , "                   (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun mk-fun@@sl$REQ@@sl$OBJ"
    , "             (sl$REQ sl$OBJ)"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$Addr (sl$Addr) (set sl$Addr))"
    , "(declare-fun mk-set@@sl$OBJ (sl$OBJ) (set sl$OBJ))"
    , "(declare-fun mk-set@@sl$REQ (sl$REQ) (set sl$REQ))"
    , "(declare-fun mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (Record-item-left-right sl$OBJ sl$Addr sl$Addr) )"
    , "             (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$Addr@Close"
    , "             ( (pfun Int sl$Addr) )"
    , "             (set (pfun Int sl$Addr)))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$OBJ@Close"
    , "             ( (pfun Int sl$OBJ) )"
    , "             (set (pfun Int sl$OBJ)))"
    , "(declare-fun mk-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "             ( (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (set (pfun sl$Addr"
    , "                        (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "(declare-fun mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             (set (pfun sl$REQ sl$OBJ)))"
    , "(declare-fun ovl@@Int@@sl$Addr"
    , "             ( (pfun Int sl$Addr)"
    , "               (pfun Int sl$Addr) )"
    , "             (pfun Int sl$Addr))"
    , "(declare-fun ovl@@Int@@sl$OBJ"
    , "             ( (pfun Int sl$OBJ)"
    , "               (pfun Int sl$OBJ) )"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "               (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (pfun sl$Addr"
    , "                   (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun ovl@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ)"
    , "               (pfun sl$REQ sl$OBJ) )"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun pfun@@Int@@sl$Addr"
    , "             ( (set Int)"
    , "               (set sl$Addr) )"
    , "             (set (pfun Int sl$Addr)))"
    , "(declare-fun pfun@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun Int sl$OBJ)))"
    , "(declare-fun pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (set sl$Addr)"
    , "               (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (set (pfun sl$Addr"
    , "                        (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "(declare-fun pfun@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun sl$REQ sl$OBJ)))"
    , "(declare-fun ran@@Int@@sl$Addr"
    , "             ( (pfun Int sl$Addr) )"
    , "             (set sl$Addr))"
    , "(declare-fun ran@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) (set sl$OBJ))"
    , "(declare-fun ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (pfun sl$Addr"
    , "                     (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun ran@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             (set sl$OBJ))"
    , "(declare-fun set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "               (Array (Record-item-left-right sl$OBJ sl$Addr sl$Addr)"
    , "                      (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(declare-fun tfun@@Int@@sl$Addr"
    , "             ( (set Int)"
    , "               (set sl$Addr) )"
    , "             (set (pfun Int sl$Addr)))"
    , "(declare-fun tfun@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun Int sl$OBJ)))"
    , "(declare-fun tfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "             ( (set sl$Addr)"
    , "               (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "             (set (pfun sl$Addr"
    , "                        (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "(declare-fun tfun@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun sl$REQ sl$OBJ)))"
    , "(declare-fun @@lambda@@_0"
    , "             ( (set sl$OBJ)"
    , "               (set sl$Addr)"
    , "               (set sl$Addr) )"
    , "             (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "(define-fun Req"
    , "            ()"
    , "            (set sl$REQ)"
    , "            (union (union (union pshL pshR) popL) popR))"
    , "(define-fun Req@prime"
    , "            ()"
    , "            (set sl$REQ)"
    , "            (union (union (union pshL@prime pshR@prime) popL@prime)"
    , "                   popR@prime))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$Addr"
    , "            ()"
    , "            (set sl$Addr)"
    , "            ( (as const (set sl$Addr))"
    , "              true ))"
    , "(define-fun all@@sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ)"
    , "            ( (as const (set sl$OBJ))"
    , "              true ))"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun all@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "            ()"
    , "            (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "            ( (as const"
    , "                  (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$Addr@Close"
    , "            ()"
    , "            (set (pfun Int sl$Addr))"
    , "            ( (as const (set (pfun Int sl$Addr)))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun Int sl$OBJ))"
    , "            ( (as const (set (pfun Int sl$OBJ)))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "            ()"
    , "            (set (pfun sl$Addr"
    , "                       (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "            ( (as const"
    , "                  (set (pfun sl$Addr"
    , "                             (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun sl$REQ sl$OBJ))"
    , "            ( (as const (set (pfun sl$REQ sl$OBJ)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$Addr"
    , "            ( (s1 (set sl$Addr)) )"
    , "            (set sl$Addr)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$OBJ"
    , "            ( (s1 (set sl$OBJ)) )"
    , "            (set sl$OBJ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "            ( (s1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "            (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$Addr@Close"
    , "            ( (s1 (set (pfun Int sl$Addr))) )"
    , "            (set (pfun Int sl$Addr))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun Int sl$OBJ))) )"
    , "            (set (pfun Int sl$OBJ))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "            ( (s1 (set (pfun sl$Addr"
    , "                             (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "            (set (pfun sl$Addr"
    , "                       (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$OBJ))) )"
    , "            (set (pfun sl$REQ sl$OBJ))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$Addr"
    , "            ( (x sl$Addr)"
    , "              (s1 (set sl$Addr)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$OBJ"
    , "            ( (x sl$OBJ)"
    , "              (s1 (set sl$OBJ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$REQ"
    , "            ( (x sl$REQ)"
    , "              (s1 (set sl$REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "            ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "              (s1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$Addr@Close"
    , "            ( (x (pfun Int sl$Addr))"
    , "              (s1 (set (pfun Int sl$Addr))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ( (x (pfun Int sl$OBJ))"
    , "              (s1 (set (pfun Int sl$OBJ))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "            ( (x (pfun sl$Addr"
    , "                       (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "              (s1 (set (pfun sl$Addr"
    , "                             (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ( (x (pfun sl$REQ sl$OBJ))"
    , "              (s1 (set (pfun sl$REQ sl$OBJ))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$Addr"
    , "            ()"
    , "            (set sl$Addr)"
    , "            ( (as const (set sl$Addr))"
    , "              false ))"
    , "(define-fun empty-set@@sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ)"
    , "            ( (as const (set sl$OBJ))"
    , "              false ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "            ()"
    , "            (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "            ( (as const"
    , "                  (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$Addr@Close"
    , "            ()"
    , "            (set (pfun Int sl$Addr))"
    , "            ( (as const (set (pfun Int sl$Addr)))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun Int sl$OBJ))"
    , "            ( (as const (set (pfun Int sl$OBJ)))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "            ()"
    , "            (set (pfun sl$Addr"
    , "                       (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "            ( (as const"
    , "                  (set (pfun sl$Addr"
    , "                             (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun sl$REQ sl$OBJ))"
    , "            ( (as const (set (pfun sl$REQ sl$OBJ)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$Addr"
    , "            ( (s1 (set sl$Addr))"
    , "              (s2 (set sl$Addr)) )"
    , "            (set sl$Addr)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$OBJ"
    , "            ( (s1 (set sl$OBJ))"
    , "              (s2 (set sl$OBJ)) )"
    , "            (set sl$OBJ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "            ( (s1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "              (s2 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "            (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$Addr@Close"
    , "            ( (s1 (set (pfun Int sl$Addr)))"
    , "              (s2 (set (pfun Int sl$Addr))) )"
    , "            (set (pfun Int sl$Addr))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun Int sl$OBJ)))"
    , "              (s2 (set (pfun Int sl$OBJ))) )"
    , "            (set (pfun Int sl$OBJ))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "            ( (s1 (set (pfun sl$Addr"
    , "                             (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "              (s2 (set (pfun sl$Addr"
    , "                             (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "            (set (pfun sl$Addr"
    , "                       (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "              (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "            (set (pfun sl$REQ sl$OBJ))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$Addr"
    , "            ( (s1 (set sl$Addr))"
    , "              (s2 (set sl$Addr)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$OBJ"
    , "            ( (s1 (set sl$OBJ))"
    , "              (s2 (set sl$OBJ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "            ( (s1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "              (s2 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$Addr@Close"
    , "            ( (s1 (set (pfun Int sl$Addr)))"
    , "              (s2 (set (pfun Int sl$Addr))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun Int sl$OBJ)))"
    , "              (s2 (set (pfun Int sl$OBJ))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close"
    , "            ( (s1 (set (pfun sl$Addr"
    , "                             (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "              (s2 (set (pfun sl$Addr"
    , "                             (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "              (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Addr"
    , "            ()"
    , "            (set sl$Addr)"
    , "            ( (as const (set sl$Addr))"
    , "              true ))"
    , "(define-fun sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ)"
    , "            ( (as const (set sl$OBJ))"
    , "              true ))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun Node@prime"
    , "            ()"
    , "            (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "            (set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (@@lambda@@_0 sl$OBJ sl$Addr sl$Addr)"
    , "                                                                                                                                           ident@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close))"
    , "(define-fun Node"
    , "            ()"
    , "            (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "            (set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (@@lambda@@_0 sl$OBJ sl$Addr sl$Addr)"
    , "                                                                                                                                           ident@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (=> (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r)"
    , "                       (<= 0"
    , "                           (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0"
    , "                         (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$Addr))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$Addr@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$Addr@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$Addr@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$OBJ@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$OBJ@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$OBJ@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun sl$Addr"
    , "                                (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r)"
    , "                       (<= 0"
    , "                           (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0"
    , "                         (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)) ))))"
    , "(assert (forall ( (r (set sl$Addr)) )"
    , "                (! (=> (finite@@sl$Addr r) (<= 0 (card@@sl$Addr r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Addr r)) ))))"
    , "(assert (forall ( (r (set sl$OBJ)) )"
    , "                (! (=> (finite@@sl$OBJ r) (<= 0 (card@@sl$OBJ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$OBJ r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (= (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r)"
    , "                         0)"
    , "                      (= r"
    , "                         empty-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$Addr))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$Addr@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$Addr@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$Addr@Close r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$OBJ@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$OBJ@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$Addr"
    , "                                (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r)"
    , "                         0)"
    , "                      (= r"
    , "                         empty-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set sl$Addr)) )"
    , "                (! (= (= (card@@sl$Addr r) 0) (= r empty-set@@sl$Addr))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr r) ))))"
    , "(assert (forall ( (r (set sl$OBJ)) )"
    , "                (! (= (= (card@@sl$OBJ r) 0) (= r empty-set@@sl$OBJ))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$Addr)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$Addr@Close (mk-set@Open@@pfun@@Int@@sl$Addr@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$Addr@Close (mk-set@Open@@pfun@@Int@@sl$Addr@Close x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$OBJ)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$Addr"
    , "                           (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (mk-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (mk-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x sl$Addr) )"
    , "                (! (= (card@@sl$Addr (mk-set@@sl$Addr x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr (mk-set@@sl$Addr x)) ))))"
    , "(assert (forall ( (x sl$OBJ) )"
    , "                (! (= (card@@sl$OBJ (mk-set@@sl$OBJ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ (mk-set@@sl$OBJ x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (= (card@@sl$REQ (mk-set@@sl$REQ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (= (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r)"
    , "                         1)"
    , "                      (exists ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                              (and true"
    , "                                   (= r"
    , "                                      (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$Addr))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$Addr@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$Addr)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@Int@@sl$Addr@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$Addr@Close r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$OBJ@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$OBJ)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$Addr"
    , "                                (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r)"
    , "                         1)"
    , "                      (exists ( (x (pfun sl$Addr"
    , "                                         (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                              (and true"
    , "                                   (= r"
    , "                                      (mk-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) 1)"
    , "                      (exists ( (x (pfun sl$REQ sl$OBJ)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set sl$Addr)) )"
    , "                (! (= (= (card@@sl$Addr r) 1)"
    , "                      (exists ( (x sl$Addr) )"
    , "                              (and true (= r (mk-set@@sl$Addr x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr r) ))))"
    , "(assert (forall ( (r (set sl$OBJ)) )"
    , "                (! (= (= (card@@sl$OBJ r) 1)"
    , "                      (exists ( (x sl$OBJ) ) (and true (= r (mk-set@@sl$OBJ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 1)"
    , "                      (exists ( (x sl$REQ) ) (and true (= r (mk-set@@sl$REQ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (r0 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close)"
    , "                       (= (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (union r r0))"
    , "                          (+ (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r)"
    , "                             (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$Addr)))"
    , "                  (r0 (set (pfun Int sl$Addr))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$Addr@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$Addr@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$Addr@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$Addr@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$Addr@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$OBJ)))"
    , "                  (r0 (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$OBJ@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$OBJ@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$OBJ@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$OBJ@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun sl$Addr"
    , "                                (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "                  (r0 (set (pfun sl$Addr"
    , "                                 (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close)"
    , "                       (= (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r)"
    , "                             (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$OBJ)))"
    , "                  (r0 (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close)"
    , "                       (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)"
    , "                             (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Addr))"
    , "                  (r0 (set sl$Addr)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Addr)"
    , "                       (= (card@@sl$Addr (union r r0))"
    , "                          (+ (card@@sl$Addr r) (card@@sl$Addr r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$OBJ))"
    , "                  (r0 (set sl$OBJ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$OBJ)"
    , "                       (= (card@@sl$OBJ (union r r0))"
    , "                          (+ (card@@sl$OBJ r) (card@@sl$OBJ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (forall ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (select (const@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x)"
    , "                              y)"
    , "                      x)"
    , "                   :pattern"
    , "                   ( (select (const@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x)"
    , "                             y) ))))"
    , "(assert (forall ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (select ident@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "                              x)"
    , "                      x)"
    , "                   :pattern"
    , "                   ( (select ident@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "                             x) ))))"
    , "(assert (= (dom@@Int@@sl$Addr empty-fun@@Int@@sl$Addr)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close)"
    , "           empty-set@@sl$Addr))"
    , "(assert (= (dom@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ)"
    , "           empty-set@@sl$REQ))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr)) )"
    , "                (! (= (ovl@@Int@@sl$Addr f1 empty-fun@@Int@@sl$Addr) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$Addr f1 empty-fun@@Int@@sl$Addr) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ)) )"
    , "                (! (= (ovl@@Int@@sl$OBJ f1 empty-fun@@Int@@sl$OBJ) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$OBJ f1 empty-fun@@Int@@sl$OBJ) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                 empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$OBJ f1 empty-fun@@sl$REQ@@sl$OBJ)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$OBJ f1 empty-fun@@sl$REQ@@sl$OBJ) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr)) )"
    , "                (! (= (ovl@@Int@@sl$Addr empty-fun@@Int@@sl$Addr f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$Addr empty-fun@@Int@@sl$Addr f1) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ)) )"
    , "                (! (= (ovl@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "                                                                                                 f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "                                                                                                f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ f1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (= (dom@@Int@@sl$Addr (mk-fun@@Int@@sl$Addr x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Addr (mk-fun@@Int@@sl$Addr x y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (dom@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y))"
    , "                      (mk-set@@sl$Addr x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                      (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (f2 (pfun Int sl$Addr))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$Addr f2))"
    , "                       (= (apply@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 f2) x)"
    , "                          (apply@@Int@@sl$Addr f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (f2 (pfun Int sl$OBJ))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$OBJ f2))"
    , "                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x)"
    , "                          (apply@@Int@@sl$OBJ f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (f2 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr) )"
    , "                (! (=> (elem@@sl$Addr x"
    , "                                      (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f2))"
    , "                       (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 f2)"
    , "                                                                                                       x)"
    , "                          (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 f2)"
    , "                                                                                                  x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (f2 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f2))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$OBJ f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (f2 (pfun Int sl$Addr))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl$Addr f2))))"
    , "                       (= (apply@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 f2) x)"
    , "                          (apply@@Int@@sl$Addr f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (f2 (pfun Int sl$OBJ))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl$OBJ f2))))"
    , "                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x)"
    , "                          (apply@@Int@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (f2 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr) )"
    , "                (! (=> (and (elem@@sl$Addr x"
    , "                                           (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                            (not (elem@@sl$Addr x"
    , "                                                (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f2))))"
    , "                       (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 f2)"
    , "                                                                                                       x)"
    , "                          (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 f2)"
    , "                                                                                                  x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (f2 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                            (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f2))))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (= (apply@@Int@@sl$Addr (mk-fun@@Int@@sl$Addr x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Addr (mk-fun@@Int@@sl$Addr x y) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y) x) ))))"
    , "(assert (forall ( (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y)"
    , "                                                                                                   x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y)"
    , "                                                                                                  x) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl$Addr f1)))"
    , "                       (= (apply@@Int@@sl$Addr (dom-rest@@Int@@sl$Addr s1 f1) x)"
    , "                          (apply@@Int@@sl$Addr f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Addr (dom-rest@@Int@@sl$Addr s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl$OBJ f1)))"
    , "                       (= (apply@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1) x)"
    , "                          (apply@@Int@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s1 (set sl$Addr))"
    , "                  (x sl$Addr) )"
    , "                (! (=> (and (elem@@sl$Addr x s1)"
    , "                            (elem@@sl$Addr x"
    , "                                           (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)))"
    , "                       (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-rest@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1)"
    , "                                                                                                       x)"
    , "                          (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-rest@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1)"
    , "                                                                                                  x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x s1)"
    , "                            (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$Addr f1) s1))"
    , "                       (= (apply@@Int@@sl$Addr (dom-subt@@Int@@sl$Addr s1 f1) x)"
    , "                          (apply@@Int@@sl$Addr f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Addr (dom-subt@@Int@@sl$Addr s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))"
    , "                       (= (apply@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1) x)"
    , "                          (apply@@Int@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s1 (set sl$Addr))"
    , "                  (x sl$Addr) )"
    , "                (! (=> (elem@@sl$Addr x"
    , "                                      (set-diff@@sl$Addr (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                                         s1))"
    , "                       (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-subt@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1)"
    , "                                                                                                       x)"
    , "                          (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-subt@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1)"
    , "                                                                                                  x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (s2 (set sl$Addr)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$Addr@Close empty-fun@@Int@@sl$Addr"
    , "                                                        (tfun@@Int@@sl$Addr empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$Addr@Close empty-fun@@Int@@sl$Addr"
    , "                                                          (tfun@@Int@@sl$Addr empty-set@@Int s2)) ))))"
    , "(assert (forall ( (s2 (set sl$OBJ)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$OBJ@Close empty-fun@@Int@@sl$OBJ"
    , "                                                       (tfun@@Int@@sl$OBJ empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close empty-fun@@Int@@sl$OBJ"
    , "                                                         (tfun@@Int@@sl$OBJ empty-set@@Int s2)) ))))"
    , "(assert (forall ( (s2 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "                                                                                                                (tfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close empty-set@@sl$Addr s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close"
    , "                                                                                                                  (tfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close empty-set@@sl$Addr s2)) ))))"
    , "(assert (forall ( (s2 (set sl$OBJ)) )"
    , "                (! (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close empty-fun@@sl$REQ@@sl$OBJ"
    , "                                                          (tfun@@sl$REQ@@sl$OBJ empty-set@@sl$REQ s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close empty-fun@@sl$REQ@@sl$OBJ"
    , "                                                            (tfun@@sl$REQ@@sl$OBJ empty-set@@sl$REQ s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (f2 (pfun Int sl$Addr)) )"
    , "                (! (= (dom@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 f2))"
    , "                      (union (dom@@Int@@sl$Addr f1) (dom@@Int@@sl$Addr f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (f2 (pfun Int sl$OBJ)) )"
    , "                (! (= (dom@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2))"
    , "                      (union (dom@@Int@@sl$OBJ f1) (dom@@Int@@sl$OBJ f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (f2 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 f2))"
    , "                      (union (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                             (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (f2 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$OBJ f1) (dom@@sl$REQ@@sl$OBJ f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$Addr (dom-rest@@Int@@sl$Addr s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$Addr f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Addr (dom-rest@@Int@@sl$Addr s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s1 (set sl$Addr)) )"
    , "                (! (= (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-rest@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1))"
    , "                      (intersect s1"
    , "                                 (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-rest@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$Addr (dom-subt@@Int@@sl$Addr s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$Addr f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Addr (dom-subt@@Int@@sl$Addr s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s1 (set sl$Addr)) )"
    , "                (! (= (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-subt@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1))"
    , "                      (set-diff@@sl$Addr (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                         s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-subt@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                           (= (apply@@Int@@sl$Addr f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                     (apply@@Int@@sl$Addr f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                           (= (apply@@Int@@sl$Addr f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                     (apply@@Int@@sl$Addr f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                           (= (apply@@Int@@sl$Addr f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                     (apply@@Int@@sl$Addr f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                           (= (apply@@Int@@sl$Addr f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                     (apply@@Int@@sl$Addr f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (and (elem@@sl$Addr x"
    , "                                          (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                           (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                              y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr x"
    , "                                    (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                     (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (and (elem@@sl$Addr x"
    , "                                          (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                           (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                              y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr x"
    , "                                    (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                     (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (and (elem@@sl$Addr x"
    , "                                          (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                           (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                              y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr x"
    , "                                    (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                     (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (and (elem@@sl$Addr x"
    , "                                          (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                           (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                              y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr x"
    , "                                    (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                     (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl$Addr) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 (mk-fun@@Int@@sl$Addr x y))"
    , "                                               x2)"
    , "                          (apply@@Int@@sl$Addr f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 (mk-fun@@Int@@sl$Addr x y))"
    , "                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))"
    , "                                              x2)"
    , "                          (apply@@Int@@sl$OBJ f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))"
    , "                                         x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr)"
    , "                  (x2 sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                                                                                                  (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y))"
    , "                                                                                                       x2)"
    , "                          (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                                                                                             (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y))"
    , "                                                                                                  x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (x2 sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                                                 x2)"
    , "                          (apply@@sl$REQ@@sl$OBJ f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                                            x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (= (apply@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 (mk-fun@@Int@@sl$Addr x y))"
    , "                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 (mk-fun@@Int@@sl$Addr x y))"
    , "                                          x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                                                                                              (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y))"
    , "                                                                                                   x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                                                                                             (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y))"
    , "                                                                                                  x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                                             x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                                            x) ))))"
    , "(assert (= (ran@@Int@@sl$Addr empty-fun@@Int@@sl$Addr)"
    , "           empty-set@@sl$Addr))"
    , "(assert (= (ran@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ)"
    , "           empty-set@@sl$OBJ))"
    , "(assert (= (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close)"
    , "           empty-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close))"
    , "(assert (= (ran@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ)"
    , "           empty-set@@sl$OBJ))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (y sl$Addr) )"
    , "                (! (= (elem@@sl$Addr y (ran@@Int@@sl$Addr f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                                        (= (apply@@Int@@sl$Addr f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr y (ran@@Int@@sl$Addr f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ y (ran@@Int@@sl$OBJ f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                                        (= (apply@@Int@@sl$OBJ f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ y (ran@@Int@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y"
    , "                                                                                         (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                      (exists ( (x sl$Addr) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$Addr x"
    , "                                                       (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                                        (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                                           y)))))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y"
    , "                                                                                        (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ y (ran@@sl$REQ@@sl$OBJ f1))"
    , "                      (exists ( (x sl$REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                                        (= (apply@@sl$REQ@@sl$OBJ f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ y (ran@@sl$REQ@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (= (ran@@Int@@sl$Addr (mk-fun@@Int@@sl$Addr x y))"
    , "                      (mk-set@@sl$Addr y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$Addr (mk-fun@@Int@@sl$Addr x y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (ran@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y))"
    , "                      (mk-set@@sl$OBJ y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y))"
    , "                      (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (ran@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                      (mk-set@@sl$OBJ y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$Addr)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$Addr@Close f1 (tfun@@Int@@sl$Addr s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$Addr f1))"
    , "                           (subset (ran@@Int@@sl$Addr f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$Addr@Close f1 (tfun@@Int@@sl$Addr s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (tfun@@Int@@sl$OBJ s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$OBJ f1))"
    , "                           (subset (ran@@Int@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (tfun@@Int@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s1 (set sl$Addr))"
    , "                  (s2 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close f1"
    , "                                                                                                                   (tfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 s2))"
    , "                      (and (= s1"
    , "                              (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                           (subset (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                   s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close f1"
    , "                                                                                                                  (tfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (tfun@@sl$REQ@@sl$OBJ s1 s2))"
    , "                      (and (= s1 (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (subset (ran@@sl$REQ@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (tfun@@sl$REQ@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$Addr)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$Addr@Close f1 (pfun@@Int@@sl$Addr s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$Addr f1) s1)"
    , "                           (subset (ran@@Int@@sl$Addr f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$Addr@Close f1 (pfun@@Int@@sl$Addr s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (pfun@@Int@@sl$OBJ s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$OBJ f1) s1)"
    , "                           (subset (ran@@Int@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (pfun@@Int@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s1 (set sl$Addr))"
    , "                  (s2 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close f1"
    , "                                                                                                                   (pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 s2))"
    , "                      (and (subset (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                   s1)"
    , "                           (subset (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                   s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close f1"
    , "                                                                                                                  (pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (pfun@@sl$REQ@@sl$OBJ s1 s2))"
    , "                      (and (subset (dom@@sl$REQ@@sl$OBJ f1) s1)"
    , "                           (subset (ran@@sl$REQ@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (pfun@@sl$REQ@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr)) )"
    , "                (! (= (injective@@Int@@sl$Addr f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl$Addr f1)))"
    , "                                  (=> (= (apply@@Int@@sl$Addr f1 x)"
    , "                                         (apply@@Int@@sl$Addr f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl$Addr f1) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ)) )"
    , "                (! (= (injective@@Int@@sl$OBJ f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl$OBJ f1)))"
    , "                                  (=> (= (apply@@Int@@sl$OBJ f1 x)"
    , "                                         (apply@@Int@@sl$OBJ f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl$OBJ f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (injective@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                      (forall ( (x sl$Addr)"
    , "                                (x2 sl$Addr) )"
    , "                              (=> (and (elem@@sl$Addr x"
    , "                                                      (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                                       (elem@@sl$Addr x2"
    , "                                                      (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)))"
    , "                                  (=> (= (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                                         (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (injective@@sl$REQ@@sl$OBJ f1)"
    , "                      (forall ( (x sl$REQ)"
    , "                                (x2 sl$REQ) )"
    , "                              (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                                       (elem@@sl$REQ x2 (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                                  (=> (= (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                         (apply@@sl$REQ@@sl$OBJ f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$REQ@@sl$OBJ f1) ))))"
    , "(assert (injective@@Int@@sl$Addr empty-fun@@Int@@sl$Addr))"
    , "(assert (injective@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ))"
    , "(assert (injective@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close empty-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close))"
    , "(assert (injective@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                       (elem@@sl$Addr (apply@@Int@@sl$Addr f1 x) (ran@@Int@@sl$Addr f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr (apply@@Int@@sl$Addr f1 x) (ran@@Int@@sl$Addr f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x) (ran@@Int@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x) (ran@@Int@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr) )"
    , "                (! (=> (elem@@sl$Addr x"
    , "                                      (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                       (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                                                                                          (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                                                                                        (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                       (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$REQ@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$REQ@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$Addr f1) s1))"
    , "                       (elem@@sl$Addr (apply@@Int@@sl$Addr f1 x)"
    , "                                      (ran@@Int@@sl$Addr (dom-subt@@Int@@sl$Addr s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr (apply@@Int@@sl$Addr f1 x)"
    , "                                    (ran@@Int@@sl$Addr (dom-subt@@Int@@sl$Addr s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                     (ran@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                   (ran@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s1 (set sl$Addr))"
    , "                  (x sl$Addr) )"
    , "                (! (=> (elem@@sl$Addr x"
    , "                                      (set-diff@@sl$Addr (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                                         s1))"
    , "                       (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                                                                                          (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-subt@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                                                                                        (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-subt@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$Addr f1) s1))"
    , "                       (elem@@sl$Addr (apply@@Int@@sl$Addr f1 x)"
    , "                                      (ran@@Int@@sl$Addr (dom-rest@@Int@@sl$Addr s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr (apply@@Int@@sl$Addr f1 x)"
    , "                                    (ran@@Int@@sl$Addr (dom-rest@@Int@@sl$Addr s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                     (ran@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                   (ran@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s1 (set sl$Addr))"
    , "                  (x sl$Addr) )"
    , "                (! (=> (elem@@sl$Addr x"
    , "                                      (intersect (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                                 s1))"
    , "                       (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                                                                                          (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-rest@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)"
    , "                                                                                        (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (dom-rest@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (intersect (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$Addr f1))"
    , "                            (injective@@Int@@sl$Addr f1))"
    , "                       (= (ran@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 (mk-fun@@Int@@sl$Addr x y)))"
    , "                          (union (set-diff@@sl$Addr (ran@@Int@@sl$Addr f1)"
    , "                                                    (mk-set@@sl$Addr (apply@@Int@@sl$Addr f1 x)))"
    , "                                 (mk-set@@sl$Addr y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 (mk-fun@@Int@@sl$Addr x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                            (injective@@Int@@sl$OBJ f1))"
    , "                       (= (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)))"
    , "                          (union (set-diff@@sl$OBJ (ran@@Int@@sl$OBJ f1)"
    , "                                                   (mk-set@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)))"
    , "                                 (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (=> (and (elem@@sl$Addr x"
    , "                                           (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                            (injective@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1))"
    , "                       (= (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                                                                                                (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y)))"
    , "                          (union (set-diff@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                                                                                        (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1 x)))"
    , "                                 (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                                                                                           (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                            (injective@@sl$REQ@@sl$OBJ f1))"
    , "                       (= (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y)))"
    , "                          (union (set-diff@@sl$OBJ (ran@@sl$REQ@@sl$OBJ f1)"
    , "                                                   (mk-set@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)))"
    , "                                 (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Addr))"
    , "                  (x Int)"
    , "                  (y sl$Addr) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl$Addr f1)))"
    , "                       (= (ran@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 (mk-fun@@Int@@sl$Addr x y)))"
    , "                          (union (ran@@Int@@sl$Addr f1) (mk-set@@sl$Addr y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$Addr (ovl@@Int@@sl$Addr f1 (mk-fun@@Int@@sl$Addr x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl$OBJ f1)))"
    , "                       (= (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)))"
    , "                          (union (ran@@Int@@sl$OBJ f1) (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr"
    , "                            (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (x sl$Addr)"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (=> (not (elem@@sl$Addr x"
    , "                                           (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)))"
    , "                       (= (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                                                                                                (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y)))"
    , "                          (union (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1)"
    , "                                 (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ovl@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close f1"
    , "                                                                                                                                                                           (mk-fun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                       (= (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y)))"
    , "                          (union (ran@@sl$REQ@@sl$OBJ f1) (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr))"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x"
    , "                                                                                         (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x"
    , "                                                                                        (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$Addr))"
    , "                  (y (pfun Int sl$Addr)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$Addr@Close x (mk-set@Open@@pfun@@Int@@sl$Addr@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$Addr@Close x (mk-set@Open@@pfun@@Int@@sl$Addr@Close y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$OBJ))"
    , "                  (y (pfun Int sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$OBJ@Close x (mk-set@Open@@pfun@@Int@@sl$OBJ@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close x (mk-set@Open@@pfun@@Int@@sl$OBJ@Close y)) ))))"
    , "(assert (forall ( (x (pfun sl$Addr"
    , "                           (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (y (pfun sl$Addr"
    , "                           (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close x"
    , "                                                                                                                   (mk-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close x"
    , "                                                                                                                  (mk-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close y)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$OBJ))"
    , "                  (y (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close x (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close x (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close y)) ))))"
    , "(assert (forall ( (x sl$Addr)"
    , "                  (y sl$Addr) )"
    , "                (! (= (elem@@sl$Addr x (mk-set@@sl$Addr y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr x (mk-set@@sl$Addr y)) ))))"
    , "(assert (forall ( (x sl$OBJ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ x (mk-set@@sl$OBJ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ x (mk-set@@sl$OBJ y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$REQ) )"
    , "                (! (= (elem@@sl$REQ x (mk-set@@sl$REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (mk-set@@sl$REQ y)) ))))"
    , "(assert (forall ( (r1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (term (Array (Record-item-left-right sl$OBJ sl$Addr sl$Addr)"
    , "                               (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y"
    , "                                                                                         (set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r1 term))"
    , "                      (exists ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                              (and (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x r1)"
    , "                                   (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y"
    , "                                                                                        (set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r1 term)) ))))"
    , "(assert (forall ( (r1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (term (Array (Record-item-left-right sl$OBJ sl$Addr sl$Addr)"
    , "                               (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (y (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (= (set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r1 term)"
    , "                         (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y))"
    , "                      (forall ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                              (=> (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x r1)"
    , "                                  (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r1 term)"
    , "                     (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close y) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s2 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (=> (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1)"
    , "                       (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (set-diff@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (set-diff@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$Addr)))"
    , "                  (s2 (set (pfun Int sl$Addr))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$Addr@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$Addr@Close (set-diff@Open@@pfun@@Int@@sl$Addr@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$Addr@Close (set-diff@Open@@pfun@@Int@@sl$Addr@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$OBJ)))"
    , "                  (s2 (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$OBJ@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Addr"
    , "                                 (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "                  (s2 (set (pfun sl$Addr"
    , "                                 (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s1)"
    , "                       (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (set-diff@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (set-diff@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "                  (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1)"
    , "                       (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr))"
    , "                  (s2 (set sl$Addr)) )"
    , "                (! (=> (finite@@sl$Addr s1)"
    , "                       (finite@@sl$Addr (set-diff@@sl$Addr s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr (set-diff@@sl$Addr s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (=> (finite@@sl$OBJ s1)"
    , "                       (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s2 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (=> (and (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1)"
    , "                            (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s2))"
    , "                       (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$Addr)))"
    , "                  (s2 (set (pfun Int sl$Addr))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$Addr@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$Addr@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$Addr@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$Addr@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$OBJ)))"
    , "                  (s2 (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$OBJ@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$OBJ@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$OBJ@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Addr"
    , "                                 (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "                  (s2 (set (pfun sl$Addr"
    , "                                 (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s1)"
    , "                            (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s2))"
    , "                       (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "                  (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1)"
    , "                            (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s2))"
    , "                       (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr))"
    , "                  (s2 (set sl$Addr)) )"
    , "                (! (=> (and (finite@@sl$Addr s1) (finite@@sl$Addr s2))"
    , "                       (finite@@sl$Addr (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (=> (and (finite@@sl$OBJ s1) (finite@@sl$OBJ s2))"
    , "                       (finite@@sl$OBJ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))"
    , "                       (not (finite@@Int (set-diff@@Int s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))"
    , "                  (s2 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (=> (and (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s2)"
    , "                            (not (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1)))"
    , "                       (not (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (set-diff@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (set-diff@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$Addr)))"
    , "                  (s2 (set (pfun Int sl$Addr))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$Addr@Close s2)"
    , "                            (not (finite@Open@@pfun@@Int@@sl$Addr@Close s1)))"
    , "                       (not (finite@Open@@pfun@@Int@@sl$Addr@Close (set-diff@Open@@pfun@@Int@@sl$Addr@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$Addr@Close (set-diff@Open@@pfun@@Int@@sl$Addr@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$OBJ)))"
    , "                  (s2 (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$OBJ@Close s2)"
    , "                            (not (finite@Open@@pfun@@Int@@sl$OBJ@Close s1)))"
    , "                       (not (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Addr"
    , "                                 (Record-item-left-right sl$OBJ sl$Addr sl$Addr))))"
    , "                  (s2 (set (pfun sl$Addr"
    , "                                 (Record-item-left-right sl$OBJ sl$Addr sl$Addr)))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s2)"
    , "                            (not (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s1)))"
    , "                       (not (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (set-diff@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (set-diff@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "                  (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s2)"
    , "                            (not (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1)))"
    , "                       (not (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr))"
    , "                  (s2 (set sl$Addr)) )"
    , "                (! (=> (and (finite@@sl$Addr s2) (not (finite@@sl$Addr s1)))"
    , "                       (not (finite@@sl$Addr (set-diff@@sl$Addr s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr (set-diff@@sl$Addr s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (=> (and (finite@@sl$OBJ s2) (not (finite@@sl$OBJ s1)))"
    , "                       (not (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s2) (not (finite@@sl$REQ s1)))"
    , "                       (not (finite@@sl$REQ (set-diff@@sl$REQ s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (mk-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$Addr)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$Addr@Close (mk-set@Open@@pfun@@Int@@sl$Addr@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$Addr@Close (mk-set@Open@@pfun@@Int@@sl$Addr@Close x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$OBJ)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$Addr"
    , "                           (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (mk-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close (mk-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$OBJ)) )"
    , "                (! (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x sl$Addr) )"
    , "                (! (finite@@sl$Addr (mk-set@@sl$Addr x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr (mk-set@@sl$Addr x)) ))))"
    , "(assert (forall ( (x sl$OBJ) )"
    , "                (! (finite@@sl$OBJ (mk-set@@sl$OBJ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (mk-set@@sl$OBJ x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (finite@@sl$REQ (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close empty-set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close))"
    , "(assert (finite@Open@@pfun@@Int@@sl$Addr@Close empty-set@Open@@pfun@@Int@@sl$Addr@Close))"
    , "(assert (finite@Open@@pfun@@Int@@sl$OBJ@Close empty-set@Open@@pfun@@Int@@sl$OBJ@Close))"
    , "(assert (finite@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close empty-set@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close))"
    , "(assert (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close))"
    , "(assert (finite@@sl$Addr empty-set@@sl$Addr))"
    , "(assert (finite@@sl$OBJ empty-set@@sl$OBJ))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (r1 (set (Record-item-left-right sl$OBJ sl$Addr sl$Addr))) )"
    , "                (! (= (set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r1"
    , "                                                                                                                                                     ident@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close)"
    , "                      r1)"
    , "                   :pattern"
    , "                   ( (set@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close r1"
    , "                                                                                                                                                    ident@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (not (forall ( (r sl$REQ)"
    , "                       (v Int) )"
    , "                     (=> true"
    , "                         (=> (and (= RH dummy) (= v ver) (elem@@sl$REQ r pshR))"
    , "                             (or (= RH@prime dummy)"
    , "                                 (not (and (= v ver@prime) (elem@@sl$REQ r pshR@prime)))))))))"
    , "(assert (not (forall ( (v Int) )"
    , "                     (=> true"
    , "                         (=> (and (= RH dummy) (= v ver) (elem@@sl$REQ r0 pshR))"
    , "                             (or (= RH@prime dummy)"
    , "                                 (not (and (= v ver@prime) (elem@@sl$REQ r0 pshR@prime)))))))))"
    , "(assert (forall ( (@@fv@@_0 (set sl$OBJ))"
    , "                  (@@fv@@_1 (set sl$Addr))"
    , "                  (@@fv@@_2 (set sl$Addr))"
    , "                  (@@bv@@_0 (Record-item-left-right sl$OBJ sl$Addr sl$Addr)) )"
    , "                (! (= (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close @@bv@@_0"
    , "                                                                                         (@@lambda@@_0 @@fv@@_0 @@fv@@_1 @@fv@@_2))"
    , "                      (and (elem@@sl$OBJ (@@field@@_item @@bv@@_0) @@fv@@_0)"
    , "                           (elem@@sl$Addr (@@field@@_left @@bv@@_0) @@fv@@_1)"
    , "                           (elem@@sl$Addr (@@field@@_right @@bv@@_0) @@fv@@_2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close @@bv@@_0"
    , "                                                                                        (@@lambda@@_0 @@fv@@_0 @@fv@@_1 @@fv@@_2)) ))))"
    , "; SKIP:LH"
    , "(assert (= LH@prime LH))"
    , "; SKIP:RH"
    , "(assert (= RH@prime RH))"
    , "; SKIP:emp"
    , "(assert (= emp@prime emp))"
    , "; SKIP:insL"
    , "(assert (= insL@prime insL))"
    , "; SKIP:insR"
    , "(assert (= insR@prime insR))"
    , "; SKIP:link"
    , "(assert (= link@prime link))"
    , "; SKIP:p"
    , "(assert (= p@prime p))"
    , "; SKIP:popR"
    , "(assert (= popR@prime popR))"
    , "; SKIP:ppd"
    , "(assert (= ppd@prime ppd))"
    , "; SKIP:pshL"
    , "(assert (= pshL@prime pshL))"
    , "; SKIP:pshR"
    , "(assert (= pshR@prime pshR))"
    , "; SKIP:q"
    , "(assert (= q@prime q))"
    , "; SKIP:qe"
    , "(assert (= qe@prime qe))"
    , "; SKIP:rep"
    , "(assert (= rep@prime rep))"
    , "; SKIP:res"
    , "(assert (= res@prime res))"
    , "; SKIP:result"
    , "(assert (= result@prime result))"
    , "; SKIP:ver"
    , "(assert (= ver@prime ver))"
    , "; m1:sch1"
    , "(assert (= v ver))"
    , "; m2:act0"
    , "(assert (= popL@prime (union popL (mk-set@@sl$REQ r))))"
    , "; m2:grd0"
    , "(assert (not (elem@@sl$REQ r Req)))"
    , "; m2:inv0"
    , "(assert (= Req req))"
    , "; m2:inv1"
    , "(assert (= (intersect pshL pshR) empty-set@@sl$REQ))"
    , "; m2:inv2"
    , "(assert (= (intersect pshL popL) empty-set@@sl$REQ))"
    , "; m2:inv3"
    , "(assert (= (intersect pshL popR) empty-set@@sl$REQ))"
    , "; m2:inv4"
    , "(assert (= (intersect pshR popL) empty-set@@sl$REQ))"
    , "; m2:inv5"
    , "(assert (= (intersect pshR popR) empty-set@@sl$REQ))"
    , "; m2:inv6"
    , "(assert (= (intersect popL popR) empty-set@@sl$REQ))"
    , "; m2:sch0"
    , "(assert (elem@@sl$REQ r pshR))"
    , "; m3:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$OBJ@Close qe (tfun@@Int@@sl$OBJ (intervalR p q) sl$OBJ)))"
    , "; m3:inv1"
    , "(assert (<= p q))"
    , "; m3:inv2"
    , "(assert (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close insL (tfun@@sl$REQ@@sl$OBJ pshL sl$OBJ)))"
    , "; m3:inv3"
    , "(assert (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close insR (tfun@@sl$REQ@@sl$OBJ pshR sl$OBJ)))"
    , "; m3:inv4"
    , "(assert (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close res (pfun@@sl$REQ@@sl$OBJ ppd sl$OBJ)))"
    , "; m4:asm0"
    , "(assert (not (finite@@sl$Addr sl$Addr)))"
    , "; m4:inv0"
    , "(assert (injective@@Int@@sl$Addr rep))"
    , "; m4:inv1"
    , "(assert (elem@Open@@pfun@@Int@@sl$Addr@Close rep (tfun@@Int@@sl$Addr (intervalR p q) sl$Addr)))"
    , "; m4:inv2"
    , "(assert (not (elem@@sl$Addr dummy (ran@@Int@@sl$Addr rep))))"
    , "; m4:inv8"
    , "(assert (finite@@sl$Addr (ran@@Int@@sl$Addr rep)))"
    , "; m5:inv1"
    , "(assert (elem@Open@@pfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close@Close link"
    , "                                                                                                     (tfun@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close (ran@@Int@@sl$Addr rep) Node)))"
    , "; m5:inv11"
    , "(assert (forall ( (i Int) )"
    , "                (! (=> (betweenR p i (- q 1))"
    , "                       (= (@@field@@_right (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close link (apply@@Int@@sl$Addr rep i)))"
    , "                          (apply@@Int@@sl$Addr rep (+ i 1))))"
    , "                   :pattern"
    , "                   ( (@@field@@_right (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close link (apply@@Int@@sl$Addr rep i))) ))))"
    , "; m5:inv12"
    , "(assert (forall ( (i Int) )"
    , "                (! (=> (betweenR p i (- q 1))"
    , "                       (= (@@field@@_left (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close link (apply@@Int@@sl$Addr rep (+ i 1))))"
    , "                          (apply@@Int@@sl$Addr rep i)))"
    , "                   :pattern"
    , "                   ( (@@field@@_left (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close link (apply@@Int@@sl$Addr rep (+ i 1)))) ))))"
    , "; m5:inv13"
    , "(assert (=> (< p q) (= LH (apply@@Int@@sl$Addr rep p))))"
    , "; m5:inv14"
    , "(assert (=> (< p q) (= RH (apply@@Int@@sl$Addr rep (- q 1)))))"
    , "; m5:inv15"
    , "(assert (=> (= p q) (= LH dummy)))"
    , "; m5:inv16"
    , "(assert (=> (= p q) (= RH dummy)))"
    , "; m5:inv2"
    , "(assert (forall ( (i Int) )"
    , "                (! (=> (betweenR p i q)"
    , "                       (= (apply@@Int@@sl$OBJ qe i)"
    , "                          (@@field@@_item (apply@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close link (apply@@Int@@sl$Addr rep i)))))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ qe i) ))))"
    , "; m5:inv4"
    , "(assert (= (= p q) (= LH dummy)))"
    , "; m5:inv5"
    , "(assert (= (= p q) (= RH dummy)))"
    , "; m5:inv7"
    , "(assert (finite@@sl$Addr (dom@@sl$Addr@Open@@Record-item-left-right@@sl$OBJ@@sl$Addr@@sl$Addr@Close link)))"
    , "(assert (not (=> (and (= RH dummy) (= v0 ver) (elem@@sl$REQ r0 pshR))"
    , "                 (or (= RH@prime dummy)"
    , "                     (not (and (= v0 ver@prime) (elem@@sl$REQ r0 pshR@prime)))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m5/handle:pushR/C_SCH/weaken/saf/add:popL/SAF/handle:pushR:empty"
    ]

result31 :: String
result31 = unlines
    [ "; m5/INIT/FIS/item"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$Node 0)"
    , "(declare-sort sl$OBJ 0)"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const LH sl$Node)"
    , "(declare-const RH sl$Node)"
    , "(declare-const dummy sl$Node)"
    , "(declare-const emp Bool)"
    , "(declare-const insL (pfun sl$REQ sl$OBJ))"
    , "(declare-const insR (pfun sl$REQ sl$OBJ))"
    , "(declare-const item (pfun sl$Node sl$OBJ))"
    , "(declare-const left (pfun sl$Node sl$Node))"
    , "(declare-const nL (pfun sl$REQ sl$Node))"
    , "(declare-const nR (pfun sl$REQ sl$Node))"
    , "(declare-const new (set sl$Node))"
    , "(declare-const node (set sl$Node))"
    , "(declare-const p Int)"
    , "(declare-const popL (set sl$REQ))"
    , "(declare-const popR (set sl$REQ))"
    , "(declare-const ppd (set sl$REQ))"
    , "(declare-const pshL (set sl$REQ))"
    , "(declare-const pshR (set sl$REQ))"
    , "(declare-const q Int)"
    , "(declare-const qe (pfun Int sl$OBJ))"
    , "(declare-const rep (pfun Int sl$Node))"
    , "(declare-const req (set sl$REQ))"
    , "(declare-const res (pfun sl$REQ sl$OBJ))"
    , "(declare-const result sl$OBJ)"
    , "(declare-const right (pfun sl$Node sl$Node))"
    , "(declare-const ver Int)"
    , "(declare-fun apply@@Int@@sl$Node"
    , "             ( (pfun Int sl$Node)"
    , "               Int )"
    , "             sl$Node)"
    , "(declare-fun apply@@Int@@sl$OBJ ( (pfun Int sl$OBJ) Int ) sl$OBJ)"
    , "(declare-fun apply@@sl$Node@@sl$Node"
    , "             ( (pfun sl$Node sl$Node)"
    , "               sl$Node )"
    , "             sl$Node)"
    , "(declare-fun apply@@sl$Node@@sl$OBJ"
    , "             ( (pfun sl$Node sl$OBJ)"
    , "               sl$Node )"
    , "             sl$OBJ)"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$Node ( (set sl$Node) ) Int)"
    , "(declare-fun card@@sl$OBJ ( (set sl$OBJ) ) Int)"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun dom@@Int@@sl$Node ( (pfun Int sl$Node) ) (set Int))"
    , "(declare-fun dom@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) (set Int))"
    , "(declare-fun dom@@sl$Node@@sl$Node"
    , "             ( (pfun sl$Node sl$Node) )"
    , "             (set sl$Node))"
    , "(declare-fun dom@@sl$Node@@sl$OBJ"
    , "             ( (pfun sl$Node sl$OBJ) )"
    , "             (set sl$Node))"
    , "(declare-fun dom@@sl$REQ@@sl$Node"
    , "             ( (pfun sl$REQ sl$Node) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom-rest@@Int@@sl$Node"
    , "             ( (set Int)"
    , "               (pfun Int sl$Node) )"
    , "             (pfun Int sl$Node))"
    , "(declare-fun dom-rest@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (pfun Int sl$OBJ) )"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun dom-rest@@sl$Node@@sl$Node"
    , "             ( (set sl$Node)"
    , "               (pfun sl$Node sl$Node) )"
    , "             (pfun sl$Node sl$Node))"
    , "(declare-fun dom-rest@@sl$Node@@sl$OBJ"
    , "             ( (set sl$Node)"
    , "               (pfun sl$Node sl$OBJ) )"
    , "             (pfun sl$Node sl$OBJ))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$Node"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$Node) )"
    , "             (pfun sl$REQ sl$Node))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$OBJ) )"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun dom-subt@@Int@@sl$Node"
    , "             ( (set Int)"
    , "               (pfun Int sl$Node) )"
    , "             (pfun Int sl$Node))"
    , "(declare-fun dom-subt@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (pfun Int sl$OBJ) )"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun dom-subt@@sl$Node@@sl$Node"
    , "             ( (set sl$Node)"
    , "               (pfun sl$Node sl$Node) )"
    , "             (pfun sl$Node sl$Node))"
    , "(declare-fun dom-subt@@sl$Node@@sl$OBJ"
    , "             ( (set sl$Node)"
    , "               (pfun sl$Node sl$OBJ) )"
    , "             (pfun sl$Node sl$OBJ))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$Node"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$Node) )"
    , "             (pfun sl$REQ sl$Node))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$OBJ) )"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun empty-fun@@Int@@sl$Node () (pfun Int sl$Node))"
    , "(declare-fun empty-fun@@Int@@sl$OBJ () (pfun Int sl$OBJ))"
    , "(declare-fun empty-fun@@sl$Node@@sl$Node"
    , "             ()"
    , "             (pfun sl$Node sl$Node))"
    , "(declare-fun empty-fun@@sl$Node@@sl$OBJ"
    , "             ()"
    , "             (pfun sl$Node sl$OBJ))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$Node"
    , "             ()"
    , "             (pfun sl$REQ sl$Node))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$OBJ () (pfun sl$REQ sl$OBJ))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$Node ( (set sl$Node) ) Bool)"
    , "(declare-fun finite@@sl$OBJ ( (set sl$OBJ) ) Bool)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(declare-fun injective@@Int@@sl$Node ( (pfun Int sl$Node) ) Bool)"
    , "(declare-fun injective@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) Bool)"
    , "(declare-fun injective@@sl$Node@@sl$Node"
    , "             ( (pfun sl$Node sl$Node) )"
    , "             Bool)"
    , "(declare-fun injective@@sl$Node@@sl$OBJ"
    , "             ( (pfun sl$Node sl$OBJ) )"
    , "             Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$Node"
    , "             ( (pfun sl$REQ sl$Node) )"
    , "             Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@sl$Node"
    , "             (Int sl$Node)"
    , "             (pfun Int sl$Node))"
    , "(declare-fun mk-fun@@Int@@sl$OBJ"
    , "             (Int sl$OBJ)"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun mk-fun@@sl$Node@@sl$Node"
    , "             (sl$Node sl$Node)"
    , "             (pfun sl$Node sl$Node))"
    , "(declare-fun mk-fun@@sl$Node@@sl$OBJ"
    , "             (sl$Node sl$OBJ)"
    , "             (pfun sl$Node sl$OBJ))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$Node (sl$Node) (set sl$Node))"
    , "(declare-fun mk-set@@sl$OBJ (sl$OBJ) (set sl$OBJ))"
    , "(declare-fun ovl@@Int@@sl$Node"
    , "             ( (pfun Int sl$Node)"
    , "               (pfun Int sl$Node) )"
    , "             (pfun Int sl$Node))"
    , "(declare-fun ovl@@Int@@sl$OBJ"
    , "             ( (pfun Int sl$OBJ)"
    , "               (pfun Int sl$OBJ) )"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun ovl@@sl$Node@@sl$Node"
    , "             ( (pfun sl$Node sl$Node)"
    , "               (pfun sl$Node sl$Node) )"
    , "             (pfun sl$Node sl$Node))"
    , "(declare-fun ovl@@sl$Node@@sl$OBJ"
    , "             ( (pfun sl$Node sl$OBJ)"
    , "               (pfun sl$Node sl$OBJ) )"
    , "             (pfun sl$Node sl$OBJ))"
    , "(declare-fun ovl@@sl$REQ@@sl$Node"
    , "             ( (pfun sl$REQ sl$Node)"
    , "               (pfun sl$REQ sl$Node) )"
    , "             (pfun sl$REQ sl$Node))"
    , "(declare-fun ovl@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ)"
    , "               (pfun sl$REQ sl$OBJ) )"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun ran@@Int@@sl$Node"
    , "             ( (pfun Int sl$Node) )"
    , "             (set sl$Node))"
    , "(declare-fun ran@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) (set sl$OBJ))"
    , "(declare-fun ran@@sl$Node@@sl$Node"
    , "             ( (pfun sl$Node sl$Node) )"
    , "             (set sl$Node))"
    , "(declare-fun ran@@sl$Node@@sl$OBJ"
    , "             ( (pfun sl$Node sl$OBJ) )"
    , "             (set sl$OBJ))"
    , "(declare-fun ran@@sl$REQ@@sl$Node"
    , "             ( (pfun sl$REQ sl$Node) )"
    , "             (set sl$Node))"
    , "(declare-fun ran@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             (set sl$OBJ))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$Node"
    , "            ()"
    , "            (set sl$Node)"
    , "            ( (as const (set sl$Node))"
    , "              true ))"
    , "(define-fun all@@sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ)"
    , "            ( (as const (set sl$OBJ))"
    , "              true ))"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$Node"
    , "            ( (s1 (set sl$Node)) )"
    , "            (set sl$Node)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$OBJ"
    , "            ( (s1 (set sl$OBJ)) )"
    , "            (set sl$OBJ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$Node"
    , "            ( (x sl$Node)"
    , "              (s1 (set sl$Node)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$OBJ"
    , "            ( (x sl$OBJ)"
    , "              (s1 (set sl$OBJ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$Node"
    , "            ()"
    , "            (set sl$Node)"
    , "            ( (as const (set sl$Node))"
    , "              false ))"
    , "(define-fun empty-set@@sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ)"
    , "            ( (as const (set sl$OBJ))"
    , "              false ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$Node"
    , "            ( (s1 (set sl$Node))"
    , "              (s2 (set sl$Node)) )"
    , "            (set sl$Node)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$OBJ"
    , "            ( (s1 (set sl$OBJ))"
    , "              (s2 (set sl$OBJ)) )"
    , "            (set sl$OBJ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$Node"
    , "            ( (s1 (set sl$Node))"
    , "              (s2 (set sl$Node)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$OBJ"
    , "            ( (s1 (set sl$OBJ))"
    , "              (s2 (set sl$OBJ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Node"
    , "            ()"
    , "            (set sl$Node)"
    , "            ( (as const (set sl$Node))"
    , "              true ))"
    , "(define-fun sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ)"
    , "            ( (as const (set sl$OBJ))"
    , "              true ))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set sl$Node)) )"
    , "                (! (=> (finite@@sl$Node r) (<= 0 (card@@sl$Node r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Node r)) ))))"
    , "(assert (forall ( (r (set sl$OBJ)) )"
    , "                (! (=> (finite@@sl$OBJ r) (<= 0 (card@@sl$OBJ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$OBJ r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set sl$Node)) )"
    , "                (! (= (= (card@@sl$Node r) 0) (= r empty-set@@sl$Node))"
    , "                   :pattern"
    , "                   ( (card@@sl$Node r) ))))"
    , "(assert (forall ( (r (set sl$OBJ)) )"
    , "                (! (= (= (card@@sl$OBJ r) 0) (= r empty-set@@sl$OBJ))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x sl$Node) )"
    , "                (! (= (card@@sl$Node (mk-set@@sl$Node x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$Node (mk-set@@sl$Node x)) ))))"
    , "(assert (forall ( (x sl$OBJ) )"
    , "                (! (= (card@@sl$OBJ (mk-set@@sl$OBJ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ (mk-set@@sl$OBJ x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set sl$Node)) )"
    , "                (! (= (= (card@@sl$Node r) 1)"
    , "                      (exists ( (x sl$Node) )"
    , "                              (and true (= r (mk-set@@sl$Node x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Node r) ))))"
    , "(assert (forall ( (r (set sl$OBJ)) )"
    , "                (! (= (= (card@@sl$OBJ r) 1)"
    , "                      (exists ( (x sl$OBJ) ) (and true (= r (mk-set@@sl$OBJ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Node))"
    , "                  (r0 (set sl$Node)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Node)"
    , "                       (= (card@@sl$Node (union r r0))"
    , "                          (+ (card@@sl$Node r) (card@@sl$Node r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Node (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$OBJ))"
    , "                  (r0 (set sl$OBJ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$OBJ)"
    , "                       (= (card@@sl$OBJ (union r r0))"
    , "                          (+ (card@@sl$OBJ r) (card@@sl$OBJ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (= (dom@@Int@@sl$Node empty-fun@@Int@@sl$Node)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node)"
    , "           empty-set@@sl$Node))"
    , "(assert (= (dom@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ)"
    , "           empty-set@@sl$Node))"
    , "(assert (= (dom@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node)"
    , "           empty-set@@sl$REQ))"
    , "(assert (= (dom@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ)"
    , "           empty-set@@sl$REQ))"
    , "(assert (forall ( (f1 (pfun Int sl$Node)) )"
    , "                (! (= (ovl@@Int@@sl$Node f1 empty-fun@@Int@@sl$Node) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$Node f1 empty-fun@@Int@@sl$Node) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ)) )"
    , "                (! (= (ovl@@Int@@sl$OBJ f1 empty-fun@@Int@@sl$OBJ) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$OBJ f1 empty-fun@@Int@@sl$OBJ) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node)) )"
    , "                (! (= (ovl@@sl$Node@@sl$Node f1 empty-fun@@sl$Node@@sl$Node)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Node@@sl$Node f1 empty-fun@@sl$Node@@sl$Node) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ)) )"
    , "                (! (= (ovl@@sl$Node@@sl$OBJ f1 empty-fun@@sl$Node@@sl$OBJ)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Node@@sl$OBJ f1 empty-fun@@sl$Node@@sl$OBJ) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$Node f1 empty-fun@@sl$REQ@@sl$Node)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$Node f1 empty-fun@@sl$REQ@@sl$Node) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$OBJ f1 empty-fun@@sl$REQ@@sl$OBJ)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$OBJ f1 empty-fun@@sl$REQ@@sl$OBJ) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node)) )"
    , "                (! (= (ovl@@Int@@sl$Node empty-fun@@Int@@sl$Node f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$Node empty-fun@@Int@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ)) )"
    , "                (! (= (ovl@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node)) )"
    , "                (! (= (ovl@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ)) )"
    , "                (! (= (ovl@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ f1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (dom@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (dom@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (dom@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y))"
    , "                      (mk-set@@sl$Node x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y)) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (dom@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                      (mk-set@@sl$Node x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (f2 (pfun Int sl$Node))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$Node f2))"
    , "                       (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x)"
    , "                          (apply@@Int@@sl$Node f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (f2 (pfun Int sl$OBJ))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$OBJ f2))"
    , "                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x)"
    , "                          (apply@@Int@@sl$OBJ f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (f2 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$Node f2))"
    , "                       (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x)"
    , "                          (apply@@sl$Node@@sl$Node f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (f2 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f2))"
    , "                       (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x)"
    , "                          (apply@@sl$Node@@sl$OBJ f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (f2 (pfun Int sl$Node))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl$Node f2))))"
    , "                       (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x)"
    , "                          (apply@@Int@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (f2 (pfun Int sl$OBJ))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl$OBJ f2))))"
    , "                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x)"
    , "                          (apply@@Int@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (f2 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                            (not (elem@@sl$Node x (dom@@sl$Node@@sl$Node f2))))"
    , "                       (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x)"
    , "                          (apply@@sl$Node@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (f2 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node) )"
    , "                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                            (not (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f2))))"
    , "                       (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x)"
    , "                          (apply@@sl$Node@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (apply@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y) x) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (apply@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y) x) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl$Node f1)))"
    , "                       (= (apply@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1) x)"
    , "                          (apply@@Int@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl$OBJ f1)))"
    , "                       (= (apply@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1) x)"
    , "                          (apply@@Int@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (and (elem@@sl$Node x s1)"
    , "                            (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1)))"
    , "                       (= (apply@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1) x)"
    , "                          (apply@@sl$Node@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (and (elem@@sl$Node x s1)"
    , "                            (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1)))"
    , "                       (= (apply@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1) x)"
    , "                          (apply@@sl$Node@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$Node f1) s1))"
    , "                       (= (apply@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1) x)"
    , "                          (apply@@Int@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))"
    , "                       (= (apply@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1) x)"
    , "                          (apply@@Int@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x"
    , "                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$Node f1) s1))"
    , "                       (= (apply@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1) x)"
    , "                          (apply@@sl$Node@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x"
    , "                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$OBJ f1) s1))"
    , "                       (= (apply@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1) x)"
    , "                          (apply@@sl$Node@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (f2 (pfun Int sl$Node)) )"
    , "                (! (= (dom@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2))"
    , "                      (union (dom@@Int@@sl$Node f1) (dom@@Int@@sl$Node f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (f2 (pfun Int sl$OBJ)) )"
    , "                (! (= (dom@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2))"
    , "                      (union (dom@@Int@@sl$OBJ f1) (dom@@Int@@sl$OBJ f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (f2 (pfun sl$Node sl$Node)) )"
    , "                (! (= (dom@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2))"
    , "                      (union (dom@@sl$Node@@sl$Node f1)"
    , "                             (dom@@sl$Node@@sl$Node f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (f2 (pfun sl$Node sl$OBJ)) )"
    , "                (! (= (dom@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2))"
    , "                      (union (dom@@sl$Node@@sl$OBJ f1)"
    , "                             (dom@@sl$Node@@sl$OBJ f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (f2 (pfun sl$REQ sl$Node)) )"
    , "                (! (= (dom@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$Node f1)"
    , "                             (dom@@sl$REQ@@sl$Node f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (f2 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$OBJ f1) (dom@@sl$REQ@@sl$OBJ f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node)) )"
    , "                (! (= (dom@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1))"
    , "                      (intersect s1 (dom@@sl$Node@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node)) )"
    , "                (! (= (dom@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1))"
    , "                      (intersect s1 (dom@@sl$Node@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$Node f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node)) )"
    , "                (! (= (dom@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1))"
    , "                      (set-diff@@sl$Node (dom@@sl$Node@@sl$Node f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node)) )"
    , "                (! (= (dom@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1))"
    , "                      (set-diff@@sl$Node (dom@@sl$Node@@sl$OBJ f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$Node f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl$Node) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))"
    , "                                               x2)"
    , "                          (apply@@Int@@sl$Node f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))"
    , "                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))"
    , "                                              x2)"
    , "                          (apply@@Int@@sl$OBJ f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))"
    , "                                         x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (x2 sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))"
    , "                                                   x2)"
    , "                          (apply@@sl$Node@@sl$Node f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))"
    , "                                              x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (x2 sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                                                  x2)"
    , "                          (apply@@sl$Node@@sl$OBJ f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                                             x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))"
    , "                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))"
    , "                                          x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))"
    , "                                               x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))"
    , "                                              x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                                              x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                                             x) ))))"
    , "(assert (= (ran@@Int@@sl$Node empty-fun@@Int@@sl$Node)"
    , "           empty-set@@sl$Node))"
    , "(assert (= (ran@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ)"
    , "           empty-set@@sl$OBJ))"
    , "(assert (= (ran@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node)"
    , "           empty-set@@sl$Node))"
    , "(assert (= (ran@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ)"
    , "           empty-set@@sl$OBJ))"
    , "(assert (= (ran@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node)"
    , "           empty-set@@sl$Node))"
    , "(assert (= (ran@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ)"
    , "           empty-set@@sl$OBJ))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (y sl$Node) )"
    , "                (! (= (elem@@sl$Node y (ran@@Int@@sl$Node f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                                        (= (apply@@Int@@sl$Node f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node y (ran@@Int@@sl$Node f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ y (ran@@Int@@sl$OBJ f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                                        (= (apply@@Int@@sl$OBJ f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ y (ran@@Int@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (y sl$Node) )"
    , "                (! (= (elem@@sl$Node y (ran@@sl$Node@@sl$Node f1))"
    , "                      (exists ( (x sl$Node) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                                        (= (apply@@sl$Node@@sl$Node f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node y (ran@@sl$Node@@sl$Node f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ y (ran@@sl$Node@@sl$OBJ f1))"
    , "                      (exists ( (x sl$Node) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                                        (= (apply@@sl$Node@@sl$OBJ f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ y (ran@@sl$Node@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (ran@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y))"
    , "                      (mk-set@@sl$Node y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (ran@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y))"
    , "                      (mk-set@@sl$OBJ y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (ran@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y))"
    , "                      (mk-set@@sl$Node y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y)) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (ran@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                      (mk-set@@sl$OBJ y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node)) )"
    , "                (! (= (injective@@Int@@sl$Node f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl$Node f1)))"
    , "                                  (=> (= (apply@@Int@@sl$Node f1 x)"
    , "                                         (apply@@Int@@sl$Node f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ)) )"
    , "                (! (= (injective@@Int@@sl$OBJ f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl$OBJ f1)))"
    , "                                  (=> (= (apply@@Int@@sl$OBJ f1 x)"
    , "                                         (apply@@Int@@sl$OBJ f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl$OBJ f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node)) )"
    , "                (! (= (injective@@sl$Node@@sl$Node f1)"
    , "                      (forall ( (x sl$Node)"
    , "                                (x2 sl$Node) )"
    , "                              (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                                       (elem@@sl$Node x2 (dom@@sl$Node@@sl$Node f1)))"
    , "                                  (=> (= (apply@@sl$Node@@sl$Node f1 x)"
    , "                                         (apply@@sl$Node@@sl$Node f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$Node@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ)) )"
    , "                (! (= (injective@@sl$Node@@sl$OBJ f1)"
    , "                      (forall ( (x sl$Node)"
    , "                                (x2 sl$Node) )"
    , "                              (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                                       (elem@@sl$Node x2 (dom@@sl$Node@@sl$OBJ f1)))"
    , "                                  (=> (= (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                         (apply@@sl$Node@@sl$OBJ f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$Node@@sl$OBJ f1) ))))"
    , "(assert (injective@@Int@@sl$Node empty-fun@@Int@@sl$Node))"
    , "(assert (injective@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ))"
    , "(assert (injective@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node))"
    , "(assert (injective@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ))"
    , "(assert (injective@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node))"
    , "(assert (injective@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                       (elem@@sl$Node (apply@@Int@@sl$Node f1 x) (ran@@Int@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@Int@@sl$Node f1 x) (ran@@Int@@sl$Node f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x) (ran@@Int@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x) (ran@@Int@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                       (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                      (ran@@sl$Node@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                    (ran@@sl$Node@@sl$Node f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                       (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$Node@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$Node@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$Node f1) s1))"
    , "                       (elem@@sl$Node (apply@@Int@@sl$Node f1 x)"
    , "                                      (ran@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@Int@@sl$Node f1 x)"
    , "                                    (ran@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                     (ran@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                   (ran@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x"
    , "                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$Node f1) s1))"
    , "                       (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                      (ran@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                    (ran@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x"
    , "                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$Node f1) s1))"
    , "                       (elem@@sl$Node (apply@@Int@@sl$Node f1 x)"
    , "                                      (ran@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@Int@@sl$Node f1 x)"
    , "                                    (ran@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                     (ran@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                   (ran@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (intersect (dom@@sl$Node@@sl$Node f1) s1))"
    , "                       (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                      (ran@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                    (ran@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (intersect (dom@@sl$Node@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                            (injective@@Int@@sl$Node f1))"
    , "                       (= (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y)))"
    , "                          (union (set-diff@@sl$Node (ran@@Int@@sl$Node f1)"
    , "                                                    (mk-set@@sl$Node (apply@@Int@@sl$Node f1 x)))"
    , "                                 (mk-set@@sl$Node y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                            (injective@@Int@@sl$OBJ f1))"
    , "                       (= (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)))"
    , "                          (union (set-diff@@sl$OBJ (ran@@Int@@sl$OBJ f1)"
    , "                                                   (mk-set@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)))"
    , "                                 (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                            (injective@@sl$Node@@sl$Node f1))"
    , "                       (= (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y)))"
    , "                          (union (set-diff@@sl$Node (ran@@sl$Node@@sl$Node f1)"
    , "                                                    (mk-set@@sl$Node (apply@@sl$Node@@sl$Node f1 x)))"
    , "                                 (mk-set@@sl$Node y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                            (injective@@sl$Node@@sl$OBJ f1))"
    , "                       (= (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y)))"
    , "                          (union (set-diff@@sl$OBJ (ran@@sl$Node@@sl$OBJ f1)"
    , "                                                   (mk-set@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)))"
    , "                                 (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl$Node f1)))"
    , "                       (= (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y)))"
    , "                          (union (ran@@Int@@sl$Node f1) (mk-set@@sl$Node y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl$OBJ f1)))"
    , "                       (= (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)))"
    , "                          (union (ran@@Int@@sl$OBJ f1) (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (=> (not (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1)))"
    , "                       (= (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y)))"
    , "                          (union (ran@@sl$Node@@sl$Node f1) (mk-set@@sl$Node y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1)))"
    , "                       (= (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y)))"
    , "                          (union (ran@@sl$Node@@sl$OBJ f1) (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (elem@@sl$Node x (mk-set@@sl$Node y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (mk-set@@sl$Node y)) ))))"
    , "(assert (forall ( (x sl$OBJ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ x (mk-set@@sl$OBJ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ x (mk-set@@sl$OBJ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Node))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (=> (finite@@sl$Node s1)"
    , "                       (finite@@sl$Node (set-diff@@sl$Node s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Node (set-diff@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (=> (finite@@sl$OBJ s1)"
    , "                       (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Node))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (=> (and (finite@@sl$Node s1) (finite@@sl$Node s2))"
    , "                       (finite@@sl$Node (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Node (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (=> (and (finite@@sl$OBJ s1) (finite@@sl$OBJ s2))"
    , "                       (finite@@sl$OBJ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))"
    , "                       (not (finite@@Int (set-diff@@Int s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Node))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (=> (and (finite@@sl$Node s2) (not (finite@@sl$Node s1)))"
    , "                       (not (finite@@sl$Node (set-diff@@sl$Node s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Node (set-diff@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (=> (and (finite@@sl$OBJ s2) (not (finite@@sl$OBJ s1)))"
    , "                       (not (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s2) (not (finite@@sl$REQ s1)))"
    , "                       (not (finite@@sl$REQ (set-diff@@sl$REQ s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x sl$Node) )"
    , "                (! (finite@@sl$Node (mk-set@@sl$Node x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Node (mk-set@@sl$Node x)) ))))"
    , "(assert (forall ( (x sl$OBJ) )"
    , "                (! (finite@@sl$OBJ (mk-set@@sl$OBJ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (mk-set@@sl$OBJ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@@sl$Node empty-set@@sl$Node))"
    , "(assert (finite@@sl$OBJ empty-set@@sl$OBJ))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "; m1:init0"
    , "(assert (= ver 0))"
    , "; m2:init0"
    , "(assert (= pshL empty-set@@sl$REQ))"
    , "; m2:init1"
    , "(assert (= popL empty-set@@sl$REQ))"
    , "; m2:init2"
    , "(assert (= pshR empty-set@@sl$REQ))"
    , "; m2:init3"
    , "(assert (= popR empty-set@@sl$REQ))"
    , "; m2:init4"
    , "(assert (= ppd empty-set@@sl$REQ))"
    , "; m3:init0"
    , "(assert (= q 0))"
    , "; m3:init1"
    , "(assert (= qe empty-fun@@Int@@sl$OBJ))"
    , "; m3:init2"
    , "(assert (= insL empty-fun@@sl$REQ@@sl$OBJ))"
    , "; m3:init3"
    , "(assert (= res empty-fun@@sl$REQ@@sl$OBJ))"
    , "; m3:init4"
    , "(assert (= insR empty-fun@@sl$REQ@@sl$OBJ))"
    , "; m4:asm0"
    , "(assert (not (finite@@sl$Node sl$Node)))"
    , "; m4:init0"
    , "(assert (= rep empty-fun@@Int@@sl$Node))"
    , "; m4:init2"
    , "(assert (= node (mk-set@@sl$Node dummy)))"
    , "; m4:init3"
    , "(assert (= nL empty-fun@@sl$REQ@@sl$Node))"
    , "; m4:init4"
    , "(assert (= nR empty-fun@@sl$REQ@@sl$Node))"
    , "; m5:init0"
    , "(assert (= left (mk-fun@@sl$Node@@sl$Node dummy dummy)))"
    , "; m5:init1"
    , "(assert (= right (mk-fun@@sl$Node@@sl$Node dummy dummy)))"
    , "; m5:init2"
    , "(assert (= RH dummy))"
    , "(assert (not (exists ( (item (pfun sl$Node sl$OBJ))"
    , "                       (val sl$OBJ) )"
    , "                     (and true (= item (mk-fun@@sl$Node@@sl$OBJ dummy val))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m5/INIT/FIS/item"
    ]

result32 :: String
result32 = unlines
    [ "; m0/add:popL/SCH/m0:grd0"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(declare-datatypes (a1 a2 a3)"
    , "                   ( (Record-item-left-right (Record-item-left-right (@@field@@_item a1)"
    , "                                                                     (@@field@@_left a2)"
    , "                                                                     (@@field@@_right a3))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "(declare-sort sl$Addr_0 0)"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$OBJ_0 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const LH sl$Addr_0)"
    , "(declare-const RH sl$Addr_0)"
    , "(declare-const free (set sl$Addr_0))"
    , "(declare-const popL Bool)"
    , "(declare-const remL Bool)"
    , "(declare-const resL sl$OBJ_0)"
    , "(declare-const ver Int)"
    , "(declare-const sl$link"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$trash"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun card@@sl$Addr_0 ( (set sl$Addr_0) ) Int)"
    , "(declare-fun card@@sl$OBJ_0 ( (set sl$OBJ_0) ) Int)"
    , "(declare-fun finite@@sl$Addr_0 ( (set sl$Addr_0) ) Bool)"
    , "(declare-fun finite@@sl$OBJ_0 ( (set sl$OBJ_0) ) Bool)"
    , "(define-fun all@@sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              true ))"
    , "(define-fun all@@sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              true ))"
    , "(define-fun compl@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0)) )"
    , "            (set sl$Addr_0)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0)) )"
    , "            (set sl$OBJ_0)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun empty-set@@sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              false ))"
    , "(define-fun empty-set@@sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              false ))"
    , "(define-fun set-diff@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0))"
    , "              (s2 (set sl$Addr_0)) )"
    , "            (set sl$Addr_0)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0))"
    , "              (s2 (set sl$OBJ_0)) )"
    , "            (set sl$OBJ_0)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0))"
    , "              (s2 (set sl$Addr_0)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0))"
    , "              (s2 (set sl$OBJ_0)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              true ))"
    , "(define-fun sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              true ))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (=> (finite@@sl$Addr_0 r) (<= 0 (card@@sl$Addr_0 r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Addr_0 r)) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (=> (finite@@sl$OBJ_0 r) (<= 0 (card@@sl$OBJ_0 r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$OBJ_0 r)) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (= (= (card@@sl$Addr_0 r) 0)"
    , "                      (= r empty-set@@sl$Addr_0))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 r) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (= (= (card@@sl$OBJ_0 r) 0)"
    , "                      (= r empty-set@@sl$OBJ_0))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 r) ))))"
    , "(assert (forall ( (r (set sl$Addr_0))"
    , "                  (r0 (set sl$Addr_0)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Addr_0)"
    , "                       (= (card@@sl$Addr_0 (union r r0))"
    , "                          (+ (card@@sl$Addr_0 r) (card@@sl$Addr_0 r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0))"
    , "                  (r0 (set sl$OBJ_0)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$OBJ_0)"
    , "                       (= (card@@sl$OBJ_0 (union r r0))"
    , "                          (+ (card@@sl$OBJ_0 r) (card@@sl$OBJ_0 r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 (union r r0)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (finite@@sl$Addr_0 s1)"
    , "                       (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (finite@@sl$OBJ_0 s1)"
    , "                       (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (and (finite@@sl$Addr_0 s1) (finite@@sl$Addr_0 s2))"
    , "                       (finite@@sl$Addr_0 (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (and (finite@@sl$OBJ_0 s1) (finite@@sl$OBJ_0 s2))"
    , "                       (finite@@sl$OBJ_0 (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (and (finite@@sl$Addr_0 s2)"
    , "                            (not (finite@@sl$Addr_0 s1)))"
    , "                       (not (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (and (finite@@sl$OBJ_0 s2) (not (finite@@sl$OBJ_0 s1)))"
    , "                       (not (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))"
    , "(assert (finite@@sl$Addr_0 empty-set@@sl$Addr_0))"
    , "(assert (finite@@sl$OBJ_0 empty-set@@sl$OBJ_0))"
    , "; default"
    , "(assert false)"
    , "(assert popL)"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m0/add:popL/SCH/m0:grd0"
    ]

result33 :: String
result33 = unlines
    [ "  o  m0/add:popL/SCH/m0:grd0"
    , "passed 1 / 1"
    ]

result34 :: String
result34 = unlines
    [ "; m1/read:LH/SKIP/EQL/ver"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(declare-datatypes (a1 a2 a3)"
    , "                   ( (Record-item-left-right (Record-item-left-right (@@field@@_item a1)"
    , "                                                                     (@@field@@_left a2)"
    , "                                                                     (@@field@@_right a3))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "(declare-sort sl$Addr_0 0)"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$OBJ_0 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(declare-sort sl$State 0)"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const LH sl$Addr_0)"
    , "(declare-const LH@prime sl$Addr_0)"
    , "(declare-const RH sl$Addr_0)"
    , "(declare-const RH@prime sl$Addr_0)"
    , "(declare-const dummy sl$Addr_0)"
    , "(declare-const free (set sl$Addr_0))"
    , "(declare-const free@prime (set sl$Addr_0))"
    , "(declare-const lh sl$Addr_0)"
    , "(declare-const lh@prime sl$Addr_0)"
    , "(declare-const popL Bool)"
    , "(declare-const popL@prime Bool)"
    , "(declare-const remL Bool)"
    , "(declare-const remL@prime Bool)"
    , "(declare-const resL sl$OBJ_0)"
    , "(declare-const resL@prime sl$OBJ_0)"
    , "(declare-const result sl$OBJ_0)"
    , "(declare-const result@prime sl$OBJ_0)"
    , "(declare-const rh sl$Addr_0)"
    , "(declare-const rh@prime sl$Addr_0)"
    , "(declare-const state sl$State)"
    , "(declare-const state@prime sl$State)"
    , "(declare-const ver Int)"
    , "(declare-const ver@prime Int)"
    , "(declare-const sl$bot sl$OBJ_0)"
    , "(declare-const sl$cEmpty sl$State)"
    , "(declare-const sl$cInit sl$State)"
    , "(declare-const sl$cNonEmpty sl$State)"
    , "(declare-const sl$link"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$link@prime"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$trash"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$trash@prime"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun card@@sl$Addr_0 ( (set sl$Addr_0) ) Int)"
    , "(declare-fun card@@sl$OBJ_0 ( (set sl$OBJ_0) ) Int)"
    , "(declare-fun card@@sl$State ( (set sl$State) ) Int)"
    , "(declare-fun dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (set sl$Addr_0))"
    , "(declare-fun dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (set sl$Addr_0)"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (set sl$Addr_0)"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ()"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun finite@@sl$Addr_0 ( (set sl$Addr_0) ) Bool)"
    , "(declare-fun finite@@sl$OBJ_0 ( (set sl$OBJ_0) ) Bool)"
    , "(declare-fun finite@@sl$State ( (set sl$State) ) Bool)"
    , "(declare-fun injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             Bool)"
    , "(declare-fun mk-set@@sl$Addr_0 (sl$Addr_0) (set sl$Addr_0))"
    , "(declare-fun mk-set@@sl$OBJ_0 (sl$OBJ_0) (set sl$OBJ_0))"
    , "(declare-fun mk-set@@sl$State (sl$State) (set sl$State))"
    , "(declare-fun ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(define-fun all@@sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              true ))"
    , "(define-fun all@@sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              true ))"
    , "(define-fun all@@sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              true ))"
    , "(define-fun compl@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0)) )"
    , "            (set sl$Addr_0)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0)) )"
    , "            (set sl$OBJ_0)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$State"
    , "            ( (s1 (set sl$State)) )"
    , "            (set sl$State)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@sl$Addr_0"
    , "            ( (x sl$Addr_0)"
    , "              (s1 (set sl$Addr_0)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$OBJ_0"
    , "            ( (x sl$OBJ_0)"
    , "              (s1 (set sl$OBJ_0)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$State"
    , "            ( (x sl$State)"
    , "              (s1 (set sl$State)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              false ))"
    , "(define-fun empty-set@@sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              false ))"
    , "(define-fun empty-set@@sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              false ))"
    , "(define-fun set-diff@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0))"
    , "              (s2 (set sl$Addr_0)) )"
    , "            (set sl$Addr_0)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0))"
    , "              (s2 (set sl$OBJ_0)) )"
    , "            (set sl$OBJ_0)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$State"
    , "            ( (s1 (set sl$State))"
    , "              (s2 (set sl$State)) )"
    , "            (set sl$State)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0))"
    , "              (s2 (set sl$Addr_0)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0))"
    , "              (s2 (set sl$OBJ_0)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$State"
    , "            ( (s1 (set sl$State))"
    , "              (s2 (set sl$State)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              true ))"
    , "(define-fun sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              true ))"
    , "(define-fun sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              true ))"
    , "(define-fun sl$OBJ@prime"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "(define-fun sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "(define-fun sl$Addr@prime"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))"
    , "(define-fun sl$Addr"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (=> (finite@@sl$Addr_0 r) (<= 0 (card@@sl$Addr_0 r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Addr_0 r)) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (=> (finite@@sl$OBJ_0 r) (<= 0 (card@@sl$OBJ_0 r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$OBJ_0 r)) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (=> (finite@@sl$State r) (<= 0 (card@@sl$State r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$State r)) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (= (= (card@@sl$Addr_0 r) 0)"
    , "                      (= r empty-set@@sl$Addr_0))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 r) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (= (= (card@@sl$OBJ_0 r) 0)"
    , "                      (= r empty-set@@sl$OBJ_0))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 r) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (= (= (card@@sl$State r) 0)"
    , "                      (= r empty-set@@sl$State))"
    , "                   :pattern"
    , "                   ( (card@@sl$State r) ))))"
    , "(assert (forall ( (x sl$Addr_0) )"
    , "                (! (= (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))"
    , "(assert (forall ( (x sl$OBJ_0) )"
    , "                (! (= (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))"
    , "(assert (forall ( (x sl$State) )"
    , "                (! (= (card@@sl$State (mk-set@@sl$State x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$State (mk-set@@sl$State x)) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (= (= (card@@sl$Addr_0 r) 1)"
    , "                      (exists ( (x sl$Addr_0) )"
    , "                              (and true (= r (mk-set@@sl$Addr_0 x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 r) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (= (= (card@@sl$OBJ_0 r) 1)"
    , "                      (exists ( (x sl$OBJ_0) )"
    , "                              (and true (= r (mk-set@@sl$OBJ_0 x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 r) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (= (= (card@@sl$State r) 1)"
    , "                      (exists ( (x sl$State) )"
    , "                              (and true (= r (mk-set@@sl$State x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$State r) ))))"
    , "(assert (forall ( (r (set sl$Addr_0))"
    , "                  (r0 (set sl$Addr_0)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Addr_0)"
    , "                       (= (card@@sl$Addr_0 (union r r0))"
    , "                          (+ (card@@sl$Addr_0 r) (card@@sl$Addr_0 r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0))"
    , "                  (r0 (set sl$OBJ_0)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$OBJ_0)"
    , "                       (= (card@@sl$OBJ_0 (union r r0))"
    , "                          (+ (card@@sl$OBJ_0 r) (card@@sl$OBJ_0 r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$State))"
    , "                  (r0 (set sl$State)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$State)"
    , "                       (= (card@@sl$State (union r r0))"
    , "                          (+ (card@@sl$State r) (card@@sl$State r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$State (union r r0)) ))))"
    , "(assert (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)"
    , "           empty-set@@sl$Addr_0))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                         empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                        empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "                                                                                                         f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "                                                                                                        f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2))"
    , "                      (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))"
    , "                      (intersect s1"
    , "                                 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))"
    , "                      (set-diff@@sl$Addr_0 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                                           s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))"
    , "(assert (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y sl$Addr_0) )"
    , "                (! (= (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) ))))"
    , "(assert (forall ( (x sl$OBJ_0)"
    , "                  (y sl$OBJ_0) )"
    , "                (! (= (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) ))))"
    , "(assert (forall ( (x sl$State)"
    , "                  (y sl$State) )"
    , "                (! (= (elem@@sl$State x (mk-set@@sl$State y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$State x (mk-set@@sl$State y)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (finite@@sl$Addr_0 s1)"
    , "                       (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (finite@@sl$OBJ_0 s1)"
    , "                       (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (finite@@sl$State s1)"
    , "                       (finite@@sl$State (set-diff@@sl$State s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (and (finite@@sl$Addr_0 s1) (finite@@sl$Addr_0 s2))"
    , "                       (finite@@sl$Addr_0 (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (and (finite@@sl$OBJ_0 s1) (finite@@sl$OBJ_0 s2))"
    , "                       (finite@@sl$OBJ_0 (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (and (finite@@sl$State s1) (finite@@sl$State s2))"
    , "                       (finite@@sl$State (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (and (finite@@sl$Addr_0 s2)"
    , "                            (not (finite@@sl$Addr_0 s1)))"
    , "                       (not (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (and (finite@@sl$OBJ_0 s2) (not (finite@@sl$OBJ_0 s1)))"
    , "                       (not (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (and (finite@@sl$State s2) (not (finite@@sl$State s1)))"
    , "                       (not (finite@@sl$State (set-diff@@sl$State s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))"
    , "(assert (forall ( (x sl$Addr_0) )"
    , "                (! (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))"
    , "(assert (forall ( (x sl$OBJ_0) )"
    , "                (! (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))"
    , "(assert (forall ( (x sl$State) )"
    , "                (! (finite@@sl$State (mk-set@@sl$State x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (mk-set@@sl$State x)) ))))"
    , "(assert (finite@@sl$Addr_0 empty-set@@sl$Addr_0))"
    , "(assert (finite@@sl$OBJ_0 empty-set@@sl$OBJ_0))"
    , "(assert (finite@@sl$State empty-set@@sl$State))"
    , "; SKIP:LH"
    , "(assert (= LH@prime LH))"
    , "; SKIP:RH"
    , "(assert (= RH@prime RH))"
    , "; SKIP:\\link"
    , "(assert (= sl$link@prime sl$link))"
    , "; SKIP:\\trash"
    , "(assert (= sl$trash@prime sl$trash))"
    , "; SKIP:free"
    , "(assert (= free@prime free))"
    , "; SKIP:popL"
    , "(assert (= popL@prime popL))"
    , "; SKIP:remL"
    , "(assert (= remL@prime remL))"
    , "; SKIP:resL"
    , "(assert (= resL@prime resL))"
    , "; SKIP:result"
    , "(assert (= result@prime result))"
    , "; SKIP:rh"
    , "(assert (= rh@prime rh))"
    , "; m0:inv0"
    , "(assert (subset free sl$Addr))"
    , "; m0:thm0:ASM"
    , "(assert (elem@@sl$Addr_0 LH"
    , "                         (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link)"
    , "                                (mk-set@@sl$Addr_0 dummy))))"
    , "; m0:thm1:ASM"
    , "(assert (elem@@sl$Addr_0 RH"
    , "                         (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link)"
    , "                                (mk-set@@sl$Addr_0 dummy))))"
    , "; m1:act0"
    , "(assert (= lh@prime LH))"
    , "; m1:act1"
    , "(assert (= state@prime"
    , "           (ite (= LH dummy) sl$cEmpty sl$cNonEmpty)))"
    , "; m1:act2"
    , "(assert (= ver@prime (ite (= LH dummy) (+ ver 1) ver)))"
    , "; m1:sch0"
    , "(assert (= state sl$cInit))"
    , "; m1:sch1"
    , "(assert (not (= LH dummy)))"
    , "(assert (not (= ver@prime ver)))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/read:LH/SKIP/EQL/ver"
    ]
 
result35 :: String 
result35 = unlines
    [ "  o  m1/hdl:popL:more/C_SCH/delay/0/prog/m1:prog0/rhs/m1:sch0"
    , "passed 1 / 1"
    ]


result37 :: String
result37 = unlines
    [ "; m1/hdl:popL:more/GRD/str/m0:sch0"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(declare-datatypes (a1)"
    , "                   ( (Record-item (Record-item (@@field@@_item a1))) ))"
    , "(declare-datatypes (a1 a2 a3)"
    , "                   ( (Record-item-left-right (Record-item-left-right (@@field@@_item a1)"
    , "                                                                     (@@field@@_left a2)"
    , "                                                                     (@@field@@_right a3))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "(declare-sort sl$Addr_0 0)"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$OBJ_0 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(declare-sort sl$State 0)"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const LH sl$Addr_0)"
    , "(declare-const LH@prime sl$Addr_0)"
    , "(declare-const RH sl$Addr_0)"
    , "(declare-const RH@prime sl$Addr_0)"
    , "(declare-const dummy sl$Addr_0)"
    , "(declare-const free (set sl$Addr_0))"
    , "(declare-const free@prime (set sl$Addr_0))"
    , "(declare-const lh sl$Addr_0)"
    , "(declare-const lh@prime sl$Addr_0)"
    , "(declare-const popL Bool)"
    , "(declare-const popL@prime Bool)"
    , "(declare-const remL Bool)"
    , "(declare-const remL@prime Bool)"
    , "(declare-const resL sl$OBJ_0)"
    , "(declare-const resL@prime sl$OBJ_0)"
    , "(declare-const result sl$OBJ_0)"
    , "(declare-const result@prime sl$OBJ_0)"
    , "(declare-const rh sl$Addr_0)"
    , "(declare-const rh@prime sl$Addr_0)"
    , "(declare-const state sl$State)"
    , "(declare-const state@prime sl$State)"
    , "(declare-const v Int)"
    , "(declare-const ver Int)"
    , "(declare-const ver@prime Int)"
    , "(declare-const sl$bot sl$OBJ_0)"
    , "(declare-const sl$cBot sl$State)"
    , "(declare-const sl$cEmpty sl$State)"
    , "(declare-const sl$cInit sl$State)"
    , "(declare-const sl$cNonEmpty sl$State)"
    , "(declare-const sl$cPopped sl$State)"
    , "(declare-const sl$link"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$link@prime"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$trash"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$trash@prime"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "               sl$Addr_0 )"
    , "             (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "(declare-fun card@@sl$Addr_0 ( (set sl$Addr_0) ) Int)"
    , "(declare-fun card@@sl$OBJ_0 ( (set sl$OBJ_0) ) Int)"
    , "(declare-fun card@@sl$State ( (set sl$State) ) Int)"
    , "(declare-fun card@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0)) )"
    , "             Int)"
    , "(declare-fun const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (Record-item sl$OBJ_0) )"
    , "             (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "(declare-fun dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (set sl$Addr_0))"
    , "(declare-fun dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (set sl$Addr_0)"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (set sl$Addr_0)"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ()"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun finite@@sl$Addr_0 ( (set sl$Addr_0) ) Bool)"
    , "(declare-fun finite@@sl$OBJ_0 ( (set sl$OBJ_0) ) Bool)"
    , "(declare-fun finite@@sl$State ( (set sl$State) ) Bool)"
    , "(declare-fun finite@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0)) )"
    , "             Bool)"
    , "(declare-fun ident@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ()"
    , "             (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "(declare-fun injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             Bool)"
    , "(declare-fun mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             (sl$Addr_0 (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun mk-set@@sl$Addr_0 (sl$Addr_0) (set sl$Addr_0))"
    , "(declare-fun mk-set@@sl$OBJ_0 (sl$OBJ_0) (set sl$OBJ_0))"
    , "(declare-fun mk-set@@sl$State (sl$State) (set sl$State))"
    , "(declare-fun mk-set@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (Record-item sl$OBJ_0) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(declare-fun ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0))"
    , "               (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(declare-fun @@lambda@@_0"
    , "             ( (set sl$OBJ_0) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(define-fun all@@sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              true ))"
    , "(define-fun all@@sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              true ))"
    , "(define-fun all@@sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              true ))"
    , "(define-fun all@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (as const (set (Record-item sl$OBJ_0)))"
    , "              true ))"
    , "(define-fun compl@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0)) )"
    , "            (set sl$Addr_0)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0)) )"
    , "            (set sl$OBJ_0)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$State"
    , "            ( (s1 (set sl$State)) )"
    , "            (set sl$State)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0))) )"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@sl$Addr_0"
    , "            ( (x sl$Addr_0)"
    , "              (s1 (set sl$Addr_0)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$OBJ_0"
    , "            ( (x sl$OBJ_0)"
    , "              (s1 (set sl$OBJ_0)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$State"
    , "            ( (x sl$State)"
    , "              (s1 (set sl$State)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (x (Record-item sl$OBJ_0))"
    , "              (s1 (set (Record-item sl$OBJ_0))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              false ))"
    , "(define-fun empty-set@@sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              false ))"
    , "(define-fun empty-set@@sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              false ))"
    , "(define-fun empty-set@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (as const (set (Record-item sl$OBJ_0)))"
    , "              false ))"
    , "(define-fun set-diff@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0))"
    , "              (s2 (set sl$Addr_0)) )"
    , "            (set sl$Addr_0)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0))"
    , "              (s2 (set sl$OBJ_0)) )"
    , "            (set sl$OBJ_0)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$State"
    , "            ( (s1 (set sl$State))"
    , "              (s2 (set sl$State)) )"
    , "            (set sl$State)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0)))"
    , "              (s2 (set (Record-item sl$OBJ_0))) )"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0))"
    , "              (s2 (set sl$Addr_0)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0))"
    , "              (s2 (set sl$OBJ_0)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$State"
    , "            ( (s1 (set sl$State))"
    , "              (s2 (set sl$State)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0)))"
    , "              (s2 (set (Record-item sl$OBJ_0))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              true ))"
    , "(define-fun sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              true ))"
    , "(define-fun sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              true ))"
    , "(define-fun sl$OBJ@prime"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "(define-fun sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "(define-fun sl$Node@prime"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close (@@lambda@@_0 (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "                                                                                     ident@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(define-fun sl$Node"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close (@@lambda@@_0 (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "                                                                                     ident@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(define-fun sl$Addr@prime"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))"
    , "(define-fun sl$Addr"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (finite@Open@@Record-item@@sl$OBJ_0@Close r)"
    , "                       (<= 0 (card@Open@@Record-item@@sl$OBJ_0@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@Record-item@@sl$OBJ_0@Close r)) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (=> (finite@@sl$Addr_0 r) (<= 0 (card@@sl$Addr_0 r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Addr_0 r)) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (=> (finite@@sl$OBJ_0 r) (<= 0 (card@@sl$OBJ_0 r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$OBJ_0 r)) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (=> (finite@@sl$State r) (<= 0 (card@@sl$State r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$State r)) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (= (card@Open@@Record-item@@sl$OBJ_0@Close r) 0)"
    , "                      (= r empty-set@Open@@Record-item@@sl$OBJ_0@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close r) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (= (= (card@@sl$Addr_0 r) 0)"
    , "                      (= r empty-set@@sl$Addr_0))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 r) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (= (= (card@@sl$OBJ_0 r) 0)"
    , "                      (= r empty-set@@sl$OBJ_0))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 r) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (= (= (card@@sl$State r) 0)"
    , "                      (= r empty-set@@sl$State))"
    , "                   :pattern"
    , "                   ( (card@@sl$State r) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (= (card@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)) ))))"
    , "(assert (forall ( (x sl$Addr_0) )"
    , "                (! (= (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))"
    , "(assert (forall ( (x sl$OBJ_0) )"
    , "                (! (= (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))"
    , "(assert (forall ( (x sl$State) )"
    , "                (! (= (card@@sl$State (mk-set@@sl$State x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$State (mk-set@@sl$State x)) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (= (card@Open@@Record-item@@sl$OBJ_0@Close r) 1)"
    , "                      (exists ( (x (Record-item sl$OBJ_0)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close r) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (= (= (card@@sl$Addr_0 r) 1)"
    , "                      (exists ( (x sl$Addr_0) )"
    , "                              (and true (= r (mk-set@@sl$Addr_0 x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 r) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (= (= (card@@sl$OBJ_0 r) 1)"
    , "                      (exists ( (x sl$OBJ_0) )"
    , "                              (and true (= r (mk-set@@sl$OBJ_0 x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 r) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (= (= (card@@sl$State r) 1)"
    , "                      (exists ( (x sl$State) )"
    , "                              (and true (= r (mk-set@@sl$State x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$State r) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0)))"
    , "                  (r0 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@Record-item@@sl$OBJ_0@Close)"
    , "                       (= (card@Open@@Record-item@@sl$OBJ_0@Close (union r r0))"
    , "                          (+ (card@Open@@Record-item@@sl$OBJ_0@Close r)"
    , "                             (card@Open@@Record-item@@sl$OBJ_0@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Addr_0))"
    , "                  (r0 (set sl$Addr_0)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Addr_0)"
    , "                       (= (card@@sl$Addr_0 (union r r0))"
    , "                          (+ (card@@sl$Addr_0 r) (card@@sl$Addr_0 r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0))"
    , "                  (r0 (set sl$OBJ_0)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$OBJ_0)"
    , "                       (= (card@@sl$OBJ_0 (union r r0))"
    , "                          (+ (card@@sl$OBJ_0 r) (card@@sl$OBJ_0 r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$State))"
    , "                  (r0 (set sl$State)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$State)"
    , "                       (= (card@@sl$State (union r r0))"
    , "                          (+ (card@@sl$State r) (card@@sl$State r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$State (union r r0)) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (select (const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                              y)"
    , "                      x)"
    , "                   :pattern"
    , "                   ( (select (const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                             y) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (= (select ident@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                      x)"
    , "                   :pattern"
    , "                   ( (select ident@Open@@Record-item@@sl$OBJ_0@Close x) ))))"
    , "(assert (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)"
    , "           empty-set@@sl$Addr_0))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                         empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                        empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "                                                                                                         f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "                                                                                                        f1) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                      (mk-set@@sl$Addr_0 x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 x"
    , "                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (and (elem@@sl$Addr_0 x"
    , "                                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                            (not (elem@@sl$Addr_0 x"
    , "                                                  (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2))))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)"
    , "                                                                                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (and (elem@@sl$Addr_0 x s1)"
    , "                            (elem@@sl$Addr_0 x"
    , "                                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 x"
    , "                                        (set-diff@@sl$Addr_0 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                                                             s1))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2))"
    , "                      (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))"
    , "                      (intersect s1"
    , "                                 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))"
    , "                      (set-diff@@sl$Addr_0 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                                           s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (and (elem@@sl$Addr_0 x"
    , "                                            (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                           (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                              y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr_0 x"
    , "                                      (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                     (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (x2 sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                                  (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                               x2)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                             (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                              (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                             (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                      (forall ( (x sl$Addr_0)"
    , "                                (x2 sl$Addr_0) )"
    , "                              (=> (and (elem@@sl$Addr_0 x"
    , "                                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                                       (elem@@sl$Addr_0 x2"
    , "                                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                                  (=> (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                                         (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1) ))))"
    , "(assert (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close x (mk-set@Open@@Record-item@@sl$OBJ_0@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close x (mk-set@Open@@Record-item@@sl$OBJ_0@Close y)) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y sl$Addr_0) )"
    , "                (! (= (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) ))))"
    , "(assert (forall ( (x sl$OBJ_0)"
    , "                  (y sl$OBJ_0) )"
    , "                (! (= (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) ))))"
    , "(assert (forall ( (x sl$State)"
    , "                  (y sl$State) )"
    , "                (! (= (elem@@sl$State x (mk-set@@sl$State y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$State x (mk-set@@sl$State y)) ))))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0)))"
    , "                  (term (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close y"
    , "                                                              (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term))"
    , "                      (exists ( (x (Record-item sl$OBJ_0)) )"
    , "                              (and (elem@Open@@Record-item@@sl$OBJ_0@Close x r1)"
    , "                                   (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close y"
    , "                                                             (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)) ))))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0)))"
    , "                  (term (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (= (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)"
    , "                         (mk-set@Open@@Record-item@@sl$OBJ_0@Close y))"
    , "                      (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                              (=> (elem@Open@@Record-item@@sl$OBJ_0@Close x r1)"
    , "                                  (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)"
    , "                     (mk-set@Open@@Record-item@@sl$OBJ_0@Close y) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (finite@Open@@Record-item@@sl$OBJ_0@Close s1)"
    , "                       (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (finite@@sl$Addr_0 s1)"
    , "                       (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (finite@@sl$OBJ_0 s1)"
    , "                       (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (finite@@sl$State s1)"
    , "                       (finite@@sl$State (set-diff@@sl$State s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (and (finite@Open@@Record-item@@sl$OBJ_0@Close s1)"
    , "                            (finite@Open@@Record-item@@sl$OBJ_0@Close s2))"
    , "                       (finite@Open@@Record-item@@sl$OBJ_0@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (and (finite@@sl$Addr_0 s1) (finite@@sl$Addr_0 s2))"
    , "                       (finite@@sl$Addr_0 (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (and (finite@@sl$OBJ_0 s1) (finite@@sl$OBJ_0 s2))"
    , "                       (finite@@sl$OBJ_0 (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (and (finite@@sl$State s1) (finite@@sl$State s2))"
    , "                       (finite@@sl$State (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (and (finite@Open@@Record-item@@sl$OBJ_0@Close s2)"
    , "                            (not (finite@Open@@Record-item@@sl$OBJ_0@Close s1)))"
    , "                       (not (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (and (finite@@sl$Addr_0 s2)"
    , "                            (not (finite@@sl$Addr_0 s1)))"
    , "                       (not (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (and (finite@@sl$OBJ_0 s2) (not (finite@@sl$OBJ_0 s1)))"
    , "                       (not (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (and (finite@@sl$State s2) (not (finite@@sl$State s1)))"
    , "                       (not (finite@@sl$State (set-diff@@sl$State s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (finite@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)) ))))"
    , "(assert (forall ( (x sl$Addr_0) )"
    , "                (! (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))"
    , "(assert (forall ( (x sl$OBJ_0) )"
    , "                (! (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))"
    , "(assert (forall ( (x sl$State) )"
    , "                (! (finite@@sl$State (mk-set@@sl$State x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (mk-set@@sl$State x)) ))))"
    , "(assert (finite@Open@@Record-item@@sl$OBJ_0@Close empty-set@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(assert (finite@@sl$Addr_0 empty-set@@sl$Addr_0))"
    , "(assert (finite@@sl$OBJ_0 empty-set@@sl$OBJ_0))"
    , "(assert (finite@@sl$State empty-set@@sl$State))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 ident@Open@@Record-item@@sl$OBJ_0@Close)"
    , "                      r1)"
    , "                   :pattern"
    , "                   ( (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 ident@Open@@Record-item@@sl$OBJ_0@Close) ))))"
    , "(assert (forall ( (@@fv@@_0 (set sl$OBJ_0))"
    , "                  (@@bv@@_0 (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close @@bv@@_0 (@@lambda@@_0 @@fv@@_0))"
    , "                      (elem@@sl$OBJ_0 (@@field@@_item @@bv@@_0) @@fv@@_0))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close @@bv@@_0 (@@lambda@@_0 @@fv@@_0)) ))))"
    , "; m0:asm0"
    , "(assert (not (= sl$cInit sl$cBot)))"
    , "; m0:asm1"
    , "(assert (not (= sl$cInit sl$cEmpty)))"
    , "; m0:asm2"
    , "(assert (not (= sl$cInit sl$cNonEmpty)))"
    , "; m0:asm3"
    , "(assert (not (= sl$cInit sl$cPopped)))"
    , "; m0:asm4"
    , "(assert (not (= sl$cBot sl$cEmpty)))"
    , "; m0:asm5"
    , "(assert (not (= sl$cBot sl$cNonEmpty)))"
    , "; m0:asm6"
    , "(assert (not (= sl$cBot sl$cPopped)))"
    , "; m0:asm7"
    , "(assert (not (= sl$cEmpty sl$cNonEmpty)))"
    , "; m0:asm8"
    , "(assert (not (= sl$cEmpty sl$cPopped)))"
    , "; m0:asm9"
    , "(assert (not (= sl$cNonEmpty sl$cPopped)))"
    , "; m0:inv0"
    , "(assert (subset free sl$Addr))"
    , "; m0:sch2"
    , "(assert (not (= LH dummy)))"
    , "; m0:sch3"
    , "(assert (not (= LH RH)))"
    , "; m0:thm0:ASM"
    , "(assert (elem@@sl$Addr_0 LH"
    , "                         (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link)"
    , "                                (mk-set@@sl$Addr_0 dummy))))"
    , "; m0:thm1:ASM"
    , "(assert (elem@@sl$Addr_0 RH"
    , "                         (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link)"
    , "                                (mk-set@@sl$Addr_0 dummy))))"
    , "; m0:thm2:ASM"
    , "(assert (not (elem@@sl$Addr_0 LH"
    , "                              (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))))"
    , "; m0:thm3:ASM"
    , "(assert (not (elem@@sl$Addr_0 RH"
    , "                              (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))))"
    , "; m1:inv0"
    , "(assert (= (= state sl$cBot) (and (not popL) (not remL))))"
    , "; m1:inv3"
    , "(assert (= popL"
    , "           (elem@@sl$State state"
    , "                           (union (mk-set@@sl$State sl$cInit)"
    , "                                  (mk-set@@sl$State sl$cNonEmpty)))))"
    , "; m1:inv4"
    , "(assert (=> (= state sl$cPopped)"
    , "            (and remL"
    , "                 (elem@@sl$Addr_0 lh"
    , "                                  (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))"
    , "                 (= (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash lh))"
    , "                    resL))))"
    , "; m1:inv5"
    , "(assert (= remL"
    , "           (elem@@sl$State state"
    , "                           (union (mk-set@@sl$State sl$cPopped)"
    , "                                  (mk-set@@sl$State sl$cEmpty)))))"
    , "; m1:inv6"
    , "(assert (= (= state sl$cEmpty) (and remL (= resL sl$bot))))"
    , "; m1:inv7"
    , "(assert (forall ( (p sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 p"
    , "                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link))"
    , "                       (elem@@sl$OBJ_0 (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link p))"
    , "                                       sl$OBJ))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ_0 (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link p))"
    , "                                     sl$OBJ) ))))"
    , "; m1:sch0"
    , "(assert (= state sl$cNonEmpty))"
    , "; m1:sch1"
    , "(assert (= lh LH))"
    , "; v"
    , "(assert (= v ver))"
    , "(assert (not (= v ver)))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/hdl:popL:more/GRD/str/m0:sch0"
    ]

result39 :: String
result39 = unlines
    [ "; m1/hdl:popL:more/WFIS/v"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(declare-datatypes (a1)"
    , "                   ( (Record-item (Record-item (@@field@@_item a1))) ))"
    , "(declare-datatypes (a1 a2 a3)"
    , "                   ( (Record-item-left-right (Record-item-left-right (@@field@@_item a1)"
    , "                                                                     (@@field@@_left a2)"
    , "                                                                     (@@field@@_right a3))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "(declare-sort sl$Addr_0 0)"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$OBJ_0 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(declare-sort sl$State 0)"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const LH sl$Addr_0)"
    , "(declare-const LH@prime sl$Addr_0)"
    , "(declare-const RH sl$Addr_0)"
    , "(declare-const RH@prime sl$Addr_0)"
    , "(declare-const dummy sl$Addr_0)"
    , "(declare-const free (set sl$Addr_0))"
    , "(declare-const free@prime (set sl$Addr_0))"
    , "(declare-const lh sl$Addr_0)"
    , "(declare-const lh@prime sl$Addr_0)"
    , "(declare-const popL Bool)"
    , "(declare-const popL@prime Bool)"
    , "(declare-const remL Bool)"
    , "(declare-const remL@prime Bool)"
    , "(declare-const resL sl$OBJ_0)"
    , "(declare-const resL@prime sl$OBJ_0)"
    , "(declare-const result sl$OBJ_0)"
    , "(declare-const result@prime sl$OBJ_0)"
    , "(declare-const rh sl$Addr_0)"
    , "(declare-const rh@prime sl$Addr_0)"
    , "(declare-const state sl$State)"
    , "(declare-const state@prime sl$State)"
    , "(declare-const ver Int)"
    , "(declare-const ver@prime Int)"
    , "(declare-const sl$bot sl$OBJ_0)"
    , "(declare-const sl$cBot sl$State)"
    , "(declare-const sl$cEmpty sl$State)"
    , "(declare-const sl$cInit sl$State)"
    , "(declare-const sl$cNonEmpty sl$State)"
    , "(declare-const sl$cPopped sl$State)"
    , "(declare-const sl$link"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$link@prime"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$trash"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$trash@prime"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "               sl$Addr_0 )"
    , "             (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "(declare-fun card@@sl$Addr_0 ( (set sl$Addr_0) ) Int)"
    , "(declare-fun card@@sl$OBJ_0 ( (set sl$OBJ_0) ) Int)"
    , "(declare-fun card@@sl$State ( (set sl$State) ) Int)"
    , "(declare-fun card@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0)) )"
    , "             Int)"
    , "(declare-fun const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (Record-item sl$OBJ_0) )"
    , "             (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "(declare-fun dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (set sl$Addr_0))"
    , "(declare-fun dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (set sl$Addr_0)"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (set sl$Addr_0)"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ()"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun finite@@sl$Addr_0 ( (set sl$Addr_0) ) Bool)"
    , "(declare-fun finite@@sl$OBJ_0 ( (set sl$OBJ_0) ) Bool)"
    , "(declare-fun finite@@sl$State ( (set sl$State) ) Bool)"
    , "(declare-fun finite@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0)) )"
    , "             Bool)"
    , "(declare-fun ident@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ()"
    , "             (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "(declare-fun injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             Bool)"
    , "(declare-fun mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             (sl$Addr_0 (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun mk-set@@sl$Addr_0 (sl$Addr_0) (set sl$Addr_0))"
    , "(declare-fun mk-set@@sl$OBJ_0 (sl$OBJ_0) (set sl$OBJ_0))"
    , "(declare-fun mk-set@@sl$State (sl$State) (set sl$State))"
    , "(declare-fun mk-set@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (Record-item sl$OBJ_0) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(declare-fun ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0))"
    , "               (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(declare-fun @@lambda@@_0"
    , "             ( (set sl$OBJ_0) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(define-fun all@@sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              true ))"
    , "(define-fun all@@sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              true ))"
    , "(define-fun all@@sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              true ))"
    , "(define-fun all@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (as const (set (Record-item sl$OBJ_0)))"
    , "              true ))"
    , "(define-fun compl@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0)) )"
    , "            (set sl$Addr_0)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0)) )"
    , "            (set sl$OBJ_0)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$State"
    , "            ( (s1 (set sl$State)) )"
    , "            (set sl$State)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0))) )"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@sl$Addr_0"
    , "            ( (x sl$Addr_0)"
    , "              (s1 (set sl$Addr_0)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$OBJ_0"
    , "            ( (x sl$OBJ_0)"
    , "              (s1 (set sl$OBJ_0)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$State"
    , "            ( (x sl$State)"
    , "              (s1 (set sl$State)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (x (Record-item sl$OBJ_0))"
    , "              (s1 (set (Record-item sl$OBJ_0))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              false ))"
    , "(define-fun empty-set@@sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              false ))"
    , "(define-fun empty-set@@sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              false ))"
    , "(define-fun empty-set@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (as const (set (Record-item sl$OBJ_0)))"
    , "              false ))"
    , "(define-fun set-diff@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0))"
    , "              (s2 (set sl$Addr_0)) )"
    , "            (set sl$Addr_0)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0))"
    , "              (s2 (set sl$OBJ_0)) )"
    , "            (set sl$OBJ_0)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$State"
    , "            ( (s1 (set sl$State))"
    , "              (s2 (set sl$State)) )"
    , "            (set sl$State)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0)))"
    , "              (s2 (set (Record-item sl$OBJ_0))) )"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0))"
    , "              (s2 (set sl$Addr_0)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0))"
    , "              (s2 (set sl$OBJ_0)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$State"
    , "            ( (s1 (set sl$State))"
    , "              (s2 (set sl$State)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0)))"
    , "              (s2 (set (Record-item sl$OBJ_0))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              true ))"
    , "(define-fun sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              true ))"
    , "(define-fun sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              true ))"
    , "(define-fun sl$OBJ@prime"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "(define-fun sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "(define-fun sl$Node@prime"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close (@@lambda@@_0 (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "                                                                                     ident@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(define-fun sl$Node"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close (@@lambda@@_0 (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "                                                                                     ident@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(define-fun sl$Addr@prime"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))"
    , "(define-fun sl$Addr"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (finite@Open@@Record-item@@sl$OBJ_0@Close r)"
    , "                       (<= 0 (card@Open@@Record-item@@sl$OBJ_0@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@Record-item@@sl$OBJ_0@Close r)) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (=> (finite@@sl$Addr_0 r) (<= 0 (card@@sl$Addr_0 r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Addr_0 r)) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (=> (finite@@sl$OBJ_0 r) (<= 0 (card@@sl$OBJ_0 r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$OBJ_0 r)) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (=> (finite@@sl$State r) (<= 0 (card@@sl$State r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$State r)) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (= (card@Open@@Record-item@@sl$OBJ_0@Close r) 0)"
    , "                      (= r empty-set@Open@@Record-item@@sl$OBJ_0@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close r) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (= (= (card@@sl$Addr_0 r) 0)"
    , "                      (= r empty-set@@sl$Addr_0))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 r) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (= (= (card@@sl$OBJ_0 r) 0)"
    , "                      (= r empty-set@@sl$OBJ_0))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 r) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (= (= (card@@sl$State r) 0)"
    , "                      (= r empty-set@@sl$State))"
    , "                   :pattern"
    , "                   ( (card@@sl$State r) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (= (card@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)) ))))"
    , "(assert (forall ( (x sl$Addr_0) )"
    , "                (! (= (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))"
    , "(assert (forall ( (x sl$OBJ_0) )"
    , "                (! (= (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))"
    , "(assert (forall ( (x sl$State) )"
    , "                (! (= (card@@sl$State (mk-set@@sl$State x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$State (mk-set@@sl$State x)) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (= (card@Open@@Record-item@@sl$OBJ_0@Close r) 1)"
    , "                      (exists ( (x (Record-item sl$OBJ_0)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close r) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (= (= (card@@sl$Addr_0 r) 1)"
    , "                      (exists ( (x sl$Addr_0) )"
    , "                              (and true (= r (mk-set@@sl$Addr_0 x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 r) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (= (= (card@@sl$OBJ_0 r) 1)"
    , "                      (exists ( (x sl$OBJ_0) )"
    , "                              (and true (= r (mk-set@@sl$OBJ_0 x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 r) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (= (= (card@@sl$State r) 1)"
    , "                      (exists ( (x sl$State) )"
    , "                              (and true (= r (mk-set@@sl$State x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$State r) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0)))"
    , "                  (r0 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@Record-item@@sl$OBJ_0@Close)"
    , "                       (= (card@Open@@Record-item@@sl$OBJ_0@Close (union r r0))"
    , "                          (+ (card@Open@@Record-item@@sl$OBJ_0@Close r)"
    , "                             (card@Open@@Record-item@@sl$OBJ_0@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Addr_0))"
    , "                  (r0 (set sl$Addr_0)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Addr_0)"
    , "                       (= (card@@sl$Addr_0 (union r r0))"
    , "                          (+ (card@@sl$Addr_0 r) (card@@sl$Addr_0 r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0))"
    , "                  (r0 (set sl$OBJ_0)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$OBJ_0)"
    , "                       (= (card@@sl$OBJ_0 (union r r0))"
    , "                          (+ (card@@sl$OBJ_0 r) (card@@sl$OBJ_0 r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$State))"
    , "                  (r0 (set sl$State)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$State)"
    , "                       (= (card@@sl$State (union r r0))"
    , "                          (+ (card@@sl$State r) (card@@sl$State r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$State (union r r0)) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (select (const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                              y)"
    , "                      x)"
    , "                   :pattern"
    , "                   ( (select (const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                             y) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (= (select ident@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                      x)"
    , "                   :pattern"
    , "                   ( (select ident@Open@@Record-item@@sl$OBJ_0@Close x) ))))"
    , "(assert (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)"
    , "           empty-set@@sl$Addr_0))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                         empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                        empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "                                                                                                         f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "                                                                                                        f1) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                      (mk-set@@sl$Addr_0 x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 x"
    , "                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (and (elem@@sl$Addr_0 x"
    , "                                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                            (not (elem@@sl$Addr_0 x"
    , "                                                  (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2))))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)"
    , "                                                                                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (and (elem@@sl$Addr_0 x s1)"
    , "                            (elem@@sl$Addr_0 x"
    , "                                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 x"
    , "                                        (set-diff@@sl$Addr_0 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                                                             s1))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2))"
    , "                      (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))"
    , "                      (intersect s1"
    , "                                 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))"
    , "                      (set-diff@@sl$Addr_0 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                                           s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (and (elem@@sl$Addr_0 x"
    , "                                            (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                           (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                              y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr_0 x"
    , "                                      (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                     (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (x2 sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                                  (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                               x2)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                             (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                              (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                             (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                      (forall ( (x sl$Addr_0)"
    , "                                (x2 sl$Addr_0) )"
    , "                              (=> (and (elem@@sl$Addr_0 x"
    , "                                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                                       (elem@@sl$Addr_0 x2"
    , "                                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                                  (=> (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                                         (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1) ))))"
    , "(assert (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close x (mk-set@Open@@Record-item@@sl$OBJ_0@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close x (mk-set@Open@@Record-item@@sl$OBJ_0@Close y)) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y sl$Addr_0) )"
    , "                (! (= (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) ))))"
    , "(assert (forall ( (x sl$OBJ_0)"
    , "                  (y sl$OBJ_0) )"
    , "                (! (= (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) ))))"
    , "(assert (forall ( (x sl$State)"
    , "                  (y sl$State) )"
    , "                (! (= (elem@@sl$State x (mk-set@@sl$State y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$State x (mk-set@@sl$State y)) ))))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0)))"
    , "                  (term (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close y"
    , "                                                              (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term))"
    , "                      (exists ( (x (Record-item sl$OBJ_0)) )"
    , "                              (and (elem@Open@@Record-item@@sl$OBJ_0@Close x r1)"
    , "                                   (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close y"
    , "                                                             (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)) ))))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0)))"
    , "                  (term (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (= (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)"
    , "                         (mk-set@Open@@Record-item@@sl$OBJ_0@Close y))"
    , "                      (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                              (=> (elem@Open@@Record-item@@sl$OBJ_0@Close x r1)"
    , "                                  (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)"
    , "                     (mk-set@Open@@Record-item@@sl$OBJ_0@Close y) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (finite@Open@@Record-item@@sl$OBJ_0@Close s1)"
    , "                       (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (finite@@sl$Addr_0 s1)"
    , "                       (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (finite@@sl$OBJ_0 s1)"
    , "                       (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (finite@@sl$State s1)"
    , "                       (finite@@sl$State (set-diff@@sl$State s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (and (finite@Open@@Record-item@@sl$OBJ_0@Close s1)"
    , "                            (finite@Open@@Record-item@@sl$OBJ_0@Close s2))"
    , "                       (finite@Open@@Record-item@@sl$OBJ_0@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (and (finite@@sl$Addr_0 s1) (finite@@sl$Addr_0 s2))"
    , "                       (finite@@sl$Addr_0 (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (and (finite@@sl$OBJ_0 s1) (finite@@sl$OBJ_0 s2))"
    , "                       (finite@@sl$OBJ_0 (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (and (finite@@sl$State s1) (finite@@sl$State s2))"
    , "                       (finite@@sl$State (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (and (finite@Open@@Record-item@@sl$OBJ_0@Close s2)"
    , "                            (not (finite@Open@@Record-item@@sl$OBJ_0@Close s1)))"
    , "                       (not (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (and (finite@@sl$Addr_0 s2)"
    , "                            (not (finite@@sl$Addr_0 s1)))"
    , "                       (not (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (and (finite@@sl$OBJ_0 s2) (not (finite@@sl$OBJ_0 s1)))"
    , "                       (not (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (and (finite@@sl$State s2) (not (finite@@sl$State s1)))"
    , "                       (not (finite@@sl$State (set-diff@@sl$State s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (finite@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)) ))))"
    , "(assert (forall ( (x sl$Addr_0) )"
    , "                (! (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))"
    , "(assert (forall ( (x sl$OBJ_0) )"
    , "                (! (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))"
    , "(assert (forall ( (x sl$State) )"
    , "                (! (finite@@sl$State (mk-set@@sl$State x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (mk-set@@sl$State x)) ))))"
    , "(assert (finite@Open@@Record-item@@sl$OBJ_0@Close empty-set@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(assert (finite@@sl$Addr_0 empty-set@@sl$Addr_0))"
    , "(assert (finite@@sl$OBJ_0 empty-set@@sl$OBJ_0))"
    , "(assert (finite@@sl$State empty-set@@sl$State))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 ident@Open@@Record-item@@sl$OBJ_0@Close)"
    , "                      r1)"
    , "                   :pattern"
    , "                   ( (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 ident@Open@@Record-item@@sl$OBJ_0@Close) ))))"
    , "(assert (forall ( (@@fv@@_0 (set sl$OBJ_0))"
    , "                  (@@bv@@_0 (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close @@bv@@_0 (@@lambda@@_0 @@fv@@_0))"
    , "                      (elem@@sl$OBJ_0 (@@field@@_item @@bv@@_0) @@fv@@_0))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close @@bv@@_0 (@@lambda@@_0 @@fv@@_0)) ))))"
    , "(assert (not (exists ( (v Int) ) (and true (= v ver)))))"
    , "; SKIP:RH"
    , "(assert (= RH@prime RH))"
    , "; SKIP:free"
    , "(assert (= free@prime free))"
    , "; SKIP:lh"
    , "(assert (= lh@prime lh))"
    , "; SKIP:result"
    , "(assert (= result@prime result))"
    , "; SKIP:rh"
    , "(assert (= rh@prime rh))"
    , "; m0:act0"
    , "(assert (= ver@prime (+ ver 1)))"
    , "; m0:act4"
    , "(assert (= sl$trash@prime"
    , "           (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash"
    , "                                                                                              (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close LH"
    , "                                                                                                                                                                                    (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link LH)))))"
    , "; m0:act5"
    , "(assert (= sl$link@prime"
    , "           (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-set@@sl$Addr_0 LH) sl$link)))"
    , "; m0:act6"
    , "(assert (= LH@prime"
    , "           (@@field@@_right (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link LH))))"
    , "; m0:asm0"
    , "(assert (not (= sl$cInit sl$cBot)))"
    , "; m0:asm1"
    , "(assert (not (= sl$cInit sl$cEmpty)))"
    , "; m0:asm2"
    , "(assert (not (= sl$cInit sl$cNonEmpty)))"
    , "; m0:asm3"
    , "(assert (not (= sl$cInit sl$cPopped)))"
    , "; m0:asm4"
    , "(assert (not (= sl$cBot sl$cEmpty)))"
    , "; m0:asm5"
    , "(assert (not (= sl$cBot sl$cNonEmpty)))"
    , "; m0:asm6"
    , "(assert (not (= sl$cBot sl$cPopped)))"
    , "; m0:asm7"
    , "(assert (not (= sl$cEmpty sl$cNonEmpty)))"
    , "; m0:asm8"
    , "(assert (not (= sl$cEmpty sl$cPopped)))"
    , "; m0:asm9"
    , "(assert (not (= sl$cNonEmpty sl$cPopped)))"
    , "; m0:inv0"
    , "(assert (subset free sl$Addr))"
    , "; m0:sch2"
    , "(assert (not (= LH dummy)))"
    , "; m0:sch3"
    , "(assert (not (= LH RH)))"
    , "; m0:thm0:ASM"
    , "(assert (elem@@sl$Addr_0 LH"
    , "                         (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link)"
    , "                                (mk-set@@sl$Addr_0 dummy))))"
    , "; m0:thm1:ASM"
    , "(assert (elem@@sl$Addr_0 RH"
    , "                         (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link)"
    , "                                (mk-set@@sl$Addr_0 dummy))))"
    , "; m0:thm2:ASM"
    , "(assert (not (elem@@sl$Addr_0 LH"
    , "                              (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))))"
    , "; m0:thm3:ASM"
    , "(assert (not (elem@@sl$Addr_0 RH"
    , "                              (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))))"
    , "; m1:act0"
    , "(assert (= state@prime sl$cPopped))"
    , "; m1:inv0"
    , "(assert (= (= state sl$cBot) (and (not popL) (not remL))))"
    , "; m1:inv3"
    , "(assert (= popL"
    , "           (elem@@sl$State state"
    , "                           (union (mk-set@@sl$State sl$cInit)"
    , "                                  (mk-set@@sl$State sl$cNonEmpty)))))"
    , "; m1:inv4"
    , "(assert (=> (= state sl$cPopped)"
    , "            (and remL"
    , "                 (elem@@sl$Addr_0 lh"
    , "                                  (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))"
    , "                 (= (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash lh))"
    , "                    resL))))"
    , "; m1:inv5"
    , "(assert (= remL"
    , "           (elem@@sl$State state"
    , "                           (union (mk-set@@sl$State sl$cPopped)"
    , "                                  (mk-set@@sl$State sl$cEmpty)))))"
    , "; m1:inv6"
    , "(assert (= (= state sl$cEmpty) (and remL (= resL sl$bot))))"
    , "; m1:inv7"
    , "(assert (forall ( (p sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 p"
    , "                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link))"
    , "                       (elem@@sl$OBJ_0 (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link p))"
    , "                                       sl$OBJ))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ_0 (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link p))"
    , "                                     sl$OBJ) ))))"
    , "; m1:sch0"
    , "(assert (= state sl$cNonEmpty))"
    , "; m1:sch1"
    , "(assert (= lh LH))"
    , "(assert (not true))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/hdl:popL:more/WFIS/v"
    ]

result43 :: String
result43 = unlines
    [ "; m1/hdl:popL:more/C_SCH/weaken/m1:sch2"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(declare-datatypes (a1)"
    , "                   ( (Record-item (Record-item (@@field@@_item a1))) ))"
    , "(declare-datatypes (a1 a2 a3)"
    , "                   ( (Record-item-left-right (Record-item-left-right (@@field@@_item a1)"
    , "                                                                     (@@field@@_left a2)"
    , "                                                                     (@@field@@_right a3))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "(declare-sort sl$Addr_0 0)"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$OBJ_0 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(declare-sort sl$State 0)"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const LH sl$Addr_0)"
    , "(declare-const LH@prime sl$Addr_0)"
    , "(declare-const RH sl$Addr_0)"
    , "(declare-const RH@prime sl$Addr_0)"
    , "(declare-const dummy sl$Addr_0)"
    , "(declare-const free (set sl$Addr_0))"
    , "(declare-const free@prime (set sl$Addr_0))"
    , "(declare-const lh sl$Addr_0)"
    , "(declare-const lh@prime sl$Addr_0)"
    , "(declare-const popL Bool)"
    , "(declare-const popL@prime Bool)"
    , "(declare-const remL Bool)"
    , "(declare-const remL@prime Bool)"
    , "(declare-const resL sl$OBJ_0)"
    , "(declare-const resL@prime sl$OBJ_0)"
    , "(declare-const result sl$OBJ_0)"
    , "(declare-const result@prime sl$OBJ_0)"
    , "(declare-const rh sl$Addr_0)"
    , "(declare-const rh@prime sl$Addr_0)"
    , "(declare-const state sl$State)"
    , "(declare-const state@prime sl$State)"
    , "(declare-const v Int)"
    , "(declare-const ver Int)"
    , "(declare-const ver@prime Int)"
    , "(declare-const sl$bot sl$OBJ_0)"
    , "(declare-const sl$cBot sl$State)"
    , "(declare-const sl$cEmpty sl$State)"
    , "(declare-const sl$cInit sl$State)"
    , "(declare-const sl$cNonEmpty sl$State)"
    , "(declare-const sl$cPopped sl$State)"
    , "(declare-const sl$link"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$link@prime"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$trash"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$trash@prime"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "               sl$Addr_0 )"
    , "             (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "(declare-fun card@@sl$Addr_0 ( (set sl$Addr_0) ) Int)"
    , "(declare-fun card@@sl$OBJ_0 ( (set sl$OBJ_0) ) Int)"
    , "(declare-fun card@@sl$State ( (set sl$State) ) Int)"
    , "(declare-fun card@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0)) )"
    , "             Int)"
    , "(declare-fun const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (Record-item sl$OBJ_0) )"
    , "             (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "(declare-fun dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (set sl$Addr_0))"
    , "(declare-fun dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (set sl$Addr_0)"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (set sl$Addr_0)"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ()"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun finite@@sl$Addr_0 ( (set sl$Addr_0) ) Bool)"
    , "(declare-fun finite@@sl$OBJ_0 ( (set sl$OBJ_0) ) Bool)"
    , "(declare-fun finite@@sl$State ( (set sl$State) ) Bool)"
    , "(declare-fun finite@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0)) )"
    , "             Bool)"
    , "(declare-fun ident@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ()"
    , "             (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "(declare-fun injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             Bool)"
    , "(declare-fun mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             (sl$Addr_0 (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun mk-set@@sl$Addr_0 (sl$Addr_0) (set sl$Addr_0))"
    , "(declare-fun mk-set@@sl$OBJ_0 (sl$OBJ_0) (set sl$OBJ_0))"
    , "(declare-fun mk-set@@sl$State (sl$State) (set sl$State))"
    , "(declare-fun mk-set@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (Record-item sl$OBJ_0) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(declare-fun ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0))"
    , "               (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(declare-fun @@lambda@@_0"
    , "             ( (set sl$OBJ_0) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(define-fun all@@sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              true ))"
    , "(define-fun all@@sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              true ))"
    , "(define-fun all@@sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              true ))"
    , "(define-fun all@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (as const (set (Record-item sl$OBJ_0)))"
    , "              true ))"
    , "(define-fun compl@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0)) )"
    , "            (set sl$Addr_0)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0)) )"
    , "            (set sl$OBJ_0)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$State"
    , "            ( (s1 (set sl$State)) )"
    , "            (set sl$State)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0))) )"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@sl$Addr_0"
    , "            ( (x sl$Addr_0)"
    , "              (s1 (set sl$Addr_0)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$OBJ_0"
    , "            ( (x sl$OBJ_0)"
    , "              (s1 (set sl$OBJ_0)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$State"
    , "            ( (x sl$State)"
    , "              (s1 (set sl$State)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (x (Record-item sl$OBJ_0))"
    , "              (s1 (set (Record-item sl$OBJ_0))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              false ))"
    , "(define-fun empty-set@@sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              false ))"
    , "(define-fun empty-set@@sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              false ))"
    , "(define-fun empty-set@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (as const (set (Record-item sl$OBJ_0)))"
    , "              false ))"
    , "(define-fun set-diff@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0))"
    , "              (s2 (set sl$Addr_0)) )"
    , "            (set sl$Addr_0)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0))"
    , "              (s2 (set sl$OBJ_0)) )"
    , "            (set sl$OBJ_0)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$State"
    , "            ( (s1 (set sl$State))"
    , "              (s2 (set sl$State)) )"
    , "            (set sl$State)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0)))"
    , "              (s2 (set (Record-item sl$OBJ_0))) )"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0))"
    , "              (s2 (set sl$Addr_0)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0))"
    , "              (s2 (set sl$OBJ_0)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$State"
    , "            ( (s1 (set sl$State))"
    , "              (s2 (set sl$State)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0)))"
    , "              (s2 (set (Record-item sl$OBJ_0))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              true ))"
    , "(define-fun sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              true ))"
    , "(define-fun sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              true ))"
    , "(define-fun sl$OBJ@prime"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "(define-fun sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "(define-fun sl$Node@prime"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close (@@lambda@@_0 (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "                                                                                     ident@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(define-fun sl$Node"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close (@@lambda@@_0 (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "                                                                                     ident@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(define-fun sl$Addr@prime"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))"
    , "(define-fun sl$Addr"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (finite@Open@@Record-item@@sl$OBJ_0@Close r)"
    , "                       (<= 0 (card@Open@@Record-item@@sl$OBJ_0@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@Record-item@@sl$OBJ_0@Close r)) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (=> (finite@@sl$Addr_0 r) (<= 0 (card@@sl$Addr_0 r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Addr_0 r)) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (=> (finite@@sl$OBJ_0 r) (<= 0 (card@@sl$OBJ_0 r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$OBJ_0 r)) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (=> (finite@@sl$State r) (<= 0 (card@@sl$State r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$State r)) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (= (card@Open@@Record-item@@sl$OBJ_0@Close r) 0)"
    , "                      (= r empty-set@Open@@Record-item@@sl$OBJ_0@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close r) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (= (= (card@@sl$Addr_0 r) 0)"
    , "                      (= r empty-set@@sl$Addr_0))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 r) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (= (= (card@@sl$OBJ_0 r) 0)"
    , "                      (= r empty-set@@sl$OBJ_0))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 r) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (= (= (card@@sl$State r) 0)"
    , "                      (= r empty-set@@sl$State))"
    , "                   :pattern"
    , "                   ( (card@@sl$State r) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (= (card@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)) ))))"
    , "(assert (forall ( (x sl$Addr_0) )"
    , "                (! (= (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))"
    , "(assert (forall ( (x sl$OBJ_0) )"
    , "                (! (= (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))"
    , "(assert (forall ( (x sl$State) )"
    , "                (! (= (card@@sl$State (mk-set@@sl$State x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$State (mk-set@@sl$State x)) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (= (card@Open@@Record-item@@sl$OBJ_0@Close r) 1)"
    , "                      (exists ( (x (Record-item sl$OBJ_0)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close r) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (= (= (card@@sl$Addr_0 r) 1)"
    , "                      (exists ( (x sl$Addr_0) )"
    , "                              (and true (= r (mk-set@@sl$Addr_0 x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 r) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (= (= (card@@sl$OBJ_0 r) 1)"
    , "                      (exists ( (x sl$OBJ_0) )"
    , "                              (and true (= r (mk-set@@sl$OBJ_0 x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 r) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (= (= (card@@sl$State r) 1)"
    , "                      (exists ( (x sl$State) )"
    , "                              (and true (= r (mk-set@@sl$State x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$State r) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0)))"
    , "                  (r0 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@Record-item@@sl$OBJ_0@Close)"
    , "                       (= (card@Open@@Record-item@@sl$OBJ_0@Close (union r r0))"
    , "                          (+ (card@Open@@Record-item@@sl$OBJ_0@Close r)"
    , "                             (card@Open@@Record-item@@sl$OBJ_0@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Addr_0))"
    , "                  (r0 (set sl$Addr_0)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Addr_0)"
    , "                       (= (card@@sl$Addr_0 (union r r0))"
    , "                          (+ (card@@sl$Addr_0 r) (card@@sl$Addr_0 r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0))"
    , "                  (r0 (set sl$OBJ_0)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$OBJ_0)"
    , "                       (= (card@@sl$OBJ_0 (union r r0))"
    , "                          (+ (card@@sl$OBJ_0 r) (card@@sl$OBJ_0 r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$State))"
    , "                  (r0 (set sl$State)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$State)"
    , "                       (= (card@@sl$State (union r r0))"
    , "                          (+ (card@@sl$State r) (card@@sl$State r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$State (union r r0)) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (select (const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                              y)"
    , "                      x)"
    , "                   :pattern"
    , "                   ( (select (const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                             y) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (= (select ident@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                      x)"
    , "                   :pattern"
    , "                   ( (select ident@Open@@Record-item@@sl$OBJ_0@Close x) ))))"
    , "(assert (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)"
    , "           empty-set@@sl$Addr_0))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                         empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                        empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "                                                                                                         f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "                                                                                                        f1) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                      (mk-set@@sl$Addr_0 x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 x"
    , "                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (and (elem@@sl$Addr_0 x"
    , "                                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                            (not (elem@@sl$Addr_0 x"
    , "                                                  (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2))))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)"
    , "                                                                                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (and (elem@@sl$Addr_0 x s1)"
    , "                            (elem@@sl$Addr_0 x"
    , "                                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 x"
    , "                                        (set-diff@@sl$Addr_0 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                                                             s1))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2))"
    , "                      (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))"
    , "                      (intersect s1"
    , "                                 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))"
    , "                      (set-diff@@sl$Addr_0 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                                           s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (and (elem@@sl$Addr_0 x"
    , "                                            (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                           (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                              y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr_0 x"
    , "                                      (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                     (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (x2 sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                                  (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                               x2)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                             (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                              (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                             (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                      (forall ( (x sl$Addr_0)"
    , "                                (x2 sl$Addr_0) )"
    , "                              (=> (and (elem@@sl$Addr_0 x"
    , "                                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                                       (elem@@sl$Addr_0 x2"
    , "                                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                                  (=> (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                                         (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1) ))))"
    , "(assert (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close x (mk-set@Open@@Record-item@@sl$OBJ_0@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close x (mk-set@Open@@Record-item@@sl$OBJ_0@Close y)) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y sl$Addr_0) )"
    , "                (! (= (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) ))))"
    , "(assert (forall ( (x sl$OBJ_0)"
    , "                  (y sl$OBJ_0) )"
    , "                (! (= (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) ))))"
    , "(assert (forall ( (x sl$State)"
    , "                  (y sl$State) )"
    , "                (! (= (elem@@sl$State x (mk-set@@sl$State y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$State x (mk-set@@sl$State y)) ))))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0)))"
    , "                  (term (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close y"
    , "                                                              (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term))"
    , "                      (exists ( (x (Record-item sl$OBJ_0)) )"
    , "                              (and (elem@Open@@Record-item@@sl$OBJ_0@Close x r1)"
    , "                                   (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close y"
    , "                                                             (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)) ))))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0)))"
    , "                  (term (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (= (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)"
    , "                         (mk-set@Open@@Record-item@@sl$OBJ_0@Close y))"
    , "                      (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                              (=> (elem@Open@@Record-item@@sl$OBJ_0@Close x r1)"
    , "                                  (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)"
    , "                     (mk-set@Open@@Record-item@@sl$OBJ_0@Close y) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (finite@Open@@Record-item@@sl$OBJ_0@Close s1)"
    , "                       (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (finite@@sl$Addr_0 s1)"
    , "                       (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (finite@@sl$OBJ_0 s1)"
    , "                       (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (finite@@sl$State s1)"
    , "                       (finite@@sl$State (set-diff@@sl$State s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (and (finite@Open@@Record-item@@sl$OBJ_0@Close s1)"
    , "                            (finite@Open@@Record-item@@sl$OBJ_0@Close s2))"
    , "                       (finite@Open@@Record-item@@sl$OBJ_0@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (and (finite@@sl$Addr_0 s1) (finite@@sl$Addr_0 s2))"
    , "                       (finite@@sl$Addr_0 (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (and (finite@@sl$OBJ_0 s1) (finite@@sl$OBJ_0 s2))"
    , "                       (finite@@sl$OBJ_0 (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (and (finite@@sl$State s1) (finite@@sl$State s2))"
    , "                       (finite@@sl$State (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (and (finite@Open@@Record-item@@sl$OBJ_0@Close s2)"
    , "                            (not (finite@Open@@Record-item@@sl$OBJ_0@Close s1)))"
    , "                       (not (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (and (finite@@sl$Addr_0 s2)"
    , "                            (not (finite@@sl$Addr_0 s1)))"
    , "                       (not (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (and (finite@@sl$OBJ_0 s2) (not (finite@@sl$OBJ_0 s1)))"
    , "                       (not (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (and (finite@@sl$State s2) (not (finite@@sl$State s1)))"
    , "                       (not (finite@@sl$State (set-diff@@sl$State s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (finite@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)) ))))"
    , "(assert (forall ( (x sl$Addr_0) )"
    , "                (! (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))"
    , "(assert (forall ( (x sl$OBJ_0) )"
    , "                (! (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))"
    , "(assert (forall ( (x sl$State) )"
    , "                (! (finite@@sl$State (mk-set@@sl$State x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (mk-set@@sl$State x)) ))))"
    , "(assert (finite@Open@@Record-item@@sl$OBJ_0@Close empty-set@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(assert (finite@@sl$Addr_0 empty-set@@sl$Addr_0))"
    , "(assert (finite@@sl$OBJ_0 empty-set@@sl$OBJ_0))"
    , "(assert (finite@@sl$State empty-set@@sl$State))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 ident@Open@@Record-item@@sl$OBJ_0@Close)"
    , "                      r1)"
    , "                   :pattern"
    , "                   ( (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 ident@Open@@Record-item@@sl$OBJ_0@Close) ))))"
    , "(assert (forall ( (@@fv@@_0 (set sl$OBJ_0))"
    , "                  (@@bv@@_0 (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close @@bv@@_0 (@@lambda@@_0 @@fv@@_0))"
    , "                      (elem@@sl$OBJ_0 (@@field@@_item @@bv@@_0) @@fv@@_0))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close @@bv@@_0 (@@lambda@@_0 @@fv@@_0)) ))))"
    , "; m0:asm0"
    , "(assert (not (= sl$cInit sl$cBot)))"
    , "; m0:asm1"
    , "(assert (not (= sl$cInit sl$cEmpty)))"
    , "; m0:asm2"
    , "(assert (not (= sl$cInit sl$cNonEmpty)))"
    , "; m0:asm3"
    , "(assert (not (= sl$cInit sl$cPopped)))"
    , "; m0:asm4"
    , "(assert (not (= sl$cBot sl$cEmpty)))"
    , "; m0:asm5"
    , "(assert (not (= sl$cBot sl$cNonEmpty)))"
    , "; m0:asm6"
    , "(assert (not (= sl$cBot sl$cPopped)))"
    , "; m0:asm7"
    , "(assert (not (= sl$cEmpty sl$cNonEmpty)))"
    , "; m0:asm8"
    , "(assert (not (= sl$cEmpty sl$cPopped)))"
    , "; m0:asm9"
    , "(assert (not (= sl$cNonEmpty sl$cPopped)))"
    , "; m0:inv0"
    , "(assert (subset free sl$Addr))"
    , "; m0:sch0"
    , "(assert (= v ver))"
    , "; m0:sch1"
    , "(assert popL)"
    , "; m0:sch2"
    , "(assert (not (= LH dummy)))"
    , "; m0:sch3"
    , "(assert (not (= LH RH)))"
    , "; m0:thm0:ASM"
    , "(assert (elem@@sl$Addr_0 LH"
    , "                         (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link)"
    , "                                (mk-set@@sl$Addr_0 dummy))))"
    , "; m0:thm1:ASM"
    , "(assert (elem@@sl$Addr_0 RH"
    , "                         (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link)"
    , "                                (mk-set@@sl$Addr_0 dummy))))"
    , "; m0:thm2:ASM"
    , "(assert (not (elem@@sl$Addr_0 LH"
    , "                              (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))))"
    , "; m0:thm3:ASM"
    , "(assert (not (elem@@sl$Addr_0 RH"
    , "                              (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))))"
    , "; m1:inv0"
    , "(assert (= (= state sl$cBot) (and (not popL) (not remL))))"
    , "; m1:inv3"
    , "(assert (= popL"
    , "           (elem@@sl$State state"
    , "                           (union (mk-set@@sl$State sl$cInit)"
    , "                                  (mk-set@@sl$State sl$cNonEmpty)))))"
    , "; m1:inv4"
    , "(assert (=> (= state sl$cPopped)"
    , "            (and remL"
    , "                 (elem@@sl$Addr_0 lh"
    , "                                  (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))"
    , "                 (= (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash lh))"
    , "                    resL))))"
    , "; m1:inv5"
    , "(assert (= remL"
    , "           (elem@@sl$State state"
    , "                           (union (mk-set@@sl$State sl$cPopped)"
    , "                                  (mk-set@@sl$State sl$cEmpty)))))"
    , "; m1:inv6"
    , "(assert (= (= state sl$cEmpty) (and remL (= resL sl$bot))))"
    , "; m1:inv7"
    , "(assert (forall ( (p sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 p"
    , "                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link))"
    , "                       (elem@@sl$OBJ_0 (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link p))"
    , "                                       sl$OBJ))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ_0 (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link p))"
    , "                                     sl$OBJ) ))))"
    , "; m1:sch0"
    , "(assert (= state sl$cNonEmpty))"
    , "; m1:sch1"
    , "(assert (= lh LH))"
    , "(assert (= lh RH))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/hdl:popL:more/C_SCH/weaken/m1:sch2"
    ]

result49 :: String
result49 = unlines
    [ "; m2/read:LH/GRD/str"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(declare-datatypes (a1)"
    , "                   ( (Record-item (Record-item (@@field@@_item a1))) ))"
    , "(declare-datatypes (a1 a2 a3)"
    , "                   ( (Record-item-left-right (Record-item-left-right (@@field@@_item a1)"
    , "                                                                     (@@field@@_left a2)"
    , "                                                                     (@@field@@_right a3))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "(declare-sort sl$Addr_0 0)"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$OBJ_0 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(declare-sort sl$State 0)"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const LH sl$Addr_0)"
    , "(declare-const LH@prime sl$Addr_0)"
    , "(declare-const RH sl$Addr_0)"
    , "(declare-const RH@prime sl$Addr_0)"
    , "(declare-const dummy sl$Addr_0)"
    , "(declare-const free (set sl$Addr_0))"
    , "(declare-const free@prime (set sl$Addr_0))"
    , "(declare-const lh sl$Addr_0)"
    , "(declare-const lh@prime sl$Addr_0)"
    , "(declare-const popL Bool)"
    , "(declare-const remL Bool)"
    , "(declare-const resL sl$OBJ_0)"
    , "(declare-const result sl$OBJ_0)"
    , "(declare-const result@prime sl$OBJ_0)"
    , "(declare-const rh sl$Addr_0)"
    , "(declare-const rh@prime sl$Addr_0)"
    , "(declare-const state sl$State)"
    , "(declare-const state@prime sl$State)"
    , "(declare-const v Int)"
    , "(declare-const ver Int)"
    , "(declare-const ver@prime Int)"
    , "(declare-const sl$bot sl$OBJ_0)"
    , "(declare-const sl$cBot sl$State)"
    , "(declare-const sl$cEmpty sl$State)"
    , "(declare-const sl$cInit sl$State)"
    , "(declare-const sl$cNonEmpty sl$State)"
    , "(declare-const sl$cPopped sl$State)"
    , "(declare-const sl$link"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$link@prime"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$trash"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$trash@prime"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "               sl$Addr_0 )"
    , "             (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "(declare-fun card@@sl$Addr_0 ( (set sl$Addr_0) ) Int)"
    , "(declare-fun card@@sl$OBJ_0 ( (set sl$OBJ_0) ) Int)"
    , "(declare-fun card@@sl$State ( (set sl$State) ) Int)"
    , "(declare-fun card@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0)) )"
    , "             Int)"
    , "(declare-fun const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (Record-item sl$OBJ_0) )"
    , "             (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "(declare-fun dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (set sl$Addr_0))"
    , "(declare-fun dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (set sl$Addr_0)"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (set sl$Addr_0)"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ()"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun finite@@sl$Addr_0 ( (set sl$Addr_0) ) Bool)"
    , "(declare-fun finite@@sl$OBJ_0 ( (set sl$OBJ_0) ) Bool)"
    , "(declare-fun finite@@sl$State ( (set sl$State) ) Bool)"
    , "(declare-fun finite@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0)) )"
    , "             Bool)"
    , "(declare-fun ident@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ()"
    , "             (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "(declare-fun injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             Bool)"
    , "(declare-fun mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             (sl$Addr_0 (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun mk-set@@sl$Addr_0 (sl$Addr_0) (set sl$Addr_0))"
    , "(declare-fun mk-set@@sl$OBJ_0 (sl$OBJ_0) (set sl$OBJ_0))"
    , "(declare-fun mk-set@@sl$State (sl$State) (set sl$State))"
    , "(declare-fun mk-set@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (Record-item sl$OBJ_0) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(declare-fun ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0))"
    , "               (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(declare-fun @@lambda@@_0"
    , "             ( (set sl$OBJ_0) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(define-fun all@@sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              true ))"
    , "(define-fun all@@sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              true ))"
    , "(define-fun all@@sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              true ))"
    , "(define-fun all@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (as const (set (Record-item sl$OBJ_0)))"
    , "              true ))"
    , "(define-fun compl@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0)) )"
    , "            (set sl$Addr_0)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0)) )"
    , "            (set sl$OBJ_0)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$State"
    , "            ( (s1 (set sl$State)) )"
    , "            (set sl$State)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0))) )"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@sl$Addr_0"
    , "            ( (x sl$Addr_0)"
    , "              (s1 (set sl$Addr_0)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$OBJ_0"
    , "            ( (x sl$OBJ_0)"
    , "              (s1 (set sl$OBJ_0)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$State"
    , "            ( (x sl$State)"
    , "              (s1 (set sl$State)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (x (Record-item sl$OBJ_0))"
    , "              (s1 (set (Record-item sl$OBJ_0))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              false ))"
    , "(define-fun empty-set@@sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              false ))"
    , "(define-fun empty-set@@sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              false ))"
    , "(define-fun empty-set@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (as const (set (Record-item sl$OBJ_0)))"
    , "              false ))"
    , "(define-fun set-diff@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0))"
    , "              (s2 (set sl$Addr_0)) )"
    , "            (set sl$Addr_0)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0))"
    , "              (s2 (set sl$OBJ_0)) )"
    , "            (set sl$OBJ_0)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$State"
    , "            ( (s1 (set sl$State))"
    , "              (s2 (set sl$State)) )"
    , "            (set sl$State)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0)))"
    , "              (s2 (set (Record-item sl$OBJ_0))) )"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0))"
    , "              (s2 (set sl$Addr_0)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0))"
    , "              (s2 (set sl$OBJ_0)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$State"
    , "            ( (s1 (set sl$State))"
    , "              (s2 (set sl$State)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0)))"
    , "              (s2 (set (Record-item sl$OBJ_0))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              true ))"
    , "(define-fun sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              true ))"
    , "(define-fun sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              true ))"
    , "(define-fun sl$OBJ@prime"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "(define-fun sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "(define-fun sl$Node@prime"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close (@@lambda@@_0 (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "                                                                                     ident@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(define-fun sl$Node"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close (@@lambda@@_0 (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "                                                                                     ident@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(define-fun sl$Addr@prime"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))"
    , "(define-fun sl$Addr"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (finite@Open@@Record-item@@sl$OBJ_0@Close r)"
    , "                       (<= 0 (card@Open@@Record-item@@sl$OBJ_0@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@Record-item@@sl$OBJ_0@Close r)) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (=> (finite@@sl$Addr_0 r) (<= 0 (card@@sl$Addr_0 r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Addr_0 r)) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (=> (finite@@sl$OBJ_0 r) (<= 0 (card@@sl$OBJ_0 r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$OBJ_0 r)) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (=> (finite@@sl$State r) (<= 0 (card@@sl$State r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$State r)) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (= (card@Open@@Record-item@@sl$OBJ_0@Close r) 0)"
    , "                      (= r empty-set@Open@@Record-item@@sl$OBJ_0@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close r) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (= (= (card@@sl$Addr_0 r) 0)"
    , "                      (= r empty-set@@sl$Addr_0))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 r) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (= (= (card@@sl$OBJ_0 r) 0)"
    , "                      (= r empty-set@@sl$OBJ_0))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 r) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (= (= (card@@sl$State r) 0)"
    , "                      (= r empty-set@@sl$State))"
    , "                   :pattern"
    , "                   ( (card@@sl$State r) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (= (card@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)) ))))"
    , "(assert (forall ( (x sl$Addr_0) )"
    , "                (! (= (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))"
    , "(assert (forall ( (x sl$OBJ_0) )"
    , "                (! (= (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))"
    , "(assert (forall ( (x sl$State) )"
    , "                (! (= (card@@sl$State (mk-set@@sl$State x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$State (mk-set@@sl$State x)) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (= (card@Open@@Record-item@@sl$OBJ_0@Close r) 1)"
    , "                      (exists ( (x (Record-item sl$OBJ_0)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close r) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (= (= (card@@sl$Addr_0 r) 1)"
    , "                      (exists ( (x sl$Addr_0) )"
    , "                              (and true (= r (mk-set@@sl$Addr_0 x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 r) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (= (= (card@@sl$OBJ_0 r) 1)"
    , "                      (exists ( (x sl$OBJ_0) )"
    , "                              (and true (= r (mk-set@@sl$OBJ_0 x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 r) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (= (= (card@@sl$State r) 1)"
    , "                      (exists ( (x sl$State) )"
    , "                              (and true (= r (mk-set@@sl$State x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$State r) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0)))"
    , "                  (r0 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@Record-item@@sl$OBJ_0@Close)"
    , "                       (= (card@Open@@Record-item@@sl$OBJ_0@Close (union r r0))"
    , "                          (+ (card@Open@@Record-item@@sl$OBJ_0@Close r)"
    , "                             (card@Open@@Record-item@@sl$OBJ_0@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Addr_0))"
    , "                  (r0 (set sl$Addr_0)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Addr_0)"
    , "                       (= (card@@sl$Addr_0 (union r r0))"
    , "                          (+ (card@@sl$Addr_0 r) (card@@sl$Addr_0 r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0))"
    , "                  (r0 (set sl$OBJ_0)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$OBJ_0)"
    , "                       (= (card@@sl$OBJ_0 (union r r0))"
    , "                          (+ (card@@sl$OBJ_0 r) (card@@sl$OBJ_0 r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$State))"
    , "                  (r0 (set sl$State)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$State)"
    , "                       (= (card@@sl$State (union r r0))"
    , "                          (+ (card@@sl$State r) (card@@sl$State r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$State (union r r0)) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (select (const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                              y)"
    , "                      x)"
    , "                   :pattern"
    , "                   ( (select (const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                             y) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (= (select ident@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                      x)"
    , "                   :pattern"
    , "                   ( (select ident@Open@@Record-item@@sl$OBJ_0@Close x) ))))"
    , "(assert (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)"
    , "           empty-set@@sl$Addr_0))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                         empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                        empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "                                                                                                         f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "                                                                                                        f1) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                      (mk-set@@sl$Addr_0 x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 x"
    , "                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (and (elem@@sl$Addr_0 x"
    , "                                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                            (not (elem@@sl$Addr_0 x"
    , "                                                  (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2))))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)"
    , "                                                                                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (and (elem@@sl$Addr_0 x s1)"
    , "                            (elem@@sl$Addr_0 x"
    , "                                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 x"
    , "                                        (set-diff@@sl$Addr_0 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                                                             s1))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2))"
    , "                      (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))"
    , "                      (intersect s1"
    , "                                 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))"
    , "                      (set-diff@@sl$Addr_0 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                                           s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (and (elem@@sl$Addr_0 x"
    , "                                            (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                           (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                              y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr_0 x"
    , "                                      (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                     (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (x2 sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                                  (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                               x2)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                             (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                              (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                             (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                      (forall ( (x sl$Addr_0)"
    , "                                (x2 sl$Addr_0) )"
    , "                              (=> (and (elem@@sl$Addr_0 x"
    , "                                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                                       (elem@@sl$Addr_0 x2"
    , "                                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                                  (=> (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                                         (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1) ))))"
    , "(assert (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close x (mk-set@Open@@Record-item@@sl$OBJ_0@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close x (mk-set@Open@@Record-item@@sl$OBJ_0@Close y)) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y sl$Addr_0) )"
    , "                (! (= (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) ))))"
    , "(assert (forall ( (x sl$OBJ_0)"
    , "                  (y sl$OBJ_0) )"
    , "                (! (= (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) ))))"
    , "(assert (forall ( (x sl$State)"
    , "                  (y sl$State) )"
    , "                (! (= (elem@@sl$State x (mk-set@@sl$State y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$State x (mk-set@@sl$State y)) ))))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0)))"
    , "                  (term (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close y"
    , "                                                              (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term))"
    , "                      (exists ( (x (Record-item sl$OBJ_0)) )"
    , "                              (and (elem@Open@@Record-item@@sl$OBJ_0@Close x r1)"
    , "                                   (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close y"
    , "                                                             (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)) ))))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0)))"
    , "                  (term (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (= (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)"
    , "                         (mk-set@Open@@Record-item@@sl$OBJ_0@Close y))"
    , "                      (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                              (=> (elem@Open@@Record-item@@sl$OBJ_0@Close x r1)"
    , "                                  (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)"
    , "                     (mk-set@Open@@Record-item@@sl$OBJ_0@Close y) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (finite@Open@@Record-item@@sl$OBJ_0@Close s1)"
    , "                       (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (finite@@sl$Addr_0 s1)"
    , "                       (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (finite@@sl$OBJ_0 s1)"
    , "                       (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (finite@@sl$State s1)"
    , "                       (finite@@sl$State (set-diff@@sl$State s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (and (finite@Open@@Record-item@@sl$OBJ_0@Close s1)"
    , "                            (finite@Open@@Record-item@@sl$OBJ_0@Close s2))"
    , "                       (finite@Open@@Record-item@@sl$OBJ_0@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (and (finite@@sl$Addr_0 s1) (finite@@sl$Addr_0 s2))"
    , "                       (finite@@sl$Addr_0 (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (and (finite@@sl$OBJ_0 s1) (finite@@sl$OBJ_0 s2))"
    , "                       (finite@@sl$OBJ_0 (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (and (finite@@sl$State s1) (finite@@sl$State s2))"
    , "                       (finite@@sl$State (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (and (finite@Open@@Record-item@@sl$OBJ_0@Close s2)"
    , "                            (not (finite@Open@@Record-item@@sl$OBJ_0@Close s1)))"
    , "                       (not (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (and (finite@@sl$Addr_0 s2)"
    , "                            (not (finite@@sl$Addr_0 s1)))"
    , "                       (not (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (and (finite@@sl$OBJ_0 s2) (not (finite@@sl$OBJ_0 s1)))"
    , "                       (not (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (and (finite@@sl$State s2) (not (finite@@sl$State s1)))"
    , "                       (not (finite@@sl$State (set-diff@@sl$State s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (finite@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)) ))))"
    , "(assert (forall ( (x sl$Addr_0) )"
    , "                (! (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))"
    , "(assert (forall ( (x sl$OBJ_0) )"
    , "                (! (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))"
    , "(assert (forall ( (x sl$State) )"
    , "                (! (finite@@sl$State (mk-set@@sl$State x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (mk-set@@sl$State x)) ))))"
    , "(assert (finite@Open@@Record-item@@sl$OBJ_0@Close empty-set@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(assert (finite@@sl$Addr_0 empty-set@@sl$Addr_0))"
    , "(assert (finite@@sl$OBJ_0 empty-set@@sl$OBJ_0))"
    , "(assert (finite@@sl$State empty-set@@sl$State))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 ident@Open@@Record-item@@sl$OBJ_0@Close)"
    , "                      r1)"
    , "                   :pattern"
    , "                   ( (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 ident@Open@@Record-item@@sl$OBJ_0@Close) ))))"
    , "(assert (forall ( (@@fv@@_0 (set sl$OBJ_0))"
    , "                  (@@bv@@_0 (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close @@bv@@_0 (@@lambda@@_0 @@fv@@_0))"
    , "                      (elem@@sl$OBJ_0 (@@field@@_item @@bv@@_0) @@fv@@_0))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close @@bv@@_0 (@@lambda@@_0 @@fv@@_0)) ))))"
    , "; m0:asm0"
    , "(assert (not (= sl$cInit sl$cBot)))"
    , "; m0:asm1"
    , "(assert (not (= sl$cInit sl$cEmpty)))"
    , "; m0:asm2"
    , "(assert (not (= sl$cInit sl$cNonEmpty)))"
    , "; m0:asm3"
    , "(assert (not (= sl$cInit sl$cPopped)))"
    , "; m0:asm4"
    , "(assert (not (= sl$cBot sl$cEmpty)))"
    , "; m0:asm5"
    , "(assert (not (= sl$cBot sl$cNonEmpty)))"
    , "; m0:asm6"
    , "(assert (not (= sl$cBot sl$cPopped)))"
    , "; m0:asm7"
    , "(assert (not (= sl$cEmpty sl$cNonEmpty)))"
    , "; m0:asm8"
    , "(assert (not (= sl$cEmpty sl$cPopped)))"
    , "; m0:asm9"
    , "(assert (not (= sl$cNonEmpty sl$cPopped)))"
    , "; m0:inv0"
    , "(assert (subset free sl$Addr))"
    , "; m0:thm0:ASM"
    , "(assert (elem@@sl$Addr_0 LH"
    , "                         (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link)"
    , "                                (mk-set@@sl$Addr_0 dummy))))"
    , "; m0:thm1:ASM"
    , "(assert (elem@@sl$Addr_0 RH"
    , "                         (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link)"
    , "                                (mk-set@@sl$Addr_0 dummy))))"
    , "; m0:thm2:ASM"
    , "(assert (not (elem@@sl$Addr_0 LH"
    , "                              (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))))"
    , "; m0:thm3:ASM"
    , "(assert (not (elem@@sl$Addr_0 RH"
    , "                              (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))))"
    , "; m1:inv0"
    , "(assert (= (= state sl$cBot) (and (not popL) (not remL))))"
    , "; m1:inv3"
    , "(assert (= popL"
    , "           (elem@@sl$State state"
    , "                           (union (mk-set@@sl$State sl$cInit)"
    , "                                  (mk-set@@sl$State sl$cNonEmpty)))))"
    , "; m1:inv4"
    , "(assert (=> (= state sl$cPopped)"
    , "            (and remL"
    , "                 (elem@@sl$Addr_0 lh"
    , "                                  (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))"
    , "                 (= (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash lh))"
    , "                    resL))))"
    , "; m1:inv5"
    , "(assert (= remL"
    , "           (elem@@sl$State state"
    , "                           (union (mk-set@@sl$State sl$cPopped)"
    , "                                  (mk-set@@sl$State sl$cEmpty)))))"
    , "; m1:inv6"
    , "(assert (= (= state sl$cEmpty) (and remL (= resL sl$bot))))"
    , "; m1:inv7"
    , "(assert (forall ( (p sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 p"
    , "                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link))"
    , "                       (elem@@sl$OBJ_0 (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link p))"
    , "                                       sl$OBJ))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ_0 (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link p))"
    , "                                     sl$OBJ) ))))"
    , "; m1:sch0"
    , "(assert (elem@@sl$State state"
    , "                        (union (mk-set@@sl$State sl$cInit)"
    , "                               (mk-set@@sl$State sl$cNonEmpty))))"
    , "; v"
    , "(assert (= v ver))"
    , "(assert (not (or (and (= v ver) (= LH dummy)) (not (= LH dummy)))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m2/read:LH/GRD/str"
    ]

result52 :: String
result52 = unlines
    [ "; m2/read:LH/SAF/LIVE/m2:prog0/ensure"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(declare-datatypes (a1)"
    , "                   ( (Record-item (Record-item (@@field@@_item a1))) ))"
    , "(declare-datatypes (a1 a2 a3)"
    , "                   ( (Record-item-left-right (Record-item-left-right (@@field@@_item a1)"
    , "                                                                     (@@field@@_left a2)"
    , "                                                                     (@@field@@_right a3))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "(declare-sort sl$Addr_0 0)"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$OBJ_0 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(declare-sort sl$State 0)"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const LH sl$Addr_0)"
    , "(declare-const LH@prime sl$Addr_0)"
    , "(declare-const RH sl$Addr_0)"
    , "(declare-const RH@prime sl$Addr_0)"
    , "(declare-const dummy sl$Addr_0)"
    , "(declare-const free (set sl$Addr_0))"
    , "(declare-const free@prime (set sl$Addr_0))"
    , "(declare-const lh sl$Addr_0)"
    , "(declare-const lh@prime sl$Addr_0)"
    , "(declare-const popL Bool)"
    , "(declare-const remL Bool)"
    , "(declare-const resL sl$OBJ_0)"
    , "(declare-const result sl$OBJ_0)"
    , "(declare-const result@prime sl$OBJ_0)"
    , "(declare-const rh sl$Addr_0)"
    , "(declare-const rh@prime sl$Addr_0)"
    , "(declare-const state sl$State)"
    , "(declare-const state@prime sl$State)"
    , "(declare-const v Int)"
    , "(declare-const v0 Int)"
    , "(declare-const ver Int)"
    , "(declare-const ver@prime Int)"
    , "(declare-const sl$bot sl$OBJ_0)"
    , "(declare-const sl$cBot sl$State)"
    , "(declare-const sl$cEmpty sl$State)"
    , "(declare-const sl$cInit sl$State)"
    , "(declare-const sl$cNonEmpty sl$State)"
    , "(declare-const sl$cPopped sl$State)"
    , "(declare-const sl$link"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$link@prime"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$trash"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$trash@prime"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "               sl$Addr_0 )"
    , "             (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "(declare-fun card@@sl$Addr_0 ( (set sl$Addr_0) ) Int)"
    , "(declare-fun card@@sl$OBJ_0 ( (set sl$OBJ_0) ) Int)"
    , "(declare-fun card@@sl$State ( (set sl$State) ) Int)"
    , "(declare-fun card@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0)) )"
    , "             Int)"
    , "(declare-fun const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (Record-item sl$OBJ_0) )"
    , "             (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "(declare-fun dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (set sl$Addr_0))"
    , "(declare-fun dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (set sl$Addr_0)"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (set sl$Addr_0)"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ()"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun finite@@sl$Addr_0 ( (set sl$Addr_0) ) Bool)"
    , "(declare-fun finite@@sl$OBJ_0 ( (set sl$OBJ_0) ) Bool)"
    , "(declare-fun finite@@sl$State ( (set sl$State) ) Bool)"
    , "(declare-fun finite@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0)) )"
    , "             Bool)"
    , "(declare-fun ident@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ()"
    , "             (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "(declare-fun injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             Bool)"
    , "(declare-fun mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             (sl$Addr_0 (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun mk-set@@sl$Addr_0 (sl$Addr_0) (set sl$Addr_0))"
    , "(declare-fun mk-set@@sl$OBJ_0 (sl$OBJ_0) (set sl$OBJ_0))"
    , "(declare-fun mk-set@@sl$State (sl$State) (set sl$State))"
    , "(declare-fun mk-set@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (Record-item sl$OBJ_0) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(declare-fun ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0))"
    , "               (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(declare-fun @@lambda@@_0"
    , "             ( (set sl$OBJ_0) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(define-fun all@@sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              true ))"
    , "(define-fun all@@sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              true ))"
    , "(define-fun all@@sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              true ))"
    , "(define-fun all@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (as const (set (Record-item sl$OBJ_0)))"
    , "              true ))"
    , "(define-fun compl@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0)) )"
    , "            (set sl$Addr_0)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0)) )"
    , "            (set sl$OBJ_0)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$State"
    , "            ( (s1 (set sl$State)) )"
    , "            (set sl$State)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0))) )"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@sl$Addr_0"
    , "            ( (x sl$Addr_0)"
    , "              (s1 (set sl$Addr_0)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$OBJ_0"
    , "            ( (x sl$OBJ_0)"
    , "              (s1 (set sl$OBJ_0)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$State"
    , "            ( (x sl$State)"
    , "              (s1 (set sl$State)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (x (Record-item sl$OBJ_0))"
    , "              (s1 (set (Record-item sl$OBJ_0))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              false ))"
    , "(define-fun empty-set@@sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              false ))"
    , "(define-fun empty-set@@sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              false ))"
    , "(define-fun empty-set@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (as const (set (Record-item sl$OBJ_0)))"
    , "              false ))"
    , "(define-fun set-diff@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0))"
    , "              (s2 (set sl$Addr_0)) )"
    , "            (set sl$Addr_0)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0))"
    , "              (s2 (set sl$OBJ_0)) )"
    , "            (set sl$OBJ_0)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$State"
    , "            ( (s1 (set sl$State))"
    , "              (s2 (set sl$State)) )"
    , "            (set sl$State)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0)))"
    , "              (s2 (set (Record-item sl$OBJ_0))) )"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0))"
    , "              (s2 (set sl$Addr_0)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0))"
    , "              (s2 (set sl$OBJ_0)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$State"
    , "            ( (s1 (set sl$State))"
    , "              (s2 (set sl$State)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0)))"
    , "              (s2 (set (Record-item sl$OBJ_0))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              true ))"
    , "(define-fun sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              true ))"
    , "(define-fun sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              true ))"
    , "(define-fun sl$OBJ@prime"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "(define-fun sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "(define-fun sl$Node@prime"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close (@@lambda@@_0 (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "                                                                                     ident@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(define-fun sl$Node"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close (@@lambda@@_0 (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "                                                                                     ident@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(define-fun sl$Addr@prime"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))"
    , "(define-fun sl$Addr"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (finite@Open@@Record-item@@sl$OBJ_0@Close r)"
    , "                       (<= 0 (card@Open@@Record-item@@sl$OBJ_0@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@Record-item@@sl$OBJ_0@Close r)) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (=> (finite@@sl$Addr_0 r) (<= 0 (card@@sl$Addr_0 r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Addr_0 r)) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (=> (finite@@sl$OBJ_0 r) (<= 0 (card@@sl$OBJ_0 r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$OBJ_0 r)) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (=> (finite@@sl$State r) (<= 0 (card@@sl$State r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$State r)) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (= (card@Open@@Record-item@@sl$OBJ_0@Close r) 0)"
    , "                      (= r empty-set@Open@@Record-item@@sl$OBJ_0@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close r) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (= (= (card@@sl$Addr_0 r) 0)"
    , "                      (= r empty-set@@sl$Addr_0))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 r) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (= (= (card@@sl$OBJ_0 r) 0)"
    , "                      (= r empty-set@@sl$OBJ_0))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 r) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (= (= (card@@sl$State r) 0)"
    , "                      (= r empty-set@@sl$State))"
    , "                   :pattern"
    , "                   ( (card@@sl$State r) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (= (card@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)) ))))"
    , "(assert (forall ( (x sl$Addr_0) )"
    , "                (! (= (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))"
    , "(assert (forall ( (x sl$OBJ_0) )"
    , "                (! (= (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))"
    , "(assert (forall ( (x sl$State) )"
    , "                (! (= (card@@sl$State (mk-set@@sl$State x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$State (mk-set@@sl$State x)) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (= (card@Open@@Record-item@@sl$OBJ_0@Close r) 1)"
    , "                      (exists ( (x (Record-item sl$OBJ_0)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close r) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (= (= (card@@sl$Addr_0 r) 1)"
    , "                      (exists ( (x sl$Addr_0) )"
    , "                              (and true (= r (mk-set@@sl$Addr_0 x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 r) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (= (= (card@@sl$OBJ_0 r) 1)"
    , "                      (exists ( (x sl$OBJ_0) )"
    , "                              (and true (= r (mk-set@@sl$OBJ_0 x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 r) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (= (= (card@@sl$State r) 1)"
    , "                      (exists ( (x sl$State) )"
    , "                              (and true (= r (mk-set@@sl$State x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$State r) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0)))"
    , "                  (r0 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@Record-item@@sl$OBJ_0@Close)"
    , "                       (= (card@Open@@Record-item@@sl$OBJ_0@Close (union r r0))"
    , "                          (+ (card@Open@@Record-item@@sl$OBJ_0@Close r)"
    , "                             (card@Open@@Record-item@@sl$OBJ_0@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Addr_0))"
    , "                  (r0 (set sl$Addr_0)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Addr_0)"
    , "                       (= (card@@sl$Addr_0 (union r r0))"
    , "                          (+ (card@@sl$Addr_0 r) (card@@sl$Addr_0 r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0))"
    , "                  (r0 (set sl$OBJ_0)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$OBJ_0)"
    , "                       (= (card@@sl$OBJ_0 (union r r0))"
    , "                          (+ (card@@sl$OBJ_0 r) (card@@sl$OBJ_0 r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$State))"
    , "                  (r0 (set sl$State)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$State)"
    , "                       (= (card@@sl$State (union r r0))"
    , "                          (+ (card@@sl$State r) (card@@sl$State r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$State (union r r0)) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (select (const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                              y)"
    , "                      x)"
    , "                   :pattern"
    , "                   ( (select (const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                             y) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (= (select ident@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                      x)"
    , "                   :pattern"
    , "                   ( (select ident@Open@@Record-item@@sl$OBJ_0@Close x) ))))"
    , "(assert (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)"
    , "           empty-set@@sl$Addr_0))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                         empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                        empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "                                                                                                         f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "                                                                                                        f1) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                      (mk-set@@sl$Addr_0 x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 x"
    , "                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (and (elem@@sl$Addr_0 x"
    , "                                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                            (not (elem@@sl$Addr_0 x"
    , "                                                  (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2))))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)"
    , "                                                                                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (and (elem@@sl$Addr_0 x s1)"
    , "                            (elem@@sl$Addr_0 x"
    , "                                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 x"
    , "                                        (set-diff@@sl$Addr_0 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                                                             s1))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2))"
    , "                      (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))"
    , "                      (intersect s1"
    , "                                 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))"
    , "                      (set-diff@@sl$Addr_0 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                                           s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (and (elem@@sl$Addr_0 x"
    , "                                            (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                           (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                              y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr_0 x"
    , "                                      (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                     (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (x2 sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                                  (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                               x2)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                             (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                              (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                             (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                      (forall ( (x sl$Addr_0)"
    , "                                (x2 sl$Addr_0) )"
    , "                              (=> (and (elem@@sl$Addr_0 x"
    , "                                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                                       (elem@@sl$Addr_0 x2"
    , "                                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                                  (=> (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                                         (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1) ))))"
    , "(assert (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close x (mk-set@Open@@Record-item@@sl$OBJ_0@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close x (mk-set@Open@@Record-item@@sl$OBJ_0@Close y)) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y sl$Addr_0) )"
    , "                (! (= (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) ))))"
    , "(assert (forall ( (x sl$OBJ_0)"
    , "                  (y sl$OBJ_0) )"
    , "                (! (= (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) ))))"
    , "(assert (forall ( (x sl$State)"
    , "                  (y sl$State) )"
    , "                (! (= (elem@@sl$State x (mk-set@@sl$State y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$State x (mk-set@@sl$State y)) ))))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0)))"
    , "                  (term (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close y"
    , "                                                              (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term))"
    , "                      (exists ( (x (Record-item sl$OBJ_0)) )"
    , "                              (and (elem@Open@@Record-item@@sl$OBJ_0@Close x r1)"
    , "                                   (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close y"
    , "                                                             (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)) ))))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0)))"
    , "                  (term (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (= (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)"
    , "                         (mk-set@Open@@Record-item@@sl$OBJ_0@Close y))"
    , "                      (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                              (=> (elem@Open@@Record-item@@sl$OBJ_0@Close x r1)"
    , "                                  (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)"
    , "                     (mk-set@Open@@Record-item@@sl$OBJ_0@Close y) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (finite@Open@@Record-item@@sl$OBJ_0@Close s1)"
    , "                       (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (finite@@sl$Addr_0 s1)"
    , "                       (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (finite@@sl$OBJ_0 s1)"
    , "                       (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (finite@@sl$State s1)"
    , "                       (finite@@sl$State (set-diff@@sl$State s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (and (finite@Open@@Record-item@@sl$OBJ_0@Close s1)"
    , "                            (finite@Open@@Record-item@@sl$OBJ_0@Close s2))"
    , "                       (finite@Open@@Record-item@@sl$OBJ_0@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (and (finite@@sl$Addr_0 s1) (finite@@sl$Addr_0 s2))"
    , "                       (finite@@sl$Addr_0 (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (and (finite@@sl$OBJ_0 s1) (finite@@sl$OBJ_0 s2))"
    , "                       (finite@@sl$OBJ_0 (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (and (finite@@sl$State s1) (finite@@sl$State s2))"
    , "                       (finite@@sl$State (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (and (finite@Open@@Record-item@@sl$OBJ_0@Close s2)"
    , "                            (not (finite@Open@@Record-item@@sl$OBJ_0@Close s1)))"
    , "                       (not (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (and (finite@@sl$Addr_0 s2)"
    , "                            (not (finite@@sl$Addr_0 s1)))"
    , "                       (not (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (and (finite@@sl$OBJ_0 s2) (not (finite@@sl$OBJ_0 s1)))"
    , "                       (not (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (and (finite@@sl$State s2) (not (finite@@sl$State s1)))"
    , "                       (not (finite@@sl$State (set-diff@@sl$State s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (finite@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)) ))))"
    , "(assert (forall ( (x sl$Addr_0) )"
    , "                (! (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))"
    , "(assert (forall ( (x sl$OBJ_0) )"
    , "                (! (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))"
    , "(assert (forall ( (x sl$State) )"
    , "                (! (finite@@sl$State (mk-set@@sl$State x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (mk-set@@sl$State x)) ))))"
    , "(assert (finite@Open@@Record-item@@sl$OBJ_0@Close empty-set@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(assert (finite@@sl$Addr_0 empty-set@@sl$Addr_0))"
    , "(assert (finite@@sl$OBJ_0 empty-set@@sl$OBJ_0))"
    , "(assert (finite@@sl$State empty-set@@sl$State))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 ident@Open@@Record-item@@sl$OBJ_0@Close)"
    , "                      r1)"
    , "                   :pattern"
    , "                   ( (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 ident@Open@@Record-item@@sl$OBJ_0@Close) ))))"
    , "(assert (not (forall ( (v Int) )"
    , "                     (=> true"
    , "                         (=> (and (= v ver)"
    , "                                  (= state sl$cNonEmpty)"
    , "                                  (not (or (= rh RH) (not (= v ver)))))"
    , "                             (or (and (= v ver@prime) (= state@prime sl$cNonEmpty))"
    , "                                 (= rh@prime RH@prime)"
    , "                                 (not (= v ver@prime))))))))"
    , "(assert (forall ( (@@fv@@_0 (set sl$OBJ_0))"
    , "                  (@@bv@@_0 (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close @@bv@@_0 (@@lambda@@_0 @@fv@@_0))"
    , "                      (elem@@sl$OBJ_0 (@@field@@_item @@bv@@_0) @@fv@@_0))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close @@bv@@_0 (@@lambda@@_0 @@fv@@_0)) ))))"
    , "; SKIP:LH"
    , "(assert (= LH@prime LH))"
    , "; SKIP:RH"
    , "(assert (= RH@prime RH))"
    , "; SKIP:\\link"
    , "(assert (= sl$link@prime sl$link))"
    , "; SKIP:\\trash"
    , "(assert (= sl$trash@prime sl$trash))"
    , "; SKIP:free"
    , "(assert (= free@prime free))"
    , "; SKIP:result"
    , "(assert (= result@prime result))"
    , "; SKIP:rh"
    , "(assert (= rh@prime rh))"
    , "; m0:asm0"
    , "(assert (not (= sl$cInit sl$cBot)))"
    , "; m0:asm1"
    , "(assert (not (= sl$cInit sl$cEmpty)))"
    , "; m0:asm2"
    , "(assert (not (= sl$cInit sl$cNonEmpty)))"
    , "; m0:asm3"
    , "(assert (not (= sl$cInit sl$cPopped)))"
    , "; m0:asm4"
    , "(assert (not (= sl$cBot sl$cEmpty)))"
    , "; m0:asm5"
    , "(assert (not (= sl$cBot sl$cNonEmpty)))"
    , "; m0:asm6"
    , "(assert (not (= sl$cBot sl$cPopped)))"
    , "; m0:asm7"
    , "(assert (not (= sl$cEmpty sl$cNonEmpty)))"
    , "; m0:asm8"
    , "(assert (not (= sl$cEmpty sl$cPopped)))"
    , "; m0:asm9"
    , "(assert (not (= sl$cNonEmpty sl$cPopped)))"
    , "; m0:inv0"
    , "(assert (subset free sl$Addr))"
    , "; m0:thm0:ASM"
    , "(assert (elem@@sl$Addr_0 LH"
    , "                         (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link)"
    , "                                (mk-set@@sl$Addr_0 dummy))))"
    , "; m0:thm1:ASM"
    , "(assert (elem@@sl$Addr_0 RH"
    , "                         (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link)"
    , "                                (mk-set@@sl$Addr_0 dummy))))"
    , "; m0:thm2:ASM"
    , "(assert (not (elem@@sl$Addr_0 LH"
    , "                              (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))))"
    , "; m0:thm3:ASM"
    , "(assert (not (elem@@sl$Addr_0 RH"
    , "                              (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))))"
    , "; m1:act0"
    , "(assert (= lh@prime LH))"
    , "; m1:act1"
    , "(assert (= state@prime"
    , "           (ite (= LH dummy) sl$cEmpty sl$cNonEmpty)))"
    , "; m1:inv0"
    , "(assert (= (= state sl$cBot) (and (not popL) (not remL))))"
    , "; m1:inv3"
    , "(assert (= popL"
    , "           (elem@@sl$State state"
    , "                           (union (mk-set@@sl$State sl$cInit)"
    , "                                  (mk-set@@sl$State sl$cNonEmpty)))))"
    , "; m1:inv4"
    , "(assert (=> (= state sl$cPopped)"
    , "            (and remL"
    , "                 (elem@@sl$Addr_0 lh"
    , "                                  (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))"
    , "                 (= (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash lh))"
    , "                    resL))))"
    , "; m1:inv5"
    , "(assert (= remL"
    , "           (elem@@sl$State state"
    , "                           (union (mk-set@@sl$State sl$cPopped)"
    , "                                  (mk-set@@sl$State sl$cEmpty)))))"
    , "; m1:inv6"
    , "(assert (= (= state sl$cEmpty) (and remL (= resL sl$bot))))"
    , "; m1:inv7"
    , "(assert (forall ( (p sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 p"
    , "                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link))"
    , "                       (elem@@sl$OBJ_0 (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link p))"
    , "                                       sl$OBJ))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ_0 (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link p))"
    , "                                     sl$OBJ) ))))"
    , "; m1:sch0"
    , "(assert (elem@@sl$State state"
    , "                        (union (mk-set@@sl$State sl$cInit)"
    , "                               (mk-set@@sl$State sl$cNonEmpty))))"
    , "; ver"
    , "(assert (= ver@prime (ite (= LH dummy) (+ ver 1) ver)))"
    , "(assert (not (=> (and (= v0 ver)"
    , "                      (= state sl$cNonEmpty)"
    , "                      (not (or (= rh RH) (not (= v0 ver)))))"
    , "                 (or (and (= v0 ver@prime) (= state@prime sl$cNonEmpty))"
    , "                     (= rh@prime RH@prime)"
    , "                     (not (= v0 ver@prime))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m2/read:LH/SAF/LIVE/m2:prog0/ensure"
    ]

result53 :: String
result53 = unlines
    [ "; m1/INIT/FIS/sl$trash"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(declare-datatypes (a1)"
    , "                   ( (Record-item (Record-item (@@field@@_item a1))) ))"
    , "(declare-datatypes (a1 a2 a3)"
    , "                   ( (Record-item-left-right (Record-item-left-right (@@field@@_item a1)"
    , "                                                                     (@@field@@_left a2)"
    , "                                                                     (@@field@@_right a3))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "(declare-sort sl$Addr_0 0)"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$OBJ_0 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(declare-sort sl$State 0)"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const LH sl$Addr_0)"
    , "(declare-const RH sl$Addr_0)"
    , "(declare-const dummy sl$Addr_0)"
    , "(declare-const free (set sl$Addr_0))"
    , "(declare-const lh sl$Addr_0)"
    , "(declare-const popL Bool)"
    , "(declare-const remL Bool)"
    , "(declare-const resL sl$OBJ_0)"
    , "(declare-const result sl$OBJ_0)"
    , "(declare-const state sl$State)"
    , "(declare-const ver Int)"
    , "(declare-const sl$bot sl$OBJ_0)"
    , "(declare-const sl$cBot sl$State)"
    , "(declare-const sl$cEmpty sl$State)"
    , "(declare-const sl$cInit sl$State)"
    , "(declare-const sl$cNonEmpty sl$State)"
    , "(declare-const sl$cPopped sl$State)"
    , "(declare-const sl$link"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-const sl$trash"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "               sl$Addr_0 )"
    , "             (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "(declare-fun card@@sl$Addr_0 ( (set sl$Addr_0) ) Int)"
    , "(declare-fun card@@sl$OBJ_0 ( (set sl$OBJ_0) ) Int)"
    , "(declare-fun card@@sl$State ( (set sl$State) ) Int)"
    , "(declare-fun card@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0)) )"
    , "             Int)"
    , "(declare-fun const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (Record-item sl$OBJ_0) )"
    , "             (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "(declare-fun dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (set sl$Addr_0))"
    , "(declare-fun dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (set sl$Addr_0)"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (set sl$Addr_0)"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ()"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun finite@@sl$Addr_0 ( (set sl$Addr_0) ) Bool)"
    , "(declare-fun finite@@sl$OBJ_0 ( (set sl$OBJ_0) ) Bool)"
    , "(declare-fun finite@@sl$State ( (set sl$State) ) Bool)"
    , "(declare-fun finite@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0)) )"
    , "             Bool)"
    , "(declare-fun ident@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ()"
    , "             (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "(declare-fun injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             Bool)"
    , "(declare-fun mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             (sl$Addr_0 (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun mk-set@@sl$Addr_0 (sl$Addr_0) (set sl$Addr_0))"
    , "(declare-fun mk-set@@sl$OBJ_0 (sl$OBJ_0) (set sl$OBJ_0))"
    , "(declare-fun mk-set@@sl$State (sl$State) (set sl$State))"
    , "(declare-fun mk-set@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (Record-item sl$OBJ_0) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(declare-fun ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "             ( (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "               (pfun sl$Addr_0"
    , "                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "             (pfun sl$Addr_0"
    , "                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "(declare-fun set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close"
    , "             ( (set (Record-item sl$OBJ_0))"
    , "               (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(declare-fun @@lambda@@_0"
    , "             ( (set sl$OBJ_0) )"
    , "             (set (Record-item sl$OBJ_0)))"
    , "(define-fun all@@sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              true ))"
    , "(define-fun all@@sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              true ))"
    , "(define-fun all@@sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              true ))"
    , "(define-fun all@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (as const (set (Record-item sl$OBJ_0)))"
    , "              true ))"
    , "(define-fun compl@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0)) )"
    , "            (set sl$Addr_0)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0)) )"
    , "            (set sl$OBJ_0)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$State"
    , "            ( (s1 (set sl$State)) )"
    , "            (set sl$State)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0))) )"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@sl$Addr_0"
    , "            ( (x sl$Addr_0)"
    , "              (s1 (set sl$Addr_0)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$OBJ_0"
    , "            ( (x sl$OBJ_0)"
    , "              (s1 (set sl$OBJ_0)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$State"
    , "            ( (x sl$State)"
    , "              (s1 (set sl$State)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (x (Record-item sl$OBJ_0))"
    , "              (s1 (set (Record-item sl$OBJ_0))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              false ))"
    , "(define-fun empty-set@@sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              false ))"
    , "(define-fun empty-set@@sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              false ))"
    , "(define-fun empty-set@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            ( (as const (set (Record-item sl$OBJ_0)))"
    , "              false ))"
    , "(define-fun set-diff@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0))"
    , "              (s2 (set sl$Addr_0)) )"
    , "            (set sl$Addr_0)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0))"
    , "              (s2 (set sl$OBJ_0)) )"
    , "            (set sl$OBJ_0)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$State"
    , "            ( (s1 (set sl$State))"
    , "              (s2 (set sl$State)) )"
    , "            (set sl$State)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0)))"
    , "              (s2 (set (Record-item sl$OBJ_0))) )"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl$Addr_0"
    , "            ( (s1 (set sl$Addr_0))"
    , "              (s2 (set sl$Addr_0)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$OBJ_0"
    , "            ( (s1 (set sl$OBJ_0))"
    , "              (s2 (set sl$OBJ_0)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$State"
    , "            ( (s1 (set sl$State))"
    , "              (s2 (set sl$State)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@Record-item@@sl$OBJ_0@Close"
    , "            ( (s1 (set (Record-item sl$OBJ_0)))"
    , "              (s2 (set (Record-item sl$OBJ_0))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Addr_0"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            ( (as const (set sl$Addr_0))"
    , "              true ))"
    , "(define-fun sl$OBJ_0"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            ( (as const (set sl$OBJ_0))"
    , "              true ))"
    , "(define-fun sl$State"
    , "            ()"
    , "            (set sl$State)"
    , "            ( (as const (set sl$State))"
    , "              true ))"
    , "(define-fun sl$shared"
    , "            ()"
    , "            (pfun sl$Addr_0"
    , "                  (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))"
    , "            (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash sl$link))"
    , "(define-fun sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ_0)"
    , "            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "(define-fun sl$Node"
    , "            ()"
    , "            (set (Record-item sl$OBJ_0))"
    , "            (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close (@@lambda@@_0 (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))"
    , "                                                                                     ident@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(define-fun sl$Addr"
    , "            ()"
    , "            (set sl$Addr_0)"
    , "            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (finite@Open@@Record-item@@sl$OBJ_0@Close r)"
    , "                       (<= 0 (card@Open@@Record-item@@sl$OBJ_0@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@Record-item@@sl$OBJ_0@Close r)) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (=> (finite@@sl$Addr_0 r) (<= 0 (card@@sl$Addr_0 r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Addr_0 r)) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (=> (finite@@sl$OBJ_0 r) (<= 0 (card@@sl$OBJ_0 r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$OBJ_0 r)) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (=> (finite@@sl$State r) (<= 0 (card@@sl$State r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$State r)) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (= (card@Open@@Record-item@@sl$OBJ_0@Close r) 0)"
    , "                      (= r empty-set@Open@@Record-item@@sl$OBJ_0@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close r) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (= (= (card@@sl$Addr_0 r) 0)"
    , "                      (= r empty-set@@sl$Addr_0))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 r) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (= (= (card@@sl$OBJ_0 r) 0)"
    , "                      (= r empty-set@@sl$OBJ_0))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 r) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (= (= (card@@sl$State r) 0)"
    , "                      (= r empty-set@@sl$State))"
    , "                   :pattern"
    , "                   ( (card@@sl$State r) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (= (card@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)) ))))"
    , "(assert (forall ( (x sl$Addr_0) )"
    , "                (! (= (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))"
    , "(assert (forall ( (x sl$OBJ_0) )"
    , "                (! (= (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))"
    , "(assert (forall ( (x sl$State) )"
    , "                (! (= (card@@sl$State (mk-set@@sl$State x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$State (mk-set@@sl$State x)) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (= (card@Open@@Record-item@@sl$OBJ_0@Close r) 1)"
    , "                      (exists ( (x (Record-item sl$OBJ_0)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close r) ))))"
    , "(assert (forall ( (r (set sl$Addr_0)) )"
    , "                (! (= (= (card@@sl$Addr_0 r) 1)"
    , "                      (exists ( (x sl$Addr_0) )"
    , "                              (and true (= r (mk-set@@sl$Addr_0 x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 r) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0)) )"
    , "                (! (= (= (card@@sl$OBJ_0 r) 1)"
    , "                      (exists ( (x sl$OBJ_0) )"
    , "                              (and true (= r (mk-set@@sl$OBJ_0 x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 r) ))))"
    , "(assert (forall ( (r (set sl$State)) )"
    , "                (! (= (= (card@@sl$State r) 1)"
    , "                      (exists ( (x sl$State) )"
    , "                              (and true (= r (mk-set@@sl$State x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$State r) ))))"
    , "(assert (forall ( (r (set (Record-item sl$OBJ_0)))"
    , "                  (r0 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@Record-item@@sl$OBJ_0@Close)"
    , "                       (= (card@Open@@Record-item@@sl$OBJ_0@Close (union r r0))"
    , "                          (+ (card@Open@@Record-item@@sl$OBJ_0@Close r)"
    , "                             (card@Open@@Record-item@@sl$OBJ_0@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@Record-item@@sl$OBJ_0@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Addr_0))"
    , "                  (r0 (set sl$Addr_0)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Addr_0)"
    , "                       (= (card@@sl$Addr_0 (union r r0))"
    , "                          (+ (card@@sl$Addr_0 r) (card@@sl$Addr_0 r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Addr_0 (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$OBJ_0))"
    , "                  (r0 (set sl$OBJ_0)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$OBJ_0)"
    , "                       (= (card@@sl$OBJ_0 (union r r0))"
    , "                          (+ (card@@sl$OBJ_0 r) (card@@sl$OBJ_0 r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ_0 (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$State))"
    , "                  (r0 (set sl$State)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$State)"
    , "                       (= (card@@sl$State (union r r0))"
    , "                          (+ (card@@sl$State r) (card@@sl$State r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$State (union r r0)) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (select (const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                              y)"
    , "                      x)"
    , "                   :pattern"
    , "                   ( (select (const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                             y) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (= (select ident@Open@@Record-item@@sl$OBJ_0@Close x)"
    , "                      x)"
    , "                   :pattern"
    , "                   ( (select ident@Open@@Record-item@@sl$OBJ_0@Close x) ))))"
    , "(assert (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)"
    , "           empty-set@@sl$Addr_0))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                         empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                        empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "                                                                                                         f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close"
    , "                                                                                                        f1) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                      (mk-set@@sl$Addr_0 x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 x"
    , "                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (and (elem@@sl$Addr_0 x"
    , "                                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                            (not (elem@@sl$Addr_0 x"
    , "                                                  (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2))))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)"
    , "                                                                                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (and (elem@@sl$Addr_0 x s1)"
    , "                            (elem@@sl$Addr_0 x"
    , "                                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0))"
    , "                  (x sl$Addr_0) )"
    , "                (! (=> (elem@@sl$Addr_0 x"
    , "                                        (set-diff@@sl$Addr_0 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                                                             s1))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                               x)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (f2 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2))"
    , "                      (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))"
    , "                      (intersect s1"
    , "                                 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (s1 (set sl$Addr_0)) )"
    , "                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))"
    , "                      (set-diff@@sl$Addr_0 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                                           s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (and (elem@@sl$Addr_0 x"
    , "                                            (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                           (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                              y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr_0 x"
    , "                                      (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                     (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (x2 sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                                  (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                               x2)"
    , "                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                             (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                  (x sl$Addr_0)"
    , "                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )"
    , "                (! (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                              (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1"
    , "                                                                                                                                                                                             (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))"
    , "                                                                                                          x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Addr_0"
    , "                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )"
    , "                (! (= (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)"
    , "                      (forall ( (x sl$Addr_0)"
    , "                                (x2 sl$Addr_0) )"
    , "                              (=> (and (elem@@sl$Addr_0 x"
    , "                                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))"
    , "                                       (elem@@sl$Addr_0 x2"
    , "                                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))"
    , "                                  (=> (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)"
    , "                                         (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1) ))))"
    , "(assert (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close x (mk-set@Open@@Record-item@@sl$OBJ_0@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close x (mk-set@Open@@Record-item@@sl$OBJ_0@Close y)) ))))"
    , "(assert (forall ( (x sl$Addr_0)"
    , "                  (y sl$Addr_0) )"
    , "                (! (= (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) ))))"
    , "(assert (forall ( (x sl$OBJ_0)"
    , "                  (y sl$OBJ_0) )"
    , "                (! (= (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) ))))"
    , "(assert (forall ( (x sl$State)"
    , "                  (y sl$State) )"
    , "                (! (= (elem@@sl$State x (mk-set@@sl$State y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$State x (mk-set@@sl$State y)) ))))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0)))"
    , "                  (term (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close y"
    , "                                                              (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term))"
    , "                      (exists ( (x (Record-item sl$OBJ_0)) )"
    , "                              (and (elem@Open@@Record-item@@sl$OBJ_0@Close x r1)"
    , "                                   (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close y"
    , "                                                             (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)) ))))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0)))"
    , "                  (term (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))"
    , "                  (y (Record-item sl$OBJ_0)) )"
    , "                (! (= (= (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)"
    , "                         (mk-set@Open@@Record-item@@sl$OBJ_0@Close y))"
    , "                      (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                              (=> (elem@Open@@Record-item@@sl$OBJ_0@Close x r1)"
    , "                                  (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)"
    , "                     (mk-set@Open@@Record-item@@sl$OBJ_0@Close y) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (finite@Open@@Record-item@@sl$OBJ_0@Close s1)"
    , "                       (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (finite@@sl$Addr_0 s1)"
    , "                       (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (finite@@sl$OBJ_0 s1)"
    , "                       (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (finite@@sl$State s1)"
    , "                       (finite@@sl$State (set-diff@@sl$State s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (and (finite@Open@@Record-item@@sl$OBJ_0@Close s1)"
    , "                            (finite@Open@@Record-item@@sl$OBJ_0@Close s2))"
    , "                       (finite@Open@@Record-item@@sl$OBJ_0@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (and (finite@@sl$Addr_0 s1) (finite@@sl$Addr_0 s2))"
    , "                       (finite@@sl$Addr_0 (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (and (finite@@sl$OBJ_0 s1) (finite@@sl$OBJ_0 s2))"
    , "                       (finite@@sl$OBJ_0 (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (and (finite@@sl$State s1) (finite@@sl$State s2))"
    , "                       (finite@@sl$State (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))"
    , "                  (s2 (set (Record-item sl$OBJ_0))) )"
    , "                (! (=> (and (finite@Open@@Record-item@@sl$OBJ_0@Close s2)"
    , "                            (not (finite@Open@@Record-item@@sl$OBJ_0@Close s1)))"
    , "                       (not (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Addr_0))"
    , "                  (s2 (set sl$Addr_0)) )"
    , "                (! (=> (and (finite@@sl$Addr_0 s2)"
    , "                            (not (finite@@sl$Addr_0 s1)))"
    , "                       (not (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ_0))"
    , "                  (s2 (set sl$OBJ_0)) )"
    , "                (! (=> (and (finite@@sl$OBJ_0 s2) (not (finite@@sl$OBJ_0 s1)))"
    , "                       (not (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$State))"
    , "                  (s2 (set sl$State)) )"
    , "                (! (=> (and (finite@@sl$State s2) (not (finite@@sl$State s1)))"
    , "                       (not (finite@@sl$State (set-diff@@sl$State s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))"
    , "(assert (forall ( (x (Record-item sl$OBJ_0)) )"
    , "                (! (finite@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)) ))))"
    , "(assert (forall ( (x sl$Addr_0) )"
    , "                (! (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))"
    , "(assert (forall ( (x sl$OBJ_0) )"
    , "                (! (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))"
    , "(assert (forall ( (x sl$State) )"
    , "                (! (finite@@sl$State (mk-set@@sl$State x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$State (mk-set@@sl$State x)) ))))"
    , "(assert (finite@Open@@Record-item@@sl$OBJ_0@Close empty-set@Open@@Record-item@@sl$OBJ_0@Close))"
    , "(assert (finite@@sl$Addr_0 empty-set@@sl$Addr_0))"
    , "(assert (finite@@sl$OBJ_0 empty-set@@sl$OBJ_0))"
    , "(assert (finite@@sl$State empty-set@@sl$State))"
    , "(assert (forall ( (r1 (set (Record-item sl$OBJ_0))) )"
    , "                (! (= (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 ident@Open@@Record-item@@sl$OBJ_0@Close)"
    , "                      r1)"
    , "                   :pattern"
    , "                   ( (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 ident@Open@@Record-item@@sl$OBJ_0@Close) ))))"
    , "(assert (forall ( (@@fv@@_0 (set sl$OBJ_0))"
    , "                  (@@bv@@_0 (Record-item sl$OBJ_0)) )"
    , "                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close @@bv@@_0 (@@lambda@@_0 @@fv@@_0))"
    , "                      (elem@@sl$OBJ_0 (@@field@@_item @@bv@@_0) @@fv@@_0))"
    , "                   :pattern"
    , "                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close @@bv@@_0 (@@lambda@@_0 @@fv@@_0)) ))))"
    , "; m0:asm0"
    , "(assert (not (= sl$cInit sl$cBot)))"
    , "; m0:asm1"
    , "(assert (not (= sl$cInit sl$cEmpty)))"
    , "; m0:asm2"
    , "(assert (not (= sl$cInit sl$cNonEmpty)))"
    , "; m0:asm3"
    , "(assert (not (= sl$cInit sl$cPopped)))"
    , "; m0:asm4"
    , "(assert (not (= sl$cBot sl$cEmpty)))"
    , "; m0:asm5"
    , "(assert (not (= sl$cBot sl$cNonEmpty)))"
    , "; m0:asm6"
    , "(assert (not (= sl$cBot sl$cPopped)))"
    , "; m0:asm7"
    , "(assert (not (= sl$cEmpty sl$cNonEmpty)))"
    , "; m0:asm8"
    , "(assert (not (= sl$cEmpty sl$cPopped)))"
    , "; m0:asm9"
    , "(assert (not (= sl$cNonEmpty sl$cPopped)))"
    , "; m0:init0"
    , "(assert (= LH dummy))"
    , "; m0:init1"
    , "(assert (= RH dummy))"
    , "; m0:init2"
    , "(assert (= free sl$Addr))"
    , "; m0:init3"
    , "(assert (= ver 0))"
    , "; m0:init4"
    , "(assert (= result sl$bot))"
    , "; m0:init5"
    , "(assert (= sl$link"
    , "           empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close))"
    , "; m1:init0"
    , "(assert (= lh dummy))"
    , "; m1:init2"
    , "(assert (= state sl$cBot))"
    , "(assert (not (exists ( (sl$trash (pfun sl$Addr_0"
    , "                                       (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))"
    , "                       (x sl$OBJ_0) )"
    , "                     (and true"
    , "                          (= sl$trash"
    , "                             (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close dummy (Record-item-left-right x dummy dummy)))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/INIT/FIS/sl$trash"
    ]
